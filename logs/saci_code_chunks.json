{
  "./saci_web_orchestrator.py::header": "# saci_web_orchestrator.py\nfrom fastapi import FastAPI, Request, Form\nfrom fastapi.responses import HTMLResponse, RedirectResponse\nfrom fastapi.staticfiles import StaticFiles\nfrom pydantic import BaseModel\nimport subprocess\nimport os\nimport json\nimport openai\nfrom datetime import datetime\n\nopenai.api_key = os.getenv(\"OPENAI_API_KEY\")\n\napp = FastAPI()\napp.mount(\"/static\", StaticFiles(directory=\"static\"), name=\"static\")",
  "./saci_web_orchestrator.py::class_PromptInput": "class PromptInput(BaseModel):\n    prompt: str\n    agent: str = \"architect\"\n\n@app.get(\"/\", response_class=HTMLResponse)",
  "./saci_web_orchestrator.py::def_root": "def root():\n    return \"\"\"\n    <html>\n      <head>\n        <title>SACI WebApp</title>\n        <style>\n          body { font-family: sans-serif; max-width: 800px; margin: 40px; }\n          textarea { width: 100%; }\n          .block { margin-top: 30px; padding: 15px; background: #f5f5f5; border-radius: 8px; }\n          code { background: #eee; padding: 2px 6px; border-radius: 4px; }\n        </style>\n        <script>\n          async function refreshData() {\n            const status = await fetch('/status').then(r => r.json());\n            const patch = await fetch('/patch').then(r => r.json());\n            const review = await fetch('/review').then(r => r.json());\n            const metrics = await fetch('/metrics').then(r => r.json());\n\n            document.getElementById(\"goal\").innerText = status.goal || '‚Äî';\n            document.getElementById(\"status\").innerText = status.status || '‚Äî';\n            document.getElementById(\"patch\").innerText = patch.patch || '‚Äî';\n            document.getElementById(\"review\").innerText = (review.review || '').slice(0, 1000);\n            document.getElementById(\"metrics\").innerText = metrics.current ?\n              `üìÑ –§–∞–π–ª–æ–≤: ${metrics.current.files}, üìè –°—Ç—Ä–æ–∫: ${metrics.current.lines}` : '‚Äî';\n          }\n          setInterval(refreshData, 8000);\n          window.onload = refreshData;\n        </script>\n      </head>\n      <body>\n        <h2>üß† SACI Web Dashboard</h2>\n\n        <form method=\"post\" action=\"/prompt\">\n          <textarea name=\"prompt\" rows=\"4\" placeholder=\"–í–≤–µ–¥–∏—Ç–µ –ø—Ä–æ–º–ø—Ç...\" required></textarea><br>\n          <select name=\"agent\">\n            <option value=\"architect\">üß† Architect</option>\n            <option value=\"developer\">üë®‚Äçüíª Developer</option>\n            <option value=\"strategist\">üéØ Strategist</option>\n          </select>\n          <button type=\"submit\">üöÄ –ó–∞–ø—É—Å—Ç–∏—Ç—å –∑–∞–¥–∞—á—É</button>\n        </form>\n\n        <div class=\"block\">\n          <h4>üìå –¢–µ–∫—É—â–∞—è —Ü–µ–ª—å</h4>\n          <div id=\"goal\">‚Äî</div>\n\n          <h4>üß¨ –°—Ç–∞—Ç—É—Å</h4>\n          <div id=\"status\">‚Äî</div>\n\n          <h4>üìÑ –ü–æ—Å–ª–µ–¥–Ω–∏–π –ø–∞—Ç—á</h4>\n          <div><code id=\"patch\">‚Äî</code></div>\n\n          <h4>üìò –ü–æ—Å–ª–µ–¥–Ω–µ–µ —Ä–µ–≤—å—é</h4>\n          <pre id=\"review\">‚Äî</pre>\n\n          <h4>üìä –ú–µ—Ç—Ä–∏–∫–∏</h4>\n          <div id=\"metrics\">‚Äî</div>\n        </div>\n\n        <form onsubmit=\"return fetchAndAlert(event, '/apply')\">\n  <button type=\"submit\">‚úÖ –ü—Ä–∏–º–µ–Ω–∏—Ç—å –ø–∞—Ç—á</button>\n</form>\n\n<form onsubmit=\"return fetchAndAlert(event, '/agree')\">\n  <button type=\"submit\">üìò –°–æ–≥–ª–∞—Å–æ–≤–∞—Ç—å</button>\n</form>\n\n<script>\n  async function fetchAndAlert(e, endpoint) {\n    e.preventDefault();\n    const res = await fetch(endpoint, { method: \"POST\" });\n    const txt = await res.text();\n    alert(txt);\n    await refreshData();\n    return false;\n  }\n</script>\n\n\n        <p><a href=\"/docs\">üìñ Swagger API Docs</a></p>\n      </body>\n    </html>\n    \"\"\"\n\n@app.post(\"/prompt\")",
  "./saci_web_orchestrator.py::def_receive_prompt_form": "def receive_prompt_form(prompt: str = Form(...), agent: str = Form(\"architect\")):\n    task_id = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n    goal = f\"–°–æ–∑–¥–∞—Ç—å –º–æ–¥—É–ª—å –Ω–∞ –æ—Å–Ω–æ–≤–µ –∑–∞–ø—Ä–æ—Å–∞: {prompt}\"\n\n    goal_state = {\n        \"goal\": goal,\n        \"status\": \"in_progress\",\n        \"timestamp\": datetime.now().strftime(\"%Y-%m-%d %H:%M\"),\n        \"source\": \"webapp\",\n        \"task_id\": task_id,\n        \"dev_done\": False,\n        \"test_done\": False\n    }\n    with open(\"saci_goal_state.json\", \"w\", encoding=\"utf-8\") as f:\n        json.dump(goal_state, f, indent=4, ensure_ascii=False)\n\n    subprocess.Popen([\"python\", \"agents/code_refactor.py\"])\n    return RedirectResponse(\"/\", status_code=303)\n\n@app.post(\"/apply\")",
  "./saci_web_orchestrator.py::def_apply_patch_web": "def apply_patch_web():\n    patch_name = None\n    if os.path.exists(\"patches\"):\n        patches = sorted([f for f in os.listdir(\"patches\") if f.endswith((\".patch\", \".diff\"))])\n        patch_name = patches[-1].replace(\".patch\", \"\").replace(\".diff\", \"\") if patches else None\n\n    if not patch_name:\n        return HTMLResponse(\"<p>‚ùå –ù–µ—Ç –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –ø–∞—Ç—á–µ–π.</p>\")\n\n    for ext in [\".patch\", \".diff\"]:\n        path = f\"patches/{patch_name}{ext}\"\n        if os.path.exists(path):\n            os.system(f\"git apply {path}\")\n            return RedirectResponse(\"/\", status_code=303)\n    return HTMLResponse(\"<p>‚ùå Patch –Ω–µ –Ω–∞–π–¥–µ–Ω.</p>\")\n\n@app.post(\"/agree\")",
  "./saci_web_orchestrator.py::def_agree_patch_web": "def agree_patch_web():\n    patch_name = None\n    if os.path.exists(\"patches\"):\n        patches = sorted([f for f in os.listdir(\"patches\") if f.endswith((\".patch\", \".diff\"))])\n        patch_name = patches[-1].replace(\".patch\", \"\").replace(\".diff\", \"\") if patches else None\n\n    if not patch_name:\n        return HTMLResponse(\"<p>‚ùå –ù–µ—Ç –ø–∞—Ç—á–∞ –¥–ª—è —Å–æ–≥–ª–∞—Å–æ–≤–∞–Ω–∏—è.</p>\")\n\n    log_path = \"logs/goals_log.json\"\n    os.makedirs(\"logs\", exist_ok=True)\n    log = []\n    if os.path.exists(log_path):\n        with open(log_path, \"r\", encoding=\"utf-8\") as f:\n            log = json.load(f)\n\n    log.append({\n        \"type\": \"patch\",\n        \"patch\": patch_name,\n        \"status\": \"applied\",\n        \"agreed\": True,\n        \"timestamp\": datetime.now().strftime(\"%Y-%m-%d %H:%M\")\n    })\n\n    with open(log_path, \"w\", encoding=\"utf-8\") as f:\n        json.dump(log, f, indent=4, ensure_ascii=False)\n\n    return RedirectResponse(\"/\", status_code=303)\n\n@app.get(\"/status\")",
  "./saci_web_orchestrator.py::def_get_status": "def get_status():\n    if not os.path.exists(\"saci_goal_state.json\"):\n        return {\"status\": \"–Ω–µ—Ç –∞–∫—Ç–∏–≤–Ω–æ–π —Ü–µ–ª–∏\"}\n    with open(\"saci_goal_state.json\", \"r\", encoding=\"utf-8\") as f:\n        state = json.load(f)\n    return state\n\n@app.get(\"/patch\")",
  "./saci_web_orchestrator.py::def_get_latest_patch": "def get_latest_patch():\n    if not os.path.exists(\"patches\"):\n        return {\"patch\": None}\n    patches = sorted([f for f in os.listdir(\"patches\") if f.endswith((\".patch\", \".diff\"))])\n    if not patches:\n        return {\"patch\": None}\n    return {\"patch\": patches[-1]}\n\n@app.get(\"/review\")",
  "./saci_web_orchestrator.py::def_get_review": "def get_review():\n    if not os.path.exists(\"logs/patch_reviews\"):\n        return {\"review\": None}\n    reviews = sorted(os.listdir(\"logs/patch_reviews\"))\n    if not reviews:\n        return {\"review\": None}\n    latest = reviews[-1]\n    with open(os.path.join(\"logs/patch_reviews\", latest), \"r\", encoding=\"utf-8\") as f:\n        content = f.read()\n    return {\"review\": content, \"file\": latest}\n\n@app.get(\"/metrics\")",
  "./saci_web_orchestrator.py::def_get_code_metrics": "def get_code_metrics():\n    path = \"logs/code_metrics.json\"\n    if not os.path.exists(path):\n        return {\"message\": \"–ù–µ—Ç –º–µ—Ç—Ä–∏–∫\"}\n    with open(path, \"r\", encoding=\"utf-8\") as f:\n        log = json.load(f)\n    return {\"current\": log[-1], \"previous\": log[-2] if len(log) > 1 else None}",
  "./fix_goal_state.py::header": "import json\nfrom datetime import datetime\n\nGOAL_STATE = \"saci_goal_state.json\"\n\ngoal = {\n    \"goal\": \"–î–æ–±–∞–≤–∏—Ç—å —Ç–µ—Å—Ç–æ–≤—ã–π –º–æ–¥—É–ª—å: tests/test_patch_predictor.py\",\n    \"status\": \"complete\",\n    \"timestamp\": datetime.now().strftime(\"%Y-%m-%d %H:%M\"),\n    \"dev_done\": True,\n    \"test_done\": True\n}\n\nwith open(GOAL_STATE, \"w\", encoding=\"utf-8\") as f:\n    json.dump(goal, f, indent=4, ensure_ascii=False)\n\nprint(\"‚úÖ saci_goal_state.json —É—Å–ø–µ—à–Ω–æ –æ–±–Ω–æ–≤–ª—ë–Ω.\")",
  "./telegram_bot.py::header": "import telebot\nfrom telebot.types import ReplyKeyboardMarkup, KeyboardButton\nfrom telebot.types import InlineKeyboardMarkup, InlineKeyboardButton\nfrom agents.code_refactor import generate_patch_review\nimport json\nfrom datetime import datetime\nfrom goal_pipeline import process_scan, process_accept, process_reject, get_status\nimport os\nfrom dotenv import load_dotenv\nimport subprocess\nfrom agents.code_refactor import (\n    generate_all_reviews_markdown,\n    send_review_markdown_to_telegram\n)\nimport sys\nimport os\nsys.path.append(os.path.abspath(\".\"))\n\nload_dotenv()\nTOKEN = os.getenv(\"TELEGRAM_BOT_TOKEN\")\nbot = telebot.TeleBot(TOKEN)",
  "./telegram_bot.py::def_safe_patch_slice": "def safe_patch_slice(patch_text, max_chars=3000):\n    lines = patch_text.splitlines(keepends=True)\n    result = \"\"\n    total = 0\n    for line in lines:\n        if total + len(line) > max_chars:\n            break\n        result += line\n        total += len(line)\n    return result",
  "./telegram_bot.py::def_saci_run": "def saci_run(module: str):\n    try:\n        subprocess.Popen([\"python\", \"-m\", module])\n    except Exception as e:\n        print(f\"‚ùå –û—à–∏–±–∫–∞ –∑–∞–ø—É—Å–∫–∞ –º–æ–¥—É–ª—è {module}: {e}\")",
  "./telegram_bot.py::def_send_long_text": "def send_long_text(chat_id, header, body, chunk_limit=3900):\n    paragraphs = body.split(\"\\n\\n\")\n    chunks = []\n    current = \"\"\n\n    for para in paragraphs:\n        if len(current) + len(para) + 2 <= chunk_limit:\n            current += para + \"\\n\\n\"\n        else:\n            chunks.append(current.strip())\n            current = para + \"\\n\\n\"\n    if current:\n        chunks.append(current.strip())\n\n    for i, chunk in enumerate(chunks):\n        prefix = f\"{header} (—á–∞—Å—Ç—å {i+1}/{len(chunks)}):\\n\\n\" if len(chunks) > 1 else f\"{header}\\n\\n\"\n        bot.send_message(chat_id, prefix + chunk)\n\n@bot.message_handler(commands=['panel'])",
  "./telegram_bot.py::def_patch_panel": "def patch_panel(message):\n    markup = InlineKeyboardMarkup(row_width=2)\n    markup.add(\n        InlineKeyboardButton(\"üìÑ –ü—Ä–æ—Å–º–æ—Ç—Ä –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ\", callback_data=\"review:last\"),\n        InlineKeyboardButton(\"‚úÖ –ü—Ä–∏–º–µ–Ω–∏—Ç—å\", callback_data=\"apply:last\")\n    )\n    markup.row(\n        InlineKeyboardButton(\"üß† Architect\", callback_data=\"review_agent:last:architect\"),\n        InlineKeyboardButton(\"üë®‚Äçüíª Developer\", callback_data=\"review_agent:last:developer\"),\n        InlineKeyboardButton(\"üéØ Strategist\", callback_data=\"review_agent:last:strategist\")\n    )\n    markup.row(\n        InlineKeyboardButton(\"üìò –õ–æ–≥ —Ä–µ–≤—å—é\", callback_data=\"review_file:last\"),\n        InlineKeyboardButton(\"üîÑ –ü–µ—Ä–µ–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å\", callback_data=\"refactor:latest\"),\n        InlineKeyboardButton(\"‚èπ –û—Å—Ç–∞–Ω–æ–≤–∏—Ç—å\", callback_data=\"stop:auto\")\n    )\n    bot.send_message(\n        message.chat.id,\n        \"üõ† SACI –ü–ê–ù–ï–õ–¨: –≤—ã–±–µ—Ä–∏ –¥–µ–π—Å—Ç–≤–∏–µ —Å –ø–æ—Å–ª–µ–¥–Ω–∏–º –ø–∞—Ç—á–µ–º:\",\n        reply_markup=markup\n    )\n\n@bot.callback_query_handler(func=lambda call: True)",
  "./telegram_bot.py::def_handle_callback": "def handle_callback(call):\n    data = call.data\n\n    if data.startswith(\"review:\"):\n        patch = data.split(\":\", 1)[1]\n        path = f\"patches/{patch}.patch\"\n        if os.path.exists(path):\n            with open(path, \"r\", encoding=\"utf-8\") as f:\n                content = f.read()[:3900]\n            bot.send_message(call.message.chat.id, f\"üìÑ Patch `{patch}`:\\n\\n{content}\")\n        else:\n            bot.send_message(call.message.chat.id, \"‚ùå Patch –Ω–µ –Ω–∞–π–¥–µ–Ω.\")\n\n    elif data == \"stop:auto\":\n        with open(\".saci_stop\", \"w\") as f:\n            f.write(\"stop\")\n        bot.send_message(call.message.chat.id, \"üõë AutoLoop –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω.\")\n\n    elif data == \"refactor:latest\":\n        bot.send_message(call.message.chat.id, \"üîÑ –ü–µ—Ä–µ–≥–µ–Ω–µ—Ä–∏—Ä—É—é –ø–∞—Ç—á...\")\n        subprocess.Popen([\"python\", \"-m\", \"agents.code_refactor\"])\n\n    elif data == \"review_file:last\":\n        import glob\n        latest = sorted(glob.glob(\"logs/patch_reviews/*.md\"))[-1]\n        if latest:\n            with open(latest, \"rb\") as f:\n                bot.send_document(call.message.chat.id, f, caption=\"üìò –ü–æ—Å–ª–µ–¥–Ω–µ–µ —Ä–µ–≤—å—é\")\n        else:\n            bot.send_message(call.message.chat.id, \"‚ö†Ô∏è –†–µ–≤—å—é –Ω–µ –Ω–∞–π–¥–µ–Ω–æ.\")\n\n    elif data.startswith(\"review:last\"):\n        latest = sorted(os.listdir(\"patches\"))[-1].replace(\".patch\", \"\").replace(\".diff\", \"\")\n        call.data = f\"review:{latest}\"\n        handle_callback(call)\n\n    elif data.startswith(\"apply:last\"):\n        latest = sorted(os.listdir(\"patches\"))[-1].replace(\".patch\", \"\").replace(\".diff\", \"\")\n        call.data = f\"apply:{latest}\"\n        handle_callback(call)\n\n    elif data.startswith(\"review_agent:last\"):\n        _, _, agent = data.split(\":\")\n        latest = sorted(os.listdir(\"patches\"))[-1].replace(\".patch\", \"\").replace(\".diff\", \"\")\n        call.data = f\"review_agent:{latest}:{agent}\"\n        handle_callback(call)\n\n    elif data.startswith(\"apply:\"):\n        patch = data.split(\":\")[1]\n        patch_path = None\n        for ext in [\".patch\", \".diff\"]:\n            candidate = f\"patches/{patch}{ext}\"\n            if os.path.exists(candidate):\n                patch_path = candidate\n                break\n\n        if patch_path:\n            os.system(f\"git apply {patch_path}\")\n            bot.send_message(call.message.chat.id, f\"‚úÖ –ü–∞—Ç—á `{patch}` –ø—Ä–∏–º–µ–Ω—ë–Ω.\")\n\n            # üìÑ –°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å .md —Ä–µ–≤—å—é –æ—Ç –≤—Å–µ—Ö –∞–≥–µ–Ω—Ç–æ–≤\n            generate_all_reviews_markdown(patch)\n            send_review_markdown_to_telegram(patch)\n\n            # üëç –ü—Ä–µ–¥–ª–æ–∂–∏—Ç—å —Å–æ–≥–ª–∞—Å–æ–≤–∞–Ω–∏–µ\n            markup = InlineKeyboardMarkup()\n            markup.add(\n                InlineKeyboardButton(\"üëç –î–∞, —Å–æ–≥–ª–∞—Å–æ–≤–∞–Ω–æ\", callback_data=f\"agree:{patch}\"),\n                InlineKeyboardButton(\"üëé –ù–µ—Ç\", callback_data=f\"reject:{patch}\")\n            )\n            bot.send_message(call.message.chat.id, \"–°–æ–≥–ª–∞—Å–æ–≤–∞—Ç—å –ø–∞—Ç—á –∏ –≤–Ω–µ—Å—Ç–∏ –≤ –∂—É—Ä–Ω–∞–ª —Ü–µ–ª–µ–π?\", reply_markup=markup)\n        else:\n            bot.send_message(call.message.chat.id, \"‚ùå Patch –Ω–µ –Ω–∞–π–¥–µ–Ω.\")\n\n    elif data.startswith(\"review_agent:\"):\n        _, patch, agent = data.split(\":\")\n        review = generate_patch_review(patch, agent)\n        send_long_text(call.message.chat.id, f\"üß† –†–µ–≤—å—é –æ—Ç {agent.title()}:\", review)\n\n    elif data.startswith(\"view_rev:\"):\n        _, patch, agent = data.split(\":\")\n        review = generate_patch_review(patch, agent)\n        send_long_text(chat_id=call.message.chat.id, header=f\"üß† –†–µ–≤—å—é –æ—Ç {agent.title()}:\", body=review)\n\nprint(\"ü§ñ SACI Telegram Bot –∑–∞–ø—É—â–µ–Ω.\")\nbot.polling()",
  "./telegram_bot.py::def_start": "def start(message):\n    markup = ReplyKeyboardMarkup(resize_keyboard=True)\n    markup.row(\n        KeyboardButton(\"/scan\"),\n        KeyboardButton(\"/status\")\n    )\n    markup.row(\n        KeyboardButton(\"/accept\"),\n        KeyboardButton(\"/reject\")\n    )\n    markup.row(\n        KeyboardButton(\"/analyze all\"),\n        KeyboardButton(\"/refactor\")\n    )\n    markup.row(\n        KeyboardButton(\"/summary\"),\n        KeyboardButton(\"/log last\")\n    )\n    bot.send_message(\n        message.chat.id,\n        \"–ü—Ä–∏–≤–µ—Ç. –Ø SACI Telegram Interface.\\n\\n–ö–æ–º–∞–Ω–¥—ã:\\n\"\n        \"/scan ‚Äî –Ω–∞—á–∞—Ç—å –∞–Ω–∞–ª–∏–∑\\n\"\n        \"/accept ‚Äî –ø—Ä–∏–Ω—è—Ç—å —Ü–µ–ª—å\\n\"\n        \"/reject ‚Äî –æ—Ç–∫–ª–æ–Ω–∏—Ç—å\\n\"\n        \"/status ‚Äî —Ç–µ–∫—É—â–µ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ\\n\"\n        \"/analyze all ‚Äî –∞–Ω–∞–ª–∏–∑ –∫–æ–¥–∞\\n\"\n        \"/refactor ‚Äî –ø—Ä–µ–¥–ª–æ–∂–∏—Ç—å –ø–∞—Ç—á\\n\"\n        \"/summary ‚Äî –¥–Ω–µ–≤–Ω–æ–π –æ—Ç—á—ë—Ç\\n\"\n        \"/log last ‚Äî –ø–æ—Å–ª–µ–¥–Ω–µ–µ –¥–µ–π—Å—Ç–≤–∏–µ\",\n        reply_markup=markup\n    )\n@bot.message_handler(commands=['scan'])",
  "./telegram_bot.py::def_scan": "def scan(message):\n    result = process_scan()\n    bot.send_message(message.chat.id, result)\n\n@bot.message_handler(commands=['accept'])",
  "./telegram_bot.py::def_accept": "def accept(message):\n    result = process_accept()\n    bot.send_message(message.chat.id, result)\n\n@bot.message_handler(commands=['reject'])",
  "./telegram_bot.py::def_reject": "def reject(message):\n    result = process_reject()\n    bot.send_message(message.chat.id, result)\n\n@bot.message_handler(commands=['status'])",
  "./telegram_bot.py::def_status": "def status(message):\n    result = get_status()\n    bot.send_message(message.chat.id, result)\n\n@bot.message_handler(commands=['summary'])",
  "./telegram_bot.py::def_summary": "def summary(message):\n    try:\n        from agents.project_manager import generate_summary_rich\n        text = generate_summary_rich()\n        bot.send_message(message.chat.id, text)\n    except Exception as e:\n        bot.send_message(message.chat.id, f\"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –æ—Ç—á—ë—Ç–∞: {e}\")\n\n@bot.message_handler(commands=['stop'])",
  "./telegram_bot.py::def_stop": "def stop(message):\n    with open(\".saci_stop\", \"w\") as f:\n        f.write(\"stop\")\n    bot.send_message(message.chat.id, \"üõë –ê–≤—Ç–æ–ø–æ—Ç–æ–∫ SACI –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω.\")\n\n@bot.message_handler(commands=['analyze'])",
  "./telegram_bot.py::def_analyze": "def analyze(message):\n    text = message.text.strip()\n    if \"all\" in text:\n        bot.send_message(message.chat.id, \"üì° –ó–∞–ø—É—Å–∫–∞—é –ø–æ–ª–Ω—ã–π –∞–Ω–∞–ª–∏–∑ –≤—Å–µ—Ö —Ñ–∞–π–ª–æ–≤...\")\n        subprocess.Popen(\"python agents/code_analyst.py all\", shell=True)\n    else:\n        bot.send_message(message.chat.id, \"üîç –ó–∞–ø—É—Å–∫–∞—é –∞–Ω–∞–ª–∏–∑ –∫–ª—é—á–µ–≤—ã—Ö –º–æ–¥—É–ª–µ–π...\")\n        subprocess.Popen(\"python agents/code_analyst.py\", shell=True)\n\n@bot.message_handler(commands=['apply'])",
  "./telegram_bot.py::def_apply_patch": "def apply_patch(message):\n    try:\n        name = message.text.replace(\"/apply patch\", \"\").strip()\n        patch_variants = [\n            f\"patches/{name}.diff\",\n            f\"patches/{name}.patch\"\n        ]\n\n        patch_path = next((p for p in patch_variants if os.path.exists(p)), None)\n\n        if not patch_path:\n            all_patches = \"\\n\".join(os.listdir(\"patches\"))\n            bot.send_message(message.chat.id, f\"‚ùå –ü–∞—Ç—á `{name}` –Ω–µ –Ω–∞–π–¥–µ–Ω.\\n\\nüìÇ –í –Ω–∞–ª–∏—á–∏–∏:\\n{all_patches}\")\n            return\n\n        os.system(f\"git apply {patch_path}\")\n        bot.send_message(message.chat.id, f\"‚úÖ –ü–∞—Ç—á `{os.path.basename(patch_path)}` –ø—Ä–∏–º–µ–Ω—ë–Ω.\")\n    except Exception as e:\n        bot.send_message(message.chat.id, f\"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏–º–µ–Ω–µ–Ω–∏—è –ø–∞—Ç—á–∞: {e}\")\n\n@bot.message_handler(commands=['review'])",
  "./telegram_bot.py::def_review_patch": "def review_patch(message):\n    try:\n        text = message.text.replace(\"/review patch\", \"\").strip()\n        patch_path = f\"patches/{text}.diff\"\n\n        if not os.path.exists(patch_path):\n            bot.send_message(message.chat.id, f\"‚ùå –ü–∞—Ç—á `{text}` –Ω–µ –Ω–∞–π–¥–µ–Ω.\")\n            return\n\n        with open(patch_path, \"r\", encoding=\"utf-8\") as f:\n            patch_text = f.read()\n\n        # Telegram –æ–≥—Ä–∞–Ω–∏—á–µ–Ω 4096 —Å–∏–º–≤–æ–ª–∞–º–∏\n        if len(patch_text) > 3900:\n            patch_text = patch_text[:3900] + \"\\n...\\n[—É—Å–µ—á–µ–Ω–æ]\"\n\n        bot.send_message(message.chat.id, f\"üìÑ Patch `{text}`:\\n\\n{patch_text}\")\n\n    except Exception as e:\n        bot.send_message(message.chat.id, f\"‚ùå –û—à–∏–±–∫–∞ —á—Ç–µ–Ω–∏—è –ø–∞—Ç—á–∞: {e}\")\n\n@bot.callback_query_handler(func=lambda call: True)",
  "./goal_pipeline.py::header": "import os\nimport json\nimport subprocess\nfrom agents.architect import analyze_repo_and_suggest_goal\n\nGOAL_STATE = \"saci_goal_state.json\"",
  "./goal_pipeline.py::def_archive_completed_goal": "def archive_completed_goal():\n    if not os.path.exists(GOAL_STATE):\n        return\n    with open(GOAL_STATE) as f:\n        goal_data = json.load(f)\n    if goal_data.get(\"status\") == \"complete\":\n        print(\"üì¶ –ê—Ä—Ö–∏–≤–∏—Ä—É–µ–º –∑–∞–≤–µ—Ä—à—ë–Ω–Ω—É—é —Ü–µ–ª—å.\")\n        subprocess.run([\"python\", \"agents/project_manager.py\"])\n        os.remove(GOAL_STATE)",
  "./goal_pipeline.py::def_process_scan": "def process_scan():\n    try:\n        archive_completed_goal()\n\n        # 1. –°–∫–∞–Ω –ø—Ä–æ–µ–∫—Ç–∞\n        subprocess.run([\"python\", \"saci_remote_agent.py\"])\n        print(\"‚úÖ –°—Ç—Ä—É–∫—Ç—É—Ä–∞ —Å–æ–±—Ä–∞–Ω–∞.\")\n\n        # 2. –ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Ü–µ–ª–∏\n        goal = analyze_repo_and_suggest_goal()\n        goal_data = {\n            \"goal\": goal,\n            \"status\": \"in_progress\",\n            \"timestamp\": subprocess.getoutput(\"date '+%Y-%m-%d %H:%M'\"),\n            \"dev_done\": False,\n            \"test_done\": False\n        }\n        with open(GOAL_STATE, \"w\") as f:\n            json.dump(goal_data, f, indent=4, ensure_ascii=False)\n        print(f\"üéØ –¶–µ–ª—å —Å—Ñ–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–∞: {goal}\")\n\n        # 3. –ó–∞–ø—É—Å–∫ goal_runner.py –≤ —Ñ–æ–Ω–µ\n        subprocess.Popen(\"python agents/goal_runner.py\", shell=True)\n        return f\"‚úÖ –¶–∏–∫–ª –∑–∞–ø—É—â–µ–Ω.\\nüéØ –¶–µ–ª—å: {goal}\"\n\n    except Exception as e:\n        return f\"‚ùå –û—à–∏–±–∫–∞ –≤ process_scan: {e}\"",
  "./goal_pipeline.py::def_process_accept": "def process_accept():\n    if not goal_exists(): return \"–ù–µ—Ç –∞–∫—Ç–∏–≤–Ω–æ–π —Ü–µ–ª–∏.\"\n    update_goal_status(\"in_progress\")\n    return \"‚úÖ –¶–µ–ª—å –ø—Ä–∏–Ω—è—Ç–∞. –ü–µ—Ä–µ–¥–∞—ë–º –∞–≥–µ–Ω—Ç—É –Ω–∞ –∏—Å–ø–æ–ª–Ω–µ–Ω–∏–µ...\"",
  "./goal_pipeline.py::def_process_reject": "def process_reject():\n    if not goal_exists(): return \"–ù–µ—Ç —Ü–µ–ª–∏ –¥–ª—è –æ—Ç–∫–ª–æ–Ω–µ–Ω–∏—è.\"\n    update_goal_status(\"rejected\")\n    return \"üö´ –¶–µ–ª—å –æ—Ç–∫–ª–æ–Ω–µ–Ω–∞.\"",
  "./goal_pipeline.py::def_get_status": "def get_status():\n    if not goal_exists(): return \"–ù–µ—Ç –∞–∫—Ç–∏–≤–Ω–æ–π —Ü–µ–ª–∏.\"\n    with open(GOAL_STATE) as f:\n        data = json.load(f)\n    return f\"üìå –°—Ç–∞—Ç—É—Å —Ü–µ–ª–∏: {data['status']}\\nüéØ –¶–µ–ª—å: {data['goal']}\"",
  "./goal_pipeline.py::def_goal_exists": "def goal_exists():\n    return os.path.exists(GOAL_STATE)",
  "./goal_pipeline.py::def_update_goal_status": "def update_goal_status(new_status):\n    with open(GOAL_STATE) as f:\n        data = json.load(f)\n    data[\"status\"] = new_status\n    with open(GOAL_STATE, \"w\") as f:\n        json.dump(data, f, indent=4)\n\nif __name__ == \"__main__\":\n    print(process_scan())",
  "./test_push_main.py::header": "import os\nfrom dotenv import load_dotenv\nfrom patch_in_place import generate_patch\nfrom saci_orchestrator.orchestrator import GitHubAgent\n\n# –ó–∞–≥—Ä—É–∑–∫–∞ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–∫—Ä—É–∂–µ–Ω–∏—è\nload_dotenv()\n\ntoken = os.getenv(\"GITHUB_TOKEN\")\nrepo = os.getenv(\"GITHUB_REPO\")\nusername = os.getenv(\"GITHUB_USERNAME\")\n\n# 1. –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –ø–∞—Ç—á–∞ –¥–æ –ª—é–±—ã—Ö –¥–µ–π—Å—Ç–≤–∏–π\ngenerate_patch()\n\n# 2. –°–æ–∑–¥–∞–Ω–∏–µ –∞–≥–µ–Ω—Ç–∞\nagent = GitHubAgent(token, repo, username)\n\n# 3. –ü—Ä–∏–º–µ—Ä –¥–µ–π—Å—Ç–≤–∏—è –∞–≥–µ–Ω—Ç–∞\nfile_path = \"README.md\"\nfile_content = \"# SACI Agent: Auto-update\\n\\nThis file was updated by SACI.\"\ncommit_msg = \"SACI: auto-update README\"\n\nagent.update_file(file_path, file_content, commit_msg)",
  "./saci_memory.py::header": "\"\"\"\nsaci_memory.py ‚Äî –∞–≤—Ç–æ—Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–π SACI –º–æ–¥—É–ª—å.\n\"\"\"",
  "./saci_memory.py::class_SaciMemory": "class SaciMemory:\n    def __init__(self):\n        pass\n\n    def run(self):\n        print(\"üöÄ SaciMemory –≥–æ—Ç–æ–≤ –∫ —Ä–∞–±–æ—Ç–µ.\")\n\nif __name__ == \"__main__\":\n    agent = SaciMemory()\n    agent.run()",
  "./goal_pipeline_local_test.py::header": "import json\nimport subprocess\nfrom agents.architect import analyze_repo_and_suggest_goal\nimport os\n\n\nGOAL_STATE = \"saci_goal_state.json\"",
  "./goal_pipeline_local_test.py::def_process_scan": "def process_scan():\n    try:\n        subprocess.run([\"python\", \"saci_remote_agent.py\"])\n        print(\"‚úÖ saci_remote_agent.py –∑–∞–≤–µ—Ä—à—ë–Ω\")\n\n        goal = analyze_repo_and_suggest_goal()\n        with open(GOAL_STATE, \"w\") as f:\n            json.dump({\"status\": \"pending\", \"goal\": goal}, f, indent=4)\n\n        print(f\"\\nüéØ –ü—Ä–µ–¥–ª–∞–≥–∞–µ–º–∞—è —Ü–µ–ª—å:\\n{goal}\\n\")\n        return True\n\n    except Exception as e:\n        print(f\"‚ùå –û—à–∏–±–∫–∞ –≤ process_scan: {e}\")\n        return False",
  "./goal_pipeline_local_test.py::def_show_goal_status": "def show_goal_status():\n    if not os.path.exists(GOAL_STATE):\n        print(\"–ù–µ—Ç –∞–∫—Ç–∏–≤–Ω–æ–π —Ü–µ–ª–∏.\")\n        return\n    with open(GOAL_STATE) as f:\n        data = json.load(f)\n    print(f\"\\nüìå –¢–µ–∫—É—â–∏–π —Å—Ç–∞—Ç—É—Å: {data['status']}\\nüéØ –¶–µ–ª—å: {data['goal']}\")\n\nif __name__ == \"__main__\":\n    print(\"‚ñ∂Ô∏è –ó–∞–ø—É—Å–∫ –ª–æ–∫–∞–ª—å–Ω–æ–≥–æ —Ç–µ—Å—Ç–∞ SACI Goal Pipeline...\\n\")\n    success = process_scan()\n    if success:\n        show_goal_status()",
  "./patch_in_place.py::header": "import os\nimport subprocess\nimport json\nfrom datetime import datetime\nfrom dotenv import load_dotenv\nimport openai\n\n# –ó–∞–≥—Ä—É–∑–∫–∞ .env –∏ API-–∫–ª—é—á–∞\nload_dotenv()\nopenai.api_key = os.getenv(\"OPENAI_API_KEY\")",
  "./patch_in_place.py::def_generate_patch": "def generate_patch():\n    # –ü—Ä–æ–≤–µ—Ä–∫–∞ –∏–∑–º–µ–Ω–µ–Ω–∏–π –≤ git\n    status = subprocess.run(['git', 'status', '--porcelain'], stdout=subprocess.PIPE)\n    if not status.stdout.strip():\n        print(\"‚ÑπÔ∏è –ù–µ—Ç –∏–∑–º–µ–Ω–µ–Ω–∏–π –¥–ª—è –ø–∞—Ç—á–∞.\")\n        return None\n\n    # –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –ø–∞—Ç—á–∞\n    timestamp = datetime.now().strftime(\"%Y-%m-%d_%H-%M\")\n    patch_dir = \"patches\"\n    os.makedirs(patch_dir, exist_ok=True)\n    patch_path = os.path.join(patch_dir, f\"auto_patch_{timestamp}.patch\")\n\n    with open(patch_path, 'w') as f:\n        subprocess.run(['git', 'diff'], stdout=f)\n\n    print(f\"üì¶ –ü–∞—Ç—á —Å–æ—Ö—Ä–∞–Ω—ë–Ω: {patch_path}\")\n    analyze_patch_with_gpt(patch_path, timestamp)\n    return patch_path",
  "./patch_in_place.py::def_analyze_patch_with_gpt": "def analyze_patch_with_gpt(patch_path, timestamp):\n    with open(patch_path, 'r', encoding='utf-8') as f:\n        diff = f.read()\n\n    prompt = f\"\"\"\n–¢—ã ‚Äî AI-–∞–Ω–∞–ª–∏—Ç–∏–∫ SACI. –ù–∞ –æ—Å–Ω–æ–≤–µ git diff –æ–ø—Ä–µ–¥–µ–ª–∏:\n- \"type\": feature, bugfix, refactor, doc, config, test\n- \"risk_score\": –æ—Ç 0.0 –¥–æ 1.0\n- \"conflict_probability\": –æ—Ç 0.0 –¥–æ 1.0\n- \"summary\": –∫—Ä–∞—Ç–∫–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ —Å—É—Ç–∏ –∏–∑–º–µ–Ω–µ–Ω–∏–π\n\n–û—Ç–≤–µ—Ç –≤–µ—Ä–Ω–∏ –≤ JSON. –í–æ—Ç diff:\n```diff\n    {diff}\n\"\"\"\n    try:\n        response = openai.ChatCompletion.create(\n            model=\"gpt-4\",\n            messages=[\n                {\"role\": \"system\", \"content\": \"–¢—ã ‚Äî AI-–∞–Ω–∞–ª–∏—Ç–∏–∫ SACI.\"},\n                {\"role\": \"user\", \"content\": prompt}\n            ],\n            temperature=0.2,\n            max_tokens=500\n        )\n\n        reply = response['choices'][0]['message']['content']\n        prediction = json.loads(reply)\n        prediction[\"timestamp\"] = timestamp\n\n        # –°–æ—Ö—Ä–∞–Ω—è–µ–º –ø—Ä–æ–≥–Ω–æ–∑\n        os.makedirs(\"logs\", exist_ok=True)\n        with open(\"logs/commit_meta.json\", \"w\", encoding='utf-8') as f:\n            json.dump(prediction, f, indent=4)\n\n        print(\"üß† GPT-–∞–Ω–∞–ª–∏–∑ –≥–æ—Ç–æ–≤.\")\n        update_saci_log(prediction)\n\n    except Exception as e:\n        print(f\"‚ùå –û—à–∏–±–∫–∞ GPT-–∞–Ω–∞–ª–∏–∑–∞: {e}\")",
  "./patch_in_place.py::def_update_saci_log": "def update_saci_log(prediction):\n    entry = f\"\"\"\n### üß† SACI-Agent\nüïí {prediction['timestamp']}\nüéØ {prediction['summary']}\nüß† –¢–∏–ø: {prediction['type']}\n‚ö†Ô∏è –†–∏—Å–∫: {prediction['risk_score']}\nüîÅ –ö–æ–Ω—Ñ–ª–∏–∫—Ç: {prediction['conflict_probability']}\n‚Äî\n\"\"\"\n    log_file = \"SACI_LOG_TEMPLATE.md\"\n    if not os.path.exists(log_file):\n        with open(log_file, \"w\", encoding='utf-8') as f:\n            f.write(\"# SACI Commit Log üìò\\n\\n\")\n\n    with open(log_file, \"a\", encoding='utf-8') as f:\n        f.write(entry)\n\n    print(\"üìå SACI_LOG_TEMPLATE.md –æ–±–Ω–æ–≤–ª—ë–Ω.\")",
  "./saci_remote_agent.py::header": "import os\nimport json",
  "./saci_remote_agent.py::def_scan_repository": "def scan_repository(root=\".\"):\n    structure = {}\n    for dirpath, _, filenames in os.walk(root):\n        if any(x in dirpath for x in ['.git', '__pycache__', 'venv', 'node_modules']):\n            continue\n        rel_path = os.path.relpath(dirpath, root)\n        structure[rel_path] = [f for f in filenames if f.endswith(('.py', '.md', '.json', '.yml', '.yaml'))]\n    return structure",
  "./saci_remote_agent.py::def_read_file_contents": "def read_file_contents(structure, root=\".\"):\n    file_map = {}\n    for folder, files in structure.items():\n        for file in files:\n            path = os.path.join(root, folder, file) if folder != '.' else os.path.join(root, file)\n            try:\n                with open(path, 'r', encoding='utf-8') as f:\n                    content = f.read()\n                file_map[os.path.join(folder, file)] = content\n            except Exception as e:\n                file_map[os.path.join(folder, file)] = f\"[–û—à–∏–±–∫–∞ —á—Ç–µ–Ω–∏—è —Ñ–∞–π–ª–∞: {e}]\"\n    return file_map",
  "./saci_remote_agent.py::def_save_outputs": "def save_outputs(structure, file_map):\n    os.makedirs(\"logs\", exist_ok=True)\n    with open(\"logs/saci_project_map.json\", \"w\", encoding=\"utf-8\") as f:\n        json.dump(structure, f, indent=4, ensure_ascii=False)\n\n    with open(\"logs/saci_file_map.json\", \"w\", encoding=\"utf-8\") as f:\n        json.dump(file_map, f, indent=2, ensure_ascii=False)\n\n    print(\"üìç –°—Ç—Ä—É–∫—Ç—É—Ä–∞ –∏ —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ —Ñ–∞–π–ª–æ–≤ —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã –≤ logs/\")\n\nif __name__ == \"__main__\":\n    project_structure = scan_repository()\n    file_contents = read_file_contents(project_structure)\n    save_outputs(project_structure, file_contents)\n    print(\"‚úÖ –ì–æ—Ç–æ–≤ –∫ –∞–Ω–∞–ª–∏–∑—É.\")",
  "./main.py::header": "# SACI: –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ main.py\nprint('Hello from SACI!')",
  "./agent_hub.py::def_generate_agent_hub": "def generate_agent_hub():\n    code = '''\"\"\"\nSACI Agent Hub\n–†–æ—É—Ç–µ—Ä –º–µ–∂–¥—É —Å—Ç—Ä–∞—Ç–µ–≥–∞–º–∏, —Ä–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫–æ–º, —Ç–µ—Å—Ç–µ—Ä–æ–º.\n\"\"\"",
  "./agent_hub.py::def_route_goal": "def route_goal(goal):\n    if \"strategy\" in goal:\n        from strategist import plan\n        return plan(goal)\n    elif \"test\" in goal:\n        from tester import run_tests\n        return run_tests(goal)\n    else:\n        from developer import build\n        return build(goal)\n\nif __name__ == \"__main__\":\n    print(\"üß† Agent Hub –≥–æ—Ç–æ–≤ –∫ –ø—Ä–∏—ë–º—É —Ü–µ–ª–µ–π.\")\n'''\n    with open(\"agents/agent_hub.py\", \"w\", encoding=\"utf-8\") as f:\n        f.write(code)\n    print(\"üß† agent_hub.py —Å–æ–∑–¥–∞–Ω.\")",
  "saci_orchestrator/__init__.py::header": "# Init file for saci_orchestrator package",
  "saci_orchestrator/orchestrator.py::header": "from typing import List\nfrom dotenv import load_dotenv\nload_dotenv()",
  "saci_orchestrator/orchestrator.py::class_SACIOrchestrator": "class SACIOrchestrator:\n    def __init__(self):\n        self.current_goal = None\n        self.tasks = []\n\n    def set_goal(self, goal: str) -> None:\n        self.current_goal = goal\n        print(f\"[SACI Orchestrator] Goal set to: {self.current_goal}\")\n\n    def plan_tasks(self) -> List[str]:\n        if not self.current_goal:\n            print(\"[SACI Orchestrator] No goal set. Unable to plan tasks.\")\n            return []\n\n        self.tasks = [\n            \"Analyze goal and create code skeleton\",\n            \"Generate code via AI agent\",\n            \"Run tests against generated code\",\n            \"Integrate code to GitHub if tests pass\",\n            \"Deploy to environment if integration is successful\"\n        ]\n\n        print(f\"[SACI Orchestrator] Planned tasks for goal '{self.current_goal}':\")\n        for i, task in enumerate(self.tasks, start=1):\n            print(f\"  {i}. {task}\")\n        return self.tasks\n\n    def execute_tasks(self) -> None:\n        if not self.tasks:\n            print(\"[SACI Orchestrator] No tasks to execute.\")\n            return\n\n        print(\"[SACI Orchestrator] Executing tasks...\")\n        for i, task in enumerate(self.tasks, start=1):\n            print(f\"  {i}. {task} [Executed]\")\n\n        self.generate_code()\n        self.tasks = []\n\n    def generate_code(self) -> None:\n        \"\"\"\n        –ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç –∫–æ–¥ –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —Ü–µ–ª–∏ –∏ –æ—Ç–ø—Ä–∞–≤–ª—è–µ—Ç —Ñ–∞–π–ª –≤ GitHub.\n        \"\"\"\n        import os\n        try:\n            from github import Github\n        except ImportError:\n            print(\"[SACI] –£—Å—Ç–∞–Ω–æ–≤–∏ PyGithub: pip install PyGithub\")\n            return\n\n        token = os.getenv(\"GITHUB_TOKEN\")\n        username = os.getenv(\"GITHUB_USERNAME\")\n        repo_name = os.getenv(\"GITHUB_REPO\")\n\n        if not token or not username or not repo_name:\n            print(\"[SACI] GitHub –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –æ–∫—Ä—É–∂–µ–Ω–∏—è –Ω–µ –∑–∞–¥–∞–Ω—ã.\")\n            return\n\n        goal = self.current_goal.lower()\n        if any(word in goal for word in [\"–±–æ—Ç\", \"telegram\", \"—á–∞—Ç\"]):\n            filename = \"telegram_bot.py\"\n            content = (\n                \"# Telegram Bot generated by SACI\\n\"\n                \"# –¶–µ–ª—å: \" + self.current_goal + \"\\n\\n\"\n                \"from telegram.ext import Application, CommandHandler\\n\\n\"\n                \"async def start(update, context):\\n\"\n                \"    await update.message.reply_text('–ü—Ä–∏–≤–µ—Ç –æ—Ç SACI-–±–æ—Ç–∞!')\\n\\n\"\n                \"app = Application.builder().token('YOUR_TOKEN').build()\\n\"\n                \"app.add_handler(CommandHandler('start', start))\\n\"\n                \"app.run_polling()\\n\"\n            )\n        elif any(word in goal for word in [\"–ø–∞—Ä—Å–µ—Ä\", \"—Ä–∞—Å–ø–∞—Ä—Å–∏—Ç—å\", \"html\", \"—Å–∞–π—Ç\"]):\n            filename = \"parser.py\"\n            content = (\n                \"# HTML Parser generated by SACI\\n\"\n                \"# –¶–µ–ª—å: \" + self.current_goal + \"\\n\\n\"\n                \"import requests\\n\"\n                \"from bs4 import BeautifulSoup\\n\\n\"\n                \"url = 'https://example.com'\\n\"\n                \"response = requests.get(url)\\n\"\n                \"soup = BeautifulSoup(response.text, 'html.parser')\\n\"\n                \"print(soup.title.text)\\n\"\n            )\n        elif any(word in goal for word in [\"api\", \"—Å–µ—Ä–≤–µ—Ä\", \"endpoint\", \"—Ñ—Ä–µ–π–º–≤–æ—Ä–∫\"]):\n            filename = \"api_server.py\"\n            content = (\n                \"# Flask API generated by SACI\\n\"\n                \"# –¶–µ–ª—å: \" + self.current_goal + \"\\n\\n\"\n                \"from flask import Flask, jsonify\\n\\n\"\n                \"app = Flask(__name__)\\n\\n\"\n                \"@app.route('/')\\n\"\n                \"def index():\\n\"\n                \"    return jsonify({'message': '–ü—Ä–∏–≤–µ—Ç –æ—Ç SACI API'})\\n\\n\"\n                \"if __name__ == '__main__':\\n\"\n                \"    app.run(debug=True)\\n\"\n            )\n        else:\n            filename = \"main.py\"\n            content = (\n                \"# Generated by SACI\\n\"\n                \"# Goal: \" + self.current_goal + \"\\n\\n\"\n                \"print('Hello from SACI!')\\n\"\n            )\n\n        try:\n            from github import Github\n            g = Github(token)\n            user = g.get_user()\n            repo = user.get_repo(repo_name)\n            try:\n                file = repo.get_contents(filename)\n                repo.update_file(filename, f\"SACI code update for goal: {self.current_goal}\", content, file.sha)\n                print(f\"[SACI] {filename} –æ–±–Ω–æ–≤–ª—ë–Ω –≤ GitHub. –ü—Ä–∏—á–∏–Ω–∞: {self.current_goal}\")\n            except:\n                repo.create_file(filename, f\"SACI code create for goal: {self.current_goal}\", content)\n                print(f\"[SACI] {filename} —Å–æ–∑–¥–∞–Ω –≤ GitHub. –ü—Ä–∏—á–∏–Ω–∞: {self.current_goal}\")\n        except Exception as e:\n            print(f\"[SACI] –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø—É—à–µ –∫–æ–¥–∞ –≤ GitHub: {e}\")\n\nimport os\nimport requests\nimport base64\nimport subprocess\nfrom datetime import datetime",
  "saci_orchestrator/orchestrator.py::class_GitHubAgent": "class GitHubAgent:\n    def __init__(self, token, repo, username):\n        self.token = token\n        self.repo = repo\n        self.username = username\n        self.api_url = f\"https://api.github.com/repos/{username}/{repo}/contents\"\n\n    def update_file(self, path, content, commit_message):\n        url = f\"{self.api_url}/{path}\"\n        headers = {\n            \"Authorization\": f\"Bearer {self.token}\",\n            \"Accept\": \"application/vnd.github+json\"\n        }\n\n        response = requests.get(url, headers=headers)\n        sha = response.json()[\"sha\"] if response.status_code == 200 else None\n\n        data = {\n            \"message\": commit_message,\n            \"content\": base64.b64encode(content.encode()).decode(),\n            \"branch\": \"main\"\n        }\n        if sha:\n            data[\"sha\"] = sha\n\n        response = requests.put(url, headers=headers, json=data)\n        if response.status_code in [200, 201]:\n            print(f\"‚úÖ –§–∞–π–ª {path} —É—Å–ø–µ—à–Ω–æ –∑–∞–ø—É—à–µ–Ω –≤ GitHub\")\n        else:\n            print(f\"‚ùå –û—à–∏–±–∫–∞ push: {response.status_code} ‚Üí {response.json()}\")\n\n    def commit_from_bot(self, file, content, message):\n        url = f\"{self.api_url}/{file}\"\n        headers = {\n            \"Authorization\": f\"Bearer {self.token}\",\n            \"Accept\": \"application/vnd.github+json\"\n        }\n\n        response = requests.get(url, headers=headers)\n        sha = response.json().get(\"sha\") if response.status_code == 200 else None\n\n        commit_msg = f\"{message}\\n\\nüß† SACI-Agent ‚Ä¢ {datetime.utcnow().isoformat()}Z\"\n\n        data = {\n            \"message\": commit_msg,\n            \"content\": base64.b64encode(content.encode()).decode(),\n            \"branch\": \"main\"\n        }\n        if sha:\n            data[\"sha\"] = sha\n\n        result = requests.put(url, headers=headers, json=data)\n        if result.status_code in [200, 201]:\n            print(f\"‚úÖ SACI-–∫–æ–º–º–∏—Ç —É—Å–ø–µ—à–Ω–æ –≤—ã–ø–æ–ª–Ω–µ–Ω ‚Üí {file}\")\n        else:\n            print(f\"‚ùå –û—à–∏–±–∫–∞ –∫–æ–º–º–∏—Ç–∞ SACI ({result.status_code}): {result.json()}\")\n\n    def sync_after_commit(self):\n        print(\"üîÑ –°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è —Å GitHub...\")\n\n        try:\n            # –ê–≤—Ç–æ–∫–æ–º–º–∏—Ç –ª–æ–∫–∞–ª—å–Ω—ã—Ö –∏–∑–º–µ–Ω–µ–Ω–∏–π –ø–µ—Ä–µ–¥ pull\n            subprocess.run([\"git\", \"add\", \".\"], check=True)\n            subprocess.run([\"git\", \"commit\", \"-m\", \"SACI: –∞–≤—Ç–æ—Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –ø–µ—Ä–µ–¥ pull\"], check=True)\n\n            output = subprocess.check_output(\n                [\"git\", \"pull\", \"--no-rebase\", \"origin\", \"main\"],\n                stderr=subprocess.STDOUT,\n                universal_newlines=True\n            )\n            print(f\"‚úÖ Pull —É—Å–ø–µ—à–µ–Ω:\\n{output}\")\n        except subprocess.CalledProcessError as e:\n            print(f\"‚ùå –û—à–∏–±–∫–∞ pull:\\n{e.output}\")\n\n    def commit_with_log(self, file, content, message, log_file=\"SACI_LOG_TEMPLATE.md\"):\n        self.commit_from_bot(file=file, content=content, message=message)\n\n        timestamp = datetime.utcnow().strftime(\"%Y-%m-%d %H:%M:%SZ\")\n        log_entry = (\n            \"### üß† SACI-Agent\\n\"\n            f\"üïí {timestamp}\\n\"\n            f\"üéØ {message}\\n\"\n            \"üîÑ –ò–∑–º–µ–Ω–µ–Ω–∏—è:\\n\"\n            f\"- `{file}` –æ–±–Ω–æ–≤–ª—ë–Ω –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏\\n\"\n        )\n\n        try:\n            if os.path.exists(log_file):\n                with open(log_file, \"r\", encoding=\"utf-8\") as f:\n                    existing = f.read()\n            else:\n                existing = \"# SACI Commit Log üìò\\n\"\n\n            updated_log = existing.strip() + \"\\n\\n\" + log_entry.strip() + \"\\n\"\n\n            with open(log_file, \"w\", encoding=\"utf-8\") as f:\n                f.write(updated_log)\n\n            self.commit_from_bot(\n                file=log_file,\n                content=updated_log,\n                message=f\"–û–±–Ω–æ–≤–ª—ë–Ω SACI-–ª–æ–≥ –ø–æ—Å–ª–µ –∫–æ–º–º–∏—Ç–∞ {file}\"\n            )\n\n            self.sync_after_commit()\n\n        except Exception as e:\n            print(f\"‚ö†Ô∏è –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ SACI-–ª–æ–≥–∞: {e}\")",
  "tests/test_patch_predictor.py::header": "import unittest\nfrom patch_in_place import generate_patch",
  "tests/test_patch_predictor.py::class_TestPatchPredictor": "class TestPatchPredictor(unittest.TestCase):\n    def test_generate_patch_runs(self):\n        result = generate_patch()\n        self.assertTrue(result is None or result.endswith('.patch'))\n\nif __name__ == \"__main__\":\n    unittest.main()",
  "core/saci_protocol.py::class_SACIProtocol": "class SACIProtocol:\n    def __init__(self, agent_name: str = \"SACI-Core-Agent\"):\n        self.agent_name = agent_name\n\n    def log_task(self, task: str):\n        print(f\"[SACI] {self.agent_name} –≤—ã–ø–æ–ª–Ω—è–µ—Ç: {task}\")",
  "core/saci_memory.py::header": "\"\"\"\nSACI Memory Core ‚Äî –æ—Ç–≤–µ—á–∞–µ—Ç –∑–∞ —Ö—Ä–∞–Ω–µ–Ω–∏–µ –∫—Ä–∞—Ç–∫–æ—Å—Ä–æ—á–Ω–æ–≥–æ —Å–æ—Å—Ç–æ—è–Ω–∏—è –∏ —Ö–æ–¥–∞ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è —Ü–µ–ª–µ–π.\n\"\"\"",
  "core/saci_memory.py::class_SACIMemory": "class SACIMemory:\n    def __init__(self):\n        self.state = {}\n\n    def set(self, key, value):\n        self.state[key] = value\n\n    def get(self, key):\n        return self.state.get(key)\n\n    def reset(self):\n        self.state = {}\n\nif __name__ == \"__main__\":\n    memory = SACIMemory()\n    memory.set(\"example\", 42)\n    print(\"üß† Memory ready:\", memory.get(\"example\"))",
  "agents/code_refactor.py::header": "import os\nimport json\nimport openai\nimport requests\nfrom telebot.types import InlineKeyboardMarkup, InlineKeyboardButton\nfrom datetime import datetime\nfrom dotenv import load_dotenv\nimport subprocess  # –¥–ª—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–≥–æ –∑–∞–ø—É—Å–∫–∞ remote_agent / splitter\nfrom agents.file_splitter import split_all_py_files  # –µ—Å–ª–∏ —Ä–µ–∑–µ—Ä–≤–Ω—ã–π split –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è\nimport sys\nimport os\nsys.path.append(os.path.abspath(\".\"))\n\n\nload_dotenv()\nOPENAI_API_KEY = os.getenv(\"OPENAI_API_KEY\")\nBOT_TOKEN = os.getenv(\"TELEGRAM_BOT_TOKEN\")\nCHAT_ID = os.getenv(\"TELEGRAM_CHAT_ID\")\n\nopenai.api_key = OPENAI_API_KEY\n\nFILE_MAP_PATH = \"logs/saci_file_map.json\"\nPATCH_DIR = \"patches\"\n\nCHUNKS_PATH = \"logs/saci_code_chunks.json\"",
  "agents/code_refactor.py::def_generate_all_reviews_markdown": "def generate_all_reviews_markdown(patch_name):\n    agents = {\n        \"architect\": \"üß† Architect\",\n        \"developer\": \"üë®‚Äçüíª Developer\",\n        \"tester\": \"üß™ Tester\",\n        \"strategist\": \"üéØ Strategist\"\n    }\n\n    md = f\"# üîç Patch Review ‚Äî `{patch_name}`\\n\\n---\\n\"\n\n    for agent_key, emoji_title in agents.items():\n        review = generate_patch_review(patch_name, agent_key)\n        md += f\"\\n## {emoji_title}\\n\\n{review}\\n\\n---\\n\"\n\n    os.makedirs(\"logs/patch_reviews\", exist_ok=True)\n    path = f\"logs/patch_reviews/{patch_name}.md\"\n    with open(path, \"w\", encoding=\"utf-8\") as f:\n        f.write(md)\n\n    return path",
  "agents/code_refactor.py::def_send_review_markdown_to_telegram": "def send_review_markdown_to_telegram(patch_name):\n    path = f\"logs/patch_reviews/{patch_name}.md\"\n    if not os.path.exists(path):\n        return\n\n    url = f\"https://api.telegram.org/bot{BOT_TOKEN}/sendDocument\"\n    with open(path, \"rb\") as doc:\n        files = {\"document\": doc}\n        data = {\n            \"chat_id\": CHAT_ID,\n            \"caption\": f\"üìÑ –û–±—â–µ–µ —Ä–µ–≤—å—é –æ—Ç –≤—Å–µ—Ö –∞–≥–µ–Ω—Ç–æ–≤ –ø–æ `{patch_name}`\",\n            \"parse_mode\": \"Markdown\"\n        }\n        requests.post(url, files=files, data=data)",
  "agents/code_refactor.py::def_generate_patch_review": "def generate_patch_review(patch_name, agent=\"architect\"):\n    patch_path = None\n    for ext in [\".patch\", \".diff\"]:\n        path = f\"patches/{patch_name}{ext}\"\n        if os.path.exists(path):\n            patch_path = path\n            break\n\n    if not patch_path:\n        return \"‚ùå Patch –Ω–µ –Ω–∞–π–¥–µ–Ω.\"\n\n    with open(patch_path, \"r\", encoding=\"utf-8\") as f:\n        patch_text = f.read()\n\n    persona = {\n        \"architect\": \"–¢—ã ‚Äî –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–Ω—ã–π AI, –æ—Ü–µ–Ω–∏–≤–∞–µ—à—å —Å—Ç—Ä–∞—Ç–µ–≥–∏—á–µ—Å–∫–∏.\",\n        \"developer\": \"–¢—ã ‚Äî –æ–ø—ã—Ç–Ω—ã–π Python-—Ä–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫ SACI.\",\n        \"tester\": \"–¢—ã ‚Äî AI-—Ç–µ—Å—Ç–∏—Ä–æ–≤—â–∏–∫, –∏—â–µ—à—å —Å–ª–∞–±—ã–µ –º–µ—Å—Ç–∞.\",\n        \"strategist\": \"–¢—ã ‚Äî AI-—Å—Ç—Ä–∞—Ç–µ–≥, —Å–º–æ—Ç—Ä–∏—à—å –Ω–∞ –ø–æ–ª—å–∑—É –≤ –±—É–¥—É—â–µ–º.\"\n    }.get(agent, \"–¢—ã ‚Äî AI-–ø–æ–º–æ—â–Ω–∏–∫.\")\n\n    prompt = f\"\"\"\n{persona}\n–î–∞–π —Ä–µ–≤—å—é –Ω–∞ —Å–ª–µ–¥—É—é—â–∏–π patch (diff):\n- –ß—Ç–æ —É–ª—É—á—à–∞–µ—Ç?\n- –ö–∞–∫–∏–µ –ø–ª—é—Å—ã?\n- –ï—Å—Ç—å –ª–∏ —Ä–∏—Å–∫–∏?\n{patch_text[:3000]}\n\"\"\"\n\n    response = openai.ChatCompletion.create(\n        model=\"gpt-4\",\n        messages=[\n            {\"role\": \"system\", \"content\": persona},\n            {\"role\": \"user\", \"content\": prompt}\n        ],\n        temperature=0.4,\n        max_tokens=400\n    )\n\n    return response['choices'][0]['message']['content'].strip()",
  "agents/code_refactor.py::def_generate_all_patch_reviews": "def generate_all_patch_reviews(patch_name):\n    agents = [\"architect\", \"developer\", \"tester\", \"strategist\"]\n    results = {}\n    for agent in agents:\n        review = generate_patch_review(patch_name, agent)\n        results[agent] = review\n    return results",
  "agents/code_refactor.py::def_send_patch_with_reviews": "def send_patch_with_reviews(filename):\n    base = filename.replace(\".patch\", \"\").replace(\".diff\", \"\")\n    reviews = generate_all_patch_reviews(base)\n\n    markup = InlineKeyboardMarkup(row_width=2)\n    markup.add(\n        InlineKeyboardButton(\"üìÑ –ü—Ä–æ—Å–º–æ—Ç—Ä patch\", callback_data=f\"review:{base}\"),\n        InlineKeyboardButton(\"‚úÖ –ü—Ä–∏–º–µ–Ω–∏—Ç—å\", callback_data=f\"apply:{base}\"),\n    )\n    markup.row(\n        InlineKeyboardButton(\"üß† Architect\", callback_data=f\"view_rev:{base}:architect\"),\n        InlineKeyboardButton(\"üë®‚Äçüíª Developer\", callback_data=f\"view_rev:{base}:developer\"),\n        InlineKeyboardButton(\"üß™ Tester\", callback_data=f\"view_rev:{base}:tester\"),\n        InlineKeyboardButton(\"üéØ Strategist\", callback_data=f\"view_rev:{base}:strategist\"),\n    )\n\n    review_text = \"\\n\".join([\n        f\"*{agent.title()}*:\\n{review[:200]}\" for agent, review in reviews.items()\n    ])\n\n    url = f\"https://api.telegram.org/bot{BOT_TOKEN}/sendMessage\"\n    payload = {\n        \"chat_id\": CHAT_ID,\n        \"text\": f\"üì¶ GPT-–ø–∞—Ç—á `{filename}`\\n\\nüß† –†–µ–≤—å—é –∞–≥–µ–Ω—Ç–æ–≤:\\n\\n{review_text}\\n\\n–í—ã–±–µ—Ä–∏ –¥–µ–π—Å—Ç–≤–∏–µ –Ω–∏–∂–µ:\",\n        \"reply_markup\": json.dumps(markup.to_dict()),\n        \"parse_mode\": \"Markdown\"\n    }\n    requests.post(url, json=payload)\n\nfrom telebot.types import InlineKeyboardMarkup, InlineKeyboardButton",
  "agents/code_refactor.py::def_send_patch_with_buttons": "def send_patch_with_buttons(filename):\n    base = filename.replace(\".diff\", \"\").replace(\".patch\", \"\")\n\n    markup = InlineKeyboardMarkup(row_width=2)\n    markup.add(\n        InlineKeyboardButton(\"üìÑ –ü—Ä–æ—Å–º–æ—Ç—Ä–µ—Ç—å\", callback_data=f\"review:{base}\"),\n        InlineKeyboardButton(\"‚úÖ –ü—Ä–∏–º–µ–Ω–∏—Ç—å\", callback_data=f\"apply:{base}\"),\n        InlineKeyboardButton(\"üß† Architect\", callback_data=f\"review_agent:{base}:architect\"),\n        InlineKeyboardButton(\"üë®‚Äçüíª Developer\", callback_data=f\"review_agent:{base}:developer\"),\n        InlineKeyboardButton(\"üéØ Strategist\", callback_data=f\"review_agent:{base}:strategist\")\n    )\n\n    url = f\"https://api.telegram.org/bot{BOT_TOKEN}/sendMessage\"\n    payload = {\n        \"chat_id\": CHAT_ID,\n        \"text\": f\"üì¶ GPT –ø—Ä–µ–¥–ª–æ–∂–∏–ª –ø–∞—Ç—á: `{filename}`\\n\\nüìé –í—ã–±–µ—Ä–∏ –¥–µ–π—Å—Ç–≤–∏–µ:\",\n        \"reply_markup\": json.dumps(markup.to_dict()),\n        \"parse_mode\": \"Markdown\"\n    }\n\n    requests.post(url, json=payload)",
  "agents/code_refactor.py::def_load_chunks": "def load_chunks():\n    # –ü–æ —É–º–æ–ª—á–∞–Ω–∏—é ‚Äî Tree-sitter\n    tree_chunks_path = \"logs/saci_code_chunks.json\"\n    if os.path.exists(tree_chunks_path):\n        with open(tree_chunks_path, \"r\", encoding=\"utf-8\") as f:\n            return json.load(f)\n    else:\n        print(\"‚ö†Ô∏è –ß–∞–Ω–∫–∏ Tree-sitter –Ω–µ –Ω–∞–π–¥–µ–Ω—ã. –ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è —Å—Ç–∞—Ä—ã–π split.\")\n        with open(\"logs/saci_file_map.json\", \"r\", encoding=\"utf-8\") as f:\n            file_map = json.load(f)\n        return split_all_py_files(file_map)  # ‚Üê –µ—Å–ª–∏ –µ—Å—Ç—å —Ñ—É–Ω–∫—Ü–∏—è-—Ä–µ–∑–µ—Ä–≤",
  "agents/code_refactor.py::def_generate_patch_prompt": "def generate_patch_prompt(file_map):\n    file_bundle = \"\\n\\n\".join([\n        f\"### {fname}\\n```python\\n{content[:1500]}\\n```\"\n        for fname, content in file_map.items()\n        if fname.endswith(\".py\")\n    ])\n    return f\"\"\"\n–¢—ã ‚Äî AI-–∞—Ä—Ö–∏—Ç–µ–∫—Ç–æ—Ä SACI. –ü—Ä–æ–∞–Ω–∞–ª–∏–∑–∏—Ä—É–π —Å–ª–µ–¥—É—é—â–∏–π –∫–æ–¥ –∏ –ø—Ä–µ–¥–ª–æ–∂–∏ —É–ª—É—á—à–µ–Ω–∏—è –≤ —Ñ–æ—Ä–º–∞—Ç–µ unified diff (git diff).\n\n–¢–æ–ª—å–∫–æ –æ–¥–∏–Ω diff-—Ñ–∞–π–ª —Å–æ –≤—Å–µ–º–∏ –∏–∑–º–µ–Ω–µ–Ω–∏—è–º–∏. –í–Ω–∏–∑—É ‚Äî –∫—Ä–∞—Ç–∫–∏–µ –ø–æ—è—Å–Ω–µ–Ω–∏—è (1‚Äì2 –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è). –ù–∏–∫–∞–∫–∏—Ö –ª–∏—à–Ω–∏—Ö –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–µ–≤.\n\n–í–æ—Ç –∫–æ–¥:\n{file_bundle}\n\"\"\"",
  "agents/code_refactor.py::def_request_gpt_patch": "def request_gpt_patch(chunks):\n    prompt = \"–¢—ã ‚Äî AI-–∫–æ–¥-–∏–Ω–∂–µ–Ω–µ—Ä SACI. –ù–∏–∂–µ —Å–æ–¥–µ—Ä–∂–∞—Ç—Å—è –ª–æ–≥–∏—á–µ—Å–∫–∏–µ –±–ª–æ–∫–∏ –∫–æ–¥–∞ (—á–∞–Ω–∫–∏). –ü—Ä–æ–∞–Ω–∞–ª–∏–∑–∏—Ä—É–π –∏—Ö –∏ –ø—Ä–µ–¥–ª–æ–∂–∏ —É–ª—É—á—à–µ–Ω–∏—è –≤ —Ñ–æ—Ä–º–∞—Ç–µ unified diff:\\n\\n\"\n\n    selected_chunks = sorted(chunks.items(), key=lambda x: priority_sort(x[0]))\n    total_chars = 0\n    max_chars = 8000\n    included = 0\n\n    for name, content in selected_chunks:\n        sliced = content[:2000]\n        chunk_text = f\"### {name} ###\\n```\\n{sliced}\\n```\\n\\n\"\n        if total_chars + len(chunk_text) > max_chars:\n            break\n        prompt += chunk_text\n        total_chars += len(chunk_text)\n        included += 1\n\n    prompt += \"\\n–°–≥–µ–Ω–µ—Ä–∏—Ä—É–π —É–ª—É—á—à–µ–Ω–∏—è –≤ —Ñ–æ—Ä–º–∞—Ç–µ unified diff (.diff). –ë–µ–∑ –ø–æ—è—Å–Ω–µ–Ω–∏–π ‚Äî —Ç–æ–ª—å–∫–æ patch.\"\n\n    print(f\"üìä –û—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ —á–∞–Ω–∫–æ–≤: {included} / {len(chunks)}\")\n\n    response = openai.ChatCompletion.create(\n        model=\"gpt-4\",\n        messages=[\n            {\"role\": \"system\", \"content\": \"–¢—ã ‚Äî AI-–∞—Ä—Ö–∏—Ç–µ–∫—Ç–æ—Ä SACI. –í–æ–∑–≤—Ä–∞—â–∞–π patch-–∏–∑–º–µ–Ω–µ–Ω–∏—è –≤ —Ñ–æ—Ä–º–∞—Ç–µ unified diff.\"},\n            {\"role\": \"user\", \"content\": prompt}\n        ],\n        temperature=0.2,\n        max_tokens=1200\n    )\n\n    return response.choices[0].message.content.strip()",
  "agents/code_refactor.py::def_priority_sort": "def priority_sort(name):\n    if \"goal_runner\" in name: return 1\n    if \"developer\" in name: return 2\n    if \"tester\" in name: return 3\n    if \"core/\" in name: return 4\n    return 99",
  "agents/code_refactor.py::def_save_patch": "def save_patch(content):\n    os.makedirs(PATCH_DIR, exist_ok=True)\n    ts = datetime.now().strftime(\"%Y-%m-%d_%H-%M\")\n    filename = f\"auto_gpt_patch_{ts}.diff\"\n    path = os.path.join(PATCH_DIR, filename)\n    with open(path, \"w\", encoding=\"utf-8\") as f:\n        f.write(content)\n    return filename, path",
  "agents/code_refactor.py::def_is_patch_valid": "def is_patch_valid(content):\n    return content.startswith(\"diff --git\") and \"@@\" in content and \"--- \" in content",
  "agents/code_refactor.py::def_repair_patch_with_gpt": "def repair_patch_with_gpt(content):\n    print(\"üîß –ü–∞—Ç—á –ø–æ–≤—Ä–µ–∂–¥—ë–Ω. –ó–∞–ø—Ä–∞—à–∏–≤–∞–µ–º –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–µ —É GPT...\")\n\n    prompt = f\"\"\"\n–ù–∏–∂–µ –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –ø–æ–≤—Ä–µ–∂–¥—ë–Ω–Ω—ã–π –∏–ª–∏ –Ω–µ–ø–æ–ª–Ω—ã–π git patch. –í–æ—Å—Å—Ç–∞–Ω–æ–≤–∏ –µ–≥–æ –≤ –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–º —Ñ–æ—Ä–º–∞—Ç–µ unified diff. –ë–µ–∑ –ø–æ—è—Å–Ω–µ–Ω–∏–π, —Ç–æ–ª—å–∫–æ patch:\n{content[:3000]}\n\"\"\"\n\n    response = openai.ChatCompletion.create(\n        model=\"gpt-4\",\n        messages=[\n            {\"role\": \"system\", \"content\": \"–¢—ã ‚Äî AI-–ø–∞—Ç—á–µ—Ä SACI. –ò—Å–ø—Ä–∞–≤–ª—è–π git-patch.\"},\n            {\"role\": \"user\", \"content\": prompt}\n        ],\n        temperature=0.2,\n        max_tokens=1000\n    )\n\n    return response.choices[0].message.content.strip()",
  "agents/code_refactor.py::def_send_to_telegram": "def send_to_telegram(text):\n    url = f\"https://api.telegram.org/bot{BOT_TOKEN}/sendMessage\"\n    payload = {\"chat_id\": CHAT_ID, \"text\": text}\n    response = requests.post(url, data=payload)\n    if response.status_code == 200:\n        print(\"üì¨ –°–æ–æ–±—â–µ–Ω–∏–µ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ –≤ Telegram.\")\n    else:\n        print(f\"‚ùå –û—à–∏–±–∫–∞ Telegram: {response.status_code} {response.text}\")",
  "agents/code_refactor.py::def_run_refactor": "def run_refactor():\n    print(\"üîÑ –û–±–Ω–æ–≤–ª—è–µ–º –∫–æ–¥–æ–≤—É—é –±–∞–∑—É –ø–µ—Ä–µ–¥ –∞–Ω–∞–ª–∏–∑–æ–º...\")\n    subprocess.run([\"python\", \"saci_remote_agent.py\"])\n    subprocess.run([\"python\", \"agents/file_splitter.py\"])\n    \n    print(\"üß† GPT-–∞–Ω–∞–ª–∏–∑ —á–∞–Ω–∫–æ–≤ –∫–æ–¥–∞...\")\n    chunks = load_chunks()\n    if not chunks:\n        send_to_telegram(\"‚ö†Ô∏è –ù–µ—Ç —á–∞–Ω–∫–æ–≤ –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞.\")\n        return\n\n    patch = request_gpt_patch(chunks)\n    if not patch:\n        print(\"‚ö†Ô∏è GPT –Ω–µ –≤–µ—Ä–Ω—É–ª –ø–∞—Ç—á.\")\n        return\n\n    patch_text = request_gpt_patch(chunks)\n    if not is_patch_valid(patch_text):\n        patch_text = repair_patch_with_gpt(patch_text)\n        print(\"‚úÖ –ü–∞—Ç—á –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω GPT.\")\n\n    filename, path = save_patch(patch_text)\n    \n    send_patch_with_buttons(filename)\n\nif __name__ == \"__main__\":\n    run_refactor()",
  "agents/architect.py::header": "import json",
  "agents/architect.py::def_analyze_repo_and_suggest_goal": "def analyze_repo_and_suggest_goal():\n    with open(\"logs/saci_project_map.json\") as f:\n        structure = json.load(f)\n\n    if \"tests\" in structure and not structure[\"tests\"]:\n        return \"–î–æ–±–∞–≤–∏—Ç—å —Ç–µ—Å—Ç–æ–≤—ã–π –º–æ–¥—É–ª—å: tests/test_patch_predictor.py\"\n\n    if \"agents\" in structure and \"agent_hub.py\" not in structure[\"agents\"]:\n        return \"–°–æ–∑–¥–∞—Ç—å agent_hub.py ‚Äî –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–æ—Ä –º–µ–∂–¥—É —Å—Ç—Ä–∞—Ç–µ–≥–∞–º–∏, –¥–µ–≤–µ–ª–æ–ø–µ—Ä–æ–º –∏ —Ç–µ—Å—Ç–µ—Ä–æ–º\"\n\n    return \"–û–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞—Ç—å —Å—Ç—Ä—É–∫—Ç—É—Ä—É core/ –∏ —Å–æ–∑–¥–∞—Ç—å saci_memory.py –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è —Å–æ—Å—Ç–æ—è–Ω–∏—è\"",
  "agents/metrics_master.py::class_MetricsMaster": "class MetricsMaster:\n    def execute(self, data):\n        data[\"metrics\"] = {\"—É—Å–ø–µ—Ö\": True, \"–æ—Ü–µ–Ω–∫–∞\": \"–æ—Ç–ª–∏—á–Ω–æ\"}\n        return data",
  "agents/file_splitter_tree.py::header": "import os\nimport json\nfrom tree_sitter import Language, Parser\n\n# –ö–æ–º–ø–∏–ª–∏—Ä—É–µ–º —è–∑—ã–∫ (–æ–¥–∏–Ω —Ä–∞–∑)\nif not os.path.exists('build/my-languages.so'):\n    Language.build_library(\n        'build/my-languages.so',\n        ['vendor/tree-sitter-python']\n    )\n\nPY_LANGUAGE = Language('build/my-languages.so', 'python')\nparser = Parser()\nparser.set_language(PY_LANGUAGE)\n\nSRC_DIR = \".\"\nCHUNKS_PATH = \"logs/saci_code_chunks.json\"",
  "agents/file_splitter_tree.py::def_extract_chunks_from_source": "def extract_chunks_from_source(filepath):\n    with open(filepath, \"r\", encoding=\"utf-8\") as f:\n        code = f.read()\n\n    tree = parser.parse(bytes(code, \"utf8\"))\n    root_node = tree.root_node\n\n    lines = code.split(\"\\n\")\n    chunks = {}\n\n    def get_text(start, end):\n        return \"\\n\".join(lines[start:end+1]).strip()\n\n    for node in root_node.children:\n        if node.type in (\"function_definition\", \"class_definition\"):\n            name = node.child_by_field_name(\"name\")\n            if name:\n                id = f\"{filepath}::{'def' if node.type == 'function_definition' else 'class'}_{name.text.decode()}\"\n                chunk = get_text(node.start_point[0], node.end_point[0])\n                chunks[id] = chunk\n\n    return chunks",
  "agents/file_splitter_tree.py::def_scan_all_files": "def scan_all_files():\n    all_chunks = {}\n    for root, _, files in os.walk(SRC_DIR):\n        if \"venv\" in root or \"__pycache__\" in root or \"node_modules\" in root:\n            continue\n        for file in files:\n            if file.endswith(\".py\"):\n                path = os.path.join(root, file)\n                chunks = extract_chunks_from_source(path)\n                all_chunks.update(chunks)\n    return all_chunks\n\nif __name__ == \"__main__\":\n    os.makedirs(\"logs\", exist_ok=True)\n    result = scan_all_files()\n    with open(CHUNKS_PATH, \"w\", encoding=\"utf-8\") as f:\n        json.dump(result, f, indent=2, ensure_ascii=False)\n    print(f\"‚úÖ Tree-sitter —á–∞–Ω–∫–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã ‚Üí {CHUNKS_PATH}\")",
  "agents/telegram_bot.py::header": "import logging\n\nfrom telegram import Update\nfrom telegram.ext import Application, CommandHandler, MessageHandler, filters, ContextTypes\n\nfrom saci_orchestrator.orchestrator import SACIOrchestrator\n\nlogging.basicConfig(level=logging.INFO)",
  "agents/telegram_bot.py::class_TelegramBot": "class TelegramBot:\n    def __init__(self, token: str):\n        self.orchestrator = SACIOrchestrator()\n        self.application = Application.builder().token(token).build()\n\n        # –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–æ–º–∞–Ω–¥—ã /start\n        self.application.add_handler(CommandHandler(\"start\", self.start))\n        # –û–±—Ä–∞–±–æ—Ç—á–∏–∫ —Ç–µ–∫—Å—Ç–æ–≤—ã—Ö —Å–æ–æ–±—â–µ–Ω–∏–π\n        self.application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, self.handle_message))\n\n    async def start(self, update: Update, context: ContextTypes.DEFAULT_TYPE):\n        await update.message.reply_text(\"–ü—Ä–∏–≤–µ—Ç! –û—Ç–ø—Ä–∞–≤—å –æ–ø–∏—Å–∞–Ω–∏–µ —Ç–µ—Ö–Ω–æ–ª–æ–≥–∏–∏, –∫–æ—Ç–æ—Ä—É—é —Ö–æ—á–µ—à—å —Ä–∞–∑—Ä–∞–±–æ—Ç–∞—Ç—å.\")\n\n    async def handle_message(self, update: Update, context: ContextTypes.DEFAULT_TYPE):\n        user_goal = update.message.text\n        # –ü–µ—Ä–µ–¥–∞–µ–º —Ü–µ–ª—å –≤ SACI-–æ—Ä–∫–µ—Å—Ç—Ä–∞—Ç–æ—Ä\n        self.orchestrator.set_goal(user_goal)\n        tasks = self.orchestrator.plan_tasks()\n\n        response = \"–¶–µ–ª—å —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞. –ü–ª–∞–Ω –∑–∞–¥–∞—á:\\n\" + \"\\n\".join(f\"{i+1}. {task}\" for i, task in enumerate(tasks))\n        await update.message.reply_text(response)\n\n    def run(self):\n        self.application.run_polling()\n\nif __name__ == \"__main__\":\n    # –ó–∞–º–µ–Ω–∏—Ç–µ –Ω–∞ —Å–≤–æ–π —Ç–æ–∫–µ–Ω Telegram Bot\n    TOKEN = \"7207967791:AAE718TLFOyr71INFTu-qYa4dzcf8PDawPM\"\n    bot = TelegramBot(TOKEN)\n    bot.run()",
  "agents/file_splitter.py::header": "import os\nimport json\nimport re\n\nFILE_MAP_PATH = \"logs/saci_file_map.json\"\nCHUNK_OUTPUT = \"logs/saci_code_chunks.json\"",
  "agents/file_splitter.py::def_split_py_file": "def split_py_file(name, code):\n    chunks = {}\n    lines = code.split('\\n')\n    current_chunk = []\n    current_name = \"header\"\n    indent_base = None\n\n    for i, line in enumerate(lines):\n        func_match = re.match(r'^def ([a-zA-Z0-9_]+)\\(', line)\n        class_match = re.match(r'^class ([a-zA-Z0-9_]+)', line)\n\n        if func_match or class_match:\n            # save previous\n            if current_chunk:\n                chunks[f\"{name}::{current_name}\"] = '\\n'.join(current_chunk).strip()\n                current_chunk = []\n\n            if func_match:\n                current_name = f\"def_{func_match.group(1)}\"\n            elif class_match:\n                current_name = f\"class_{class_match.group(1)}\"\n\n        current_chunk.append(line)\n\n    if current_chunk:\n        chunks[f\"{name}::{current_name}\"] = '\\n'.join(current_chunk).strip()\n\n    return chunks",
  "agents/file_splitter.py::def_split_all_py_files": "def split_all_py_files(file_map):\n    all_chunks = {}\n    for name, content in file_map.items():\n        if name.endswith(\".py\"):\n            chunks = split_py_file(name, content)\n            all_chunks.update(chunks)\n    return all_chunks",
  "agents/file_splitter.py::def_run_split": "def run_split():\n    if not os.path.exists(FILE_MAP_PATH):\n        print(\"‚ùå –ù–µ –Ω–∞–π–¥–µ–Ω saci_file_map.json\")\n        return\n\n    with open(FILE_MAP_PATH, \"r\", encoding=\"utf-8\") as f:\n        file_map = json.load(f)\n\n    chunks = split_all_py_files(file_map)\n    os.makedirs(\"logs\", exist_ok=True)\n    with open(CHUNK_OUTPUT, \"w\", encoding=\"utf-8\") as f:\n        json.dump(chunks, f, indent=2, ensure_ascii=False)\n\n    print(f\"‚úÖ –†–∞–∑–¥–µ–ª–µ–Ω–æ —á–∞–Ω–∫–æ–≤: {len(chunks)}\")\n    print(f\"üì¶ –°–æ—Ö—Ä–∞–Ω–µ–Ω–æ –≤ {CHUNK_OUTPUT}\")\n\nif __name__ == \"__main__\":\n    run_split()",
  "agents/code_analyst.py::header": "import os\nimport json\nimport openai\nimport requests\nfrom dotenv import load_dotenv\n\nload_dotenv()\n\nOPENAI_API_KEY = os.getenv(\"OPENAI_API_KEY\")\nBOT_TOKEN = os.getenv(\"TELEGRAM_BOT_TOKEN\")\nCHAT_ID = os.getenv(\"TELEGRAM_CHAT_ID\")\n\nopenai.api_key = OPENAI_API_KEY\n\nFILE_MAP_PATH = \"logs/saci_file_map.json\"\nFILES_TO_ANALYZE = [\"agents/developer.py\", \"agents/tester.py\", \"agents/goal_runner.py\"]",
  "agents/code_analyst.py::def_load_file_map": "def load_file_map():\n    if not os.path.exists(FILE_MAP_PATH):\n        return {}\n    with open(FILE_MAP_PATH, \"r\", encoding=\"utf-8\") as f:\n        return json.load(f)",
  "agents/code_analyst.py::def_analyze_code_with_gpt": "def analyze_code_with_gpt(filename, content):\n    prompt = f\"\"\"\n–¢—ã ‚Äî AI-–∫–æ–¥-—Ä–µ–≤—å—é–µ—Ä SACI. –ü—Ä–æ–∞–Ω–∞–ª–∏–∑–∏—Ä—É–π —Ñ–∞–π–ª `{filename}`. –î–∞–π —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏ –ø–æ:\n- —É–ª—É—á—à–µ–Ω–∏—é –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä—ã\n- —É—Å—Ç—Ä–∞–Ω–µ–Ω–∏—é –ø–æ–≤—Ç–æ—Ä–æ–≤\n- —á–∏—Ç–∞–µ–º–æ—Å—Ç–∏\n- —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏\n\n–í—ã–≤–µ–¥–∏ –∫—Ä–∞—Ç–∫–æ –≤ –≤–∏–¥–µ —Å–ø–∏—Å–∫–∞ —Å —ç–º–æ–¥–∂–∏:\n{content[:3000]}\n    \"\"\"\n\n    try:\n        response = openai.ChatCompletion.create(\n            model=\"gpt-4\",\n            messages=[\n                {\"role\": \"system\", \"content\": \"–¢—ã ‚Äî AI-–∞—Ä—Ö–∏—Ç–µ–∫—Ç–æ—Ä SACI.\"},\n                {\"role\": \"user\", \"content\": prompt}\n            ],\n            temperature=0.3,\n            max_tokens=600\n        )\n        return response.choices[0].message.content.strip()\n    except Exception as e:\n        return f\"‚ùå –û—à–∏–±–∫–∞ GPT: {e}\"",
  "agents/code_analyst.py::def_send_to_telegram": "def send_to_telegram(text):\n    url = f\"https://api.telegram.org/bot{BOT_TOKEN}/sendMessage\"\n    payload = {\"chat_id\": CHAT_ID, \"text\": text}\n    response = requests.post(url, data=payload)\n    if response.status_code == 200:\n        print(\"üì¨ –ê–Ω–∞–ª–∏–∑ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω –≤ Telegram.\")\n    else:\n        print(f\"‚ùå –û—à–∏–±–∫–∞ Telegram: {response.status_code} {response.text}\")",
  "agents/code_analyst.py::def_run_analysis": "def run_analysis(all_files=False):\n    print(\"üß† –ó–∞–ø—É—Å–∫ –∞–Ω–∞–ª–∏–∑–∞ –∫–æ–¥–∞...\")\n    file_map = load_file_map()\n    if not file_map:\n        send_to_telegram(\"‚ö†Ô∏è –§–∞–π–ª saci_file_map.json –Ω–µ –Ω–∞–π–¥–µ–Ω.\")\n        return\n\n    files_to_process = file_map.keys() if all_files else FILES_TO_ANALYZE\n\n    for filename in files_to_process:\n        content = file_map.get(filename)\n        if not content:\n            continue\n\n        print(f\"üîç –ê–Ω–∞–ª–∏–∑: {filename}\")\n        result = analyze_code_with_gpt(filename, content)\n        send_to_telegram(f\"üìÑ –ê–Ω–∞–ª–∏–∑ `{filename}`:\\n\\n{result}\")\n\nif __name__ == \"__main__\":\n    import sys\n    run_analysis(all_files=\"all\" in sys.argv)",
  "agents/deployer.py::class_Deployer": "class Deployer:\n    def execute(self, data):\n        data[\"deployment\"] = \"–ú–æ–¥—É–ª—å –∑–∞–¥–µ–ø–ª–æ–µ–Ω —É—Å–ø–µ—à–Ω–æ.\"\n        return data",
  "agents/project_manager.py::header": "import json\nimport os\nfrom datetime import datetime\nimport requests\nfrom dotenv import load_dotenv\nfrom collections import Counter\n\nload_dotenv()\n\nGOAL_STATE = \"saci_goal_state.json\"\nGOAL_LOG = \"logs/goals_log.json\"\nBOT_TOKEN = os.getenv(\"TELEGRAM_BOT_TOKEN\")\nCHAT_ID = os.getenv(\"TELEGRAM_CHAT_ID\")",
  "agents/project_manager.py::def_log_current_goal": "def log_current_goal():\n    if not os.path.exists(GOAL_STATE):\n        return\n\n    with open(GOAL_STATE) as f:\n        goal_data = json.load(f)\n\n    goal_data[\"timestamp\"] = datetime.now().strftime(\"%Y-%m-%d %H:%M\")\n\n    if not os.path.exists(GOAL_LOG):\n        log = []\n    else:\n        with open(GOAL_LOG) as f:\n            log = json.load(f)\n\n    log.append(goal_data)\n\n    with open(GOAL_LOG, \"w\") as f:\n        json.dump(log, f, indent=4, ensure_ascii=False)\n\n    print(\"üìò –¶–µ–ª—å –∑–∞—Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–∞ –≤ –∂—É—Ä–Ω–∞–ª–µ.\")",
  "agents/project_manager.py::def_extract_filename_from_goal": "def extract_filename_from_goal(goal):\n    words = goal.split()\n    for word in words:\n        if word.endswith((\".py\", \".md\", \".json\", \".yml\", \".yaml\")):\n            return word\n    return None",
  "agents/project_manager.py::def_generate_summary_rich": "def generate_summary_rich():\n    if not os.path.exists(GOAL_LOG):\n        return \"–ù–µ—Ç –∂—É—Ä–Ω–∞–ª–æ–≤ —Ü–µ–ª–µ–π –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞.\"\n\n    with open(GOAL_LOG) as f:\n        log = json.load(f)\n\n    today = datetime.now().strftime(\"%Y-%m-%d\")\n    today_goals = [g for g in log if g['timestamp'].startswith(today)]\n\n    if not today_goals:\n        return \"–°–µ–≥–æ–¥–Ω—è –µ—â—ë –Ω–µ –±—ã–ª–æ –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏.\"\n\n    statuses = Counter(g[\"status\"] for g in today_goals)\n    all_goals = [g[\"goal\"] for g in today_goals]\n    files = [extract_filename_from_goal(g[\"goal\"]) for g in today_goals if extract_filename_from_goal(g[\"goal\"])]\n    extensions = [os.path.splitext(f)[-1] for f in files if f]\n\n    # –ù–∞—Ö–æ–¥–∏–º –ø–æ–≤—Ç–æ—Ä—è—é—â–∏–µ—Å—è —Ü–µ–ª–∏\n    repeated = [item for item, count in Counter(all_goals).items() if count > 1]\n\n    summary = f\"\"\"üìä SACI /summary ‚Äî {today}\n\nüéØ –¶–µ–ª–µ–π –∑–∞ –¥–µ–Ω—å: {len(today_goals)}\n‚úÖ –í—ã–ø–æ–ª–Ω–µ–Ω–æ: {statuses.get('complete', 0)}\n‚ö†Ô∏è –ü–æ–≤—Ç–æ—Ä—ã —Ü–µ–ª–µ–π: {len(repeated)}\nüìÅ –ù–æ–≤—ã—Ö —Ñ–∞–π–ª–æ–≤: {len(set(files))}\nüìÇ –¢–∏–ø—ã: {', '.join(sorted(set(extensions))) or '‚Äî'}\n\nüìå –ü–æ—Å–ª–µ–¥–Ω—è—è —Ü–µ–ª—å: {today_goals[-1]['goal']}\nüïí –í—Ä–µ–º—è –ø–æ—Å–ª–µ–¥–Ω–µ–π –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏: {today_goals[-1]['timestamp']}\n\"\"\"\n\n    return summary",
  "agents/project_manager.py::def_send_summary_to_telegram": "def send_summary_to_telegram():\n    summary = generate_summary_rich()\n    url = f\"https://api.telegram.org/bot{BOT_TOKEN}/sendMessage\"\n    payload = {\"chat_id\": CHAT_ID, \"text\": summary}\n    response = requests.post(url, data=payload)\n    if response.status_code == 200:\n        print(\"üì¨ –î–Ω–µ–≤–Ω–æ–π –æ—Ç—á—ë—Ç –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω –≤ Telegram.\")\n    else:\n        print(f\"‚ùå –û—à–∏–±–∫–∞ Telegram: {response.status_code} {response.text}\")\n\nif __name__ == \"__main__\":\n    log_current_goal()\n    send_summary_to_telegram()",
  "agents/code_metrics.py::header": "import os\nimport json\nfrom datetime import datetime\n\nLOG_PATH = \"logs/code_metrics.json\"",
  "agents/code_metrics.py::def_collect_code_metrics": "def collect_code_metrics():\n    total_lines = 0\n    file_count = 0\n    for root, _, files in os.walk(\".\"):\n        if any(x in root for x in [\"venv\", \"__pycache__\", \"node_modules\", \"logs\"]):\n            continue\n        for file in files:\n            if file.endswith(\".py\"):\n                path = os.path.join(root, file)\n                with open(path, \"r\", encoding=\"utf-8\", errors=\"ignore\") as f:\n                    lines = f.readlines()\n                    total_lines += len(lines)\n                    file_count += 1\n    return {\n        \"timestamp\": datetime.now().strftime(\"%Y-%m-%d %H:%M\"),\n        \"files\": file_count,\n        \"lines\": total_lines\n    }",
  "agents/code_metrics.py::def_append_to_log": "def append_to_log(metrics):\n    os.makedirs(\"logs\", exist_ok=True)\n    if os.path.exists(LOG_PATH):\n        with open(LOG_PATH, \"r\", encoding=\"utf-8\") as f:\n            log = json.load(f)\n    else:\n        log = []\n    log.append(metrics)\n    with open(LOG_PATH, \"w\", encoding=\"utf-8\") as f:\n        json.dump(log, f, indent=2)",
  "agents/code_metrics.py::def_show_growth": "def show_growth():\n    if not os.path.exists(LOG_PATH):\n        print(\"–ù–µ—Ç —Å–æ—Ö—Ä–∞–Ω—ë–Ω–Ω—ã—Ö –º–µ—Ç—Ä–∏–∫.\")\n        return\n    with open(LOG_PATH, \"r\", encoding=\"utf-8\") as f:\n        log = json.load(f)\n    if len(log) < 2:\n        print(\"–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞ —Ä–æ—Å—Ç–∞.\")\n        return\n\n    last = log[-1]\n    prev = log[-2]\n    delta_lines = last[\"lines\"] - prev[\"lines\"]\n    delta_files = last[\"files\"] - prev[\"files\"]\n\n    print(f\"üìä –†–æ—Å—Ç –∫–æ–¥–∞ —Å –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ –∑–∞–ø—É—Å–∫–∞:\")\n    print(f\"+ {delta_files} —Ñ–∞–π–ª–æ–≤\")\n    print(f\"+ {delta_lines} —Å—Ç—Ä–æ–∫\")\n\nif __name__ == \"__main__\":\n    metrics = collect_code_metrics()\n    append_to_log(metrics)\n    print(f\"üì¶ –°—Ç—Ä–æ–∫: {metrics['lines']} –≤ {metrics['files']} —Ñ–∞–π–ª–∞—Ö\")\n    show_growth()",
  "agents/goal_runner.py::header": "import os\nimport json\nimport subprocess\nimport time\n\nGOAL_STATE = \"saci_goal_state.json\"",
  "agents/goal_runner.py::def_load_goal": "def load_goal():\n    if not os.path.exists(GOAL_STATE):\n        return None\n    with open(GOAL_STATE) as f:\n        return json.load(f)",
  "agents/goal_runner.py::def_save_goal": "def save_goal(data):\n    with open(GOAL_STATE, \"w\") as f:\n        json.dump(data, f, indent=4, ensure_ascii=False)",
  "agents/goal_runner.py::def_run_cycle": "def run_cycle():\n    while True:\n        goal_data = load_goal()\n        if not goal_data:\n            print(\"‚è≥ –û–∂–∏–¥–∞–Ω–∏–µ –Ω–æ–≤–æ–π —Ü–µ–ª–∏...\")\n            time.sleep(10)\n            continue\n\n        status = goal_data.get(\"status\", \"\")\n        goal = goal_data.get(\"goal\", \"\").lower()\n\n        print(f\"üìç –°—Ç–∞—Ç—É—Å —Ü–µ–ª–∏: {status}\")\n\n        if status == \"in_progress\":\n            if \"test\" in goal and not goal_data.get(\"dev_done\"):\n                print(\"üë®‚Äçüíª –ó–∞–ø—É—Å–∫ developer.py\")\n                subprocess.run([\"python\", \"agents/developer.py\"])\n            elif \"test\" in goal and not goal_data.get(\"test_done\"):\n                print(\"üß™ –ó–∞–ø—É—Å–∫ tester.py\")\n                subprocess.run([\"python\", \"agents/tester.py\"])\n            elif \"test\" in goal and goal_data.get(\"dev_done\") and goal_data.get(\"test_done\"):\n                print(\"üìò –ó–∞–≤–µ—Ä—à–∞–µ–º —Ü–∏–∫–ª —á–µ—Ä–µ–∑ project_manager\")\n                subprocess.run([\"python\", \"agents/project_manager.py\"])\n                goal_data[\"status\"] = \"complete\"\n                save_goal(goal_data)\n\n        elif status == \"done\":\n            print(\"üìò –ó–∞–≤–µ—Ä—à–∞–µ–º —Ü–∏–∫–ª (–±–µ–∑ —Ç–µ—Å—Ç–æ–≤) —á–µ—Ä–µ–∑ project_manager\")\n            subprocess.run([\"python\", \"agents/project_manager.py\"])\n            goal_data[\"status\"] = \"complete\"\n            save_goal(goal_data)\n\n        else:\n            print(f\"üìå –¢–µ–∫—É—â–∏–π —Å—Ç–∞—Ç—É—Å: {status} ‚Üí –æ–∂–∏–¥–∞–Ω–∏–µ...\")\n\n        time.sleep(5)\n\nif __name__ == \"__main__\":\n    run_cycle()",
  "agents/repair_commit_with_log.py::header": "import os\nimport openai\nimport json\nfrom dotenv import load_dotenv\nfrom datetime import datetime\n\nload_dotenv()\nopenai.api_key = os.getenv(\"OPENAI_API_KEY\")\n\nPATCH_DIR = \"patches\"\nREPAIRED_DIR = \"patches/repaired\"",
  "agents/repair_commit_with_log.py::def_is_patch_broken": "def is_patch_broken(text):\n    return not text.startswith(\"diff --git\") or \"@@\" not in text or \"--- \" not in text",
  "agents/repair_commit_with_log.py::def_fix_patch_with_gpt": "def fix_patch_with_gpt(bad_patch):\n    prompt = f\"\"\"\n–ù–∏–∂–µ –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –ø–æ–≤—Ä–µ–∂–¥—ë–Ω–Ω—ã–π –∏–ª–∏ –Ω–µ–ø–æ–ª–Ω—ã–π git patch. –í–æ—Å—Å—Ç–∞–Ω–æ–≤–∏ –µ–≥–æ –≤ –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–º —Ñ–æ—Ä–º–∞—Ç–µ unified diff.\n{bad_patch[:3000]}\n\n–í–µ—Ä–Ω–∏ —Ç–æ–ª—å–∫–æ –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã–π diff. –ë–µ–∑ –ø–æ—è—Å–Ω–µ–Ω–∏–π.\n\"\"\"\n    response = openai.ChatCompletion.create(\n        model=\"gpt-4\",\n        messages=[\n            {\"role\": \"system\", \"content\": \"–¢—ã ‚Äî AI-–ø–∞—Ç—á–µ—Ä SACI.\"},\n            {\"role\": \"user\", \"content\": prompt}\n        ],\n        temperature=0.2,\n        max_tokens=1000\n    )\n    return response['choices'][0]['message']['content'].strip()",
  "agents/repair_commit_with_log.py::def_run_patch_fix": "def run_patch_fix():\n    os.makedirs(REPAIRED_DIR, exist_ok=True)\n\n    for file in os.listdir(PATCH_DIR):\n        if not file.endswith(\".patch\"):\n            continue\n\n        path = os.path.join(PATCH_DIR, file)\n        with open(path, \"r\", encoding=\"utf-8\") as f:\n            content = f.read()\n\n        if is_patch_broken(content):\n            print(f\"‚ùå –ü–∞—Ç—á {file} –ø–æ–≤—Ä–µ–∂–¥—ë–Ω. GPT –≤–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç...\")\n            fixed = fix_patch_with_gpt(content)\n            repaired_path = os.path.join(REPAIRED_DIR, file)\n            with open(repaired_path, \"w\", encoding=\"utf-8\") as f:\n                f.write(fixed)\n            print(f\"‚úÖ –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–æ –∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–æ: {repaired_path}\")\n        else:\n            print(f\"‚úÖ –ü–∞—Ç—á {file} –≤ –ø–æ—Ä—è–¥–∫–µ.\")\n\nif __name__ == \"__main__\":\n    run_patch_fix()",
  "agents/strategist.py::class_Strategist": "class Strategist:\n    def execute(self, data):\n        goal = data.get(\"goal\", \"–Ω–µ—Ç —Ü–µ–ª–∏\")\n        data[\"strategy\"] = f\"–†–∞–∑—Ä–∞–±–æ—Ç–∫–∞ —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏ –¥–ª—è —Ü–µ–ª–∏: {goal}\"\n        return data",
  "agents/developer.py::header": "import os\nimport json\n\nGOAL_STATE = \"saci_goal_state.json\"",
  "agents/developer.py::def_run_developer_agent": "def run_developer_agent():\n    if not os.path.exists(GOAL_STATE):\n        print(\"‚ùå –ù–µ—Ç —Ü–µ–ª–∏.\")\n        return\n\n    with open(GOAL_STATE) as f:\n        goal_data = json.load(f)\n\n    goal = goal_data.get(\"goal\", \"\")\n    updated = False\n\n    filename = extract_filename_from_goal(goal)\n    if filename:\n        extension = os.path.splitext(filename)[-1]\n        if extension == \".py\" and filename.startswith(\"test_\"):\n            generate_py_test(filename)\n        elif extension == \".py\":\n            generate_python_stub(filename)\n        elif extension == \".md\":\n            generate_markdown_doc(filename, goal)\n        elif extension == \".json\":\n            generate_json_config(filename)\n        elif extension in [\".yml\", \".yaml\"]:\n            generate_yaml_config(filename)\n        else:\n            print(f\"‚ö†Ô∏è –ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ–µ —Ä–∞—Å—à–∏—Ä–µ–Ω–∏–µ: {extension}\")\n        updated = True\n\n    if updated:\n        goal_data[\"dev_done\"] = True\n        goal_data[\"status\"] = \"done\"\n        with open(GOAL_STATE, \"w\") as f:\n            json.dump(goal_data, f, indent=4, ensure_ascii=False)\n        print(f\"‚úÖ –¶–µ–ª—å developer.py –∑–∞–≤–µ—Ä—à–µ–Ω–∞: {goal}\")\n    else:\n        print(\"‚ö†Ô∏è –¶–µ–ª—å developer.py –Ω–µ —Ä–∞—Å–ø–æ–∑–Ω–∞–Ω–∞.\")",
  "agents/developer.py::def_extract_filename_from_goal": "def extract_filename_from_goal(goal):\n    words = goal.split()\n    for word in words:\n        if any(word.endswith(ext) for ext in [\".py\", \".md\", \".json\", \".yml\", \".yaml\"]):\n            return word\n    return None",
  "agents/developer.py::def_generate_python_stub": "def generate_python_stub(filename):\n    path = ensure_path(filename)\n    class_name = class_from_filename(filename)\n    content = f'''\"\"\"\n{filename} ‚Äî –∞–≤—Ç–æ—Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–π SACI –º–æ–¥—É–ª—å.\n\"\"\"\n\nclass {class_name}:\n    def __init__(self):\n        pass\n\n    def run(self):\n        print(\"üöÄ {class_name} –≥–æ—Ç–æ–≤ –∫ —Ä–∞–±–æ—Ç–µ.\")\n\nif __name__ == \"__main__\":\n    agent = {class_name}()\n    agent.run()\n'''\n    write_file(path, content)",
  "agents/developer.py::def_generate_py_test": "def generate_py_test(filename):\n    path = ensure_path(filename)\n    content = f'''import unittest",
  "agents/developer.py::class_TestGenerated": "class TestGenerated(unittest.TestCase):\n    def test_placeholder(self):\n        self.assertTrue(True)\n\nif __name__ == \"__main__\":\n    unittest.main()\n'''\n    write_file(path, content)",
  "agents/developer.py::def_generate_markdown_doc": "def generate_markdown_doc(filename, goal):\n    path = ensure_path(filename)\n    title = goal.split(\" —Å–æ–∑–¥–∞—Ç—å \")[-1] if \"—Å–æ–∑–¥–∞—Ç—å\" in goal else filename.replace(\".md\", \"\")\n    content = f'''# {title.title()}\n\n> –ê–≤—Ç–æ—Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–π SACI –¥–æ–∫—É–º–µ–Ω—Ç –ø–æ —Ü–µ–ª–∏:\n\nüéØ **{goal}**\n\n---\n\n## TODO\n\n- [ ] –û–ø—Ä–µ–¥–µ–ª–∏—Ç—å —Å—Ç—Ä—É–∫—Ç—É—Ä—É\n- [ ] –î–æ–±–∞–≤–∏—Ç—å –æ–ø–∏—Å–∞–Ω–∏–µ\n- [ ] –ó–∞–≤–µ—Ä—à–∏—Ç—å —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—é\n'''\n    write_file(path, content)",
  "agents/developer.py::def_generate_json_config": "def generate_json_config(filename):\n    path = ensure_path(filename)\n    default = {\n        \"name\": filename.replace(\".json\", \"\"),\n        \"description\": \"\",\n        \"version\": \"1.0\",\n        \"config\": {}\n    }\n    write_file(path, json.dumps(default, indent=4, ensure_ascii=False))",
  "agents/developer.py::def_generate_yaml_config": "def generate_yaml_config(filename):\n    path = ensure_path(filename)\n    content = f'''# {filename}\nname: sample_pipeline\ndescription: SACI auto-generated YAML config\nsteps:\n  - name: analyze\n    run: python analyze.py\n  - name: generate\n    run: python developer.py\n'''\n    write_file(path, content)",
  "agents/developer.py::def_ensure_path": "def ensure_path(filename):\n    parts = filename.split(\"/\")\n    if len(parts) > 1:\n        dir_path = os.path.join(*parts[:-1])\n        os.makedirs(dir_path, exist_ok=True)\n    return filename",
  "agents/developer.py::def_write_file": "def write_file(path, content):\n    with open(path, \"w\", encoding=\"utf-8\") as f:\n        f.write(content)\n    print(f\"üì¶ –°–æ–∑–¥–∞–Ω —Ñ–∞–π–ª: {path}\")",
  "agents/developer.py::def_class_from_filename": "def class_from_filename(filename):\n    base = os.path.splitext(os.path.basename(filename))[0]\n    return ''.join(word.capitalize() for word in base.split(\"_\"))\n\nif __name__ == \"__main__\":\n    run_developer_agent()",
  "agents/saci_contact_bot.py::header": "",
  "agents/tester.py::header": "import os\nimport json\nimport subprocess\nimport requests\nfrom dotenv import load_dotenv\n\nload_dotenv()\n\nGOAL_STATE = \"saci_goal_state.json\"\nBOT_TOKEN = os.getenv(\"TELEGRAM_BOT_TOKEN\")\nCHAT_ID = os.getenv(\"TELEGRAM_CHAT_ID\")",
  "agents/tester.py::def_send_telegram_message": "def send_telegram_message(message):\n    url = f\"https://api.telegram.org/bot{BOT_TOKEN}/sendMessage\"\n    data = {\"chat_id\": CHAT_ID, \"text\": message}\n    try:\n        requests.post(url, data=data)\n    except Exception as e:\n        print(f\"‚ùå –û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ –≤ Telegram: {e}\")",
  "agents/tester.py::def_run_tests": "def run_tests():\n    if not os.path.exists(GOAL_STATE):\n        print(\"‚ùå –ù–µ—Ç –∞–∫—Ç–∏–≤–Ω–æ–π —Ü–µ–ª–∏.\")\n        return\n\n    with open(GOAL_STATE) as f:\n        data = json.load(f)\n\n    if data[\"status\"] != \"done\":\n        print(\"‚ÑπÔ∏è –¶–µ–ª—å –µ—â—ë –Ω–µ –∑–∞–≤–µ—Ä—à–µ–Ω–∞.\")\n        return\n\n    if \"test_patch_predictor.py\" not in data[\"goal\"]:\n        print(\"‚ÑπÔ∏è –¢–µ–∫—É—â–∞—è —Ü–µ–ª—å –Ω–µ —Ç—Ä–µ–±—É–µ—Ç –∑–∞–ø—É—Å–∫–∞ —Ç–µ—Å—Ç–æ–≤.\")\n        return\n\n    print(\"üß™ –ó–∞–ø—É—Å–∫ unittest –Ω–∞ tests/\")\n    result = subprocess.run([\"python\", \"-m\", \"unittest\", \"discover\", \"tests\"], capture_output=True, text=True)\n\n    summary = \"‚úÖ –í—Å–µ —Ç–µ—Å—Ç—ã –ø—Ä–æ—à–ª–∏ —É—Å–ø–µ—à–Ω–æ.\" if result.returncode == 0 else \"‚ùå –û–±–Ω–∞—Ä—É–∂–µ–Ω—ã –æ—à–∏–±–∫–∏ –≤ —Ç–µ—Å—Ç–∞—Ö.\"\n\n    report = f\"\"\"üìä *SACI Test Report*\nüéØ –¶–µ–ª—å: {data['goal']}\nüì¶ –§–∞–π–ª: test_patch_predictor.py\nüìã –†–µ–∑—É–ª—å—Ç–∞—Ç: {\"‚úÖ PASSED\" if result.returncode == 0 else \"‚ùå FAILED\"}\n\"\"\"\n\n    print(report)\n    send_telegram_message(report)\n\nif __name__ == \"__main__\":\n    run_tests()",
  "agents/agent_hub.py::header": "\"\"\"\nSACI Agent Hub ‚Äî –º–∞—Ä—à—Ä—É—Ç–∏–∑–∞—Ç–æ—Ä –∑–∞–¥–∞—á –º–µ–∂–¥—É AI-–∞–≥–µ–Ω—Ç–∞–º–∏.\n\"\"\"",
  "agents/agent_hub.py::def_route_goal": "def route_goal(goal):\n    if \"strategy\" in goal:\n        from strategist import plan\n        return plan(goal)\n    elif \"test\" in goal:\n        from tester import run_tests\n        return run_tests(goal)\n    else:\n        from developer import build\n        return build(goal)\n\nif __name__ == \"__main__\":\n    print(\"üß† Agent Hub –∑–∞–ø—É—â–µ–Ω.\")",
  "scripts/auto_loop.py::header": "import subprocess\nimport time\nimport json\nimport os\nfrom agents.architect import analyze_repo_and_suggest_goal\n\nGOAL_STATE = \"saci_goal_state.json\"\nSTOP_FILE = \".saci_stop\"\nGOAL_LOG = \"logs/goals_log.json\"",
  "scripts/auto_loop.py::def_archive_completed": "def archive_completed():\n    if not os.path.exists(GOAL_STATE):\n        return\n    with open(GOAL_STATE) as f:\n        goal = json.load(f)\n    if goal.get(\"status\") == \"complete\":\n        subprocess.run([\"python\", \"agents/project_manager.py\"])\n        os.remove(GOAL_STATE)\n        print(\"üì¶ –ó–∞–≤–µ—Ä—à—ë–Ω–Ω–∞—è —Ü–µ–ª—å –∑–∞–∞—Ä—Ö–∏–≤–∏—Ä–æ–≤–∞–Ω–∞.\")",
  "scripts/auto_loop.py::def_already_done": "def already_done(goal_text):\n    if not os.path.exists(GOAL_LOG):\n        return False\n    with open(GOAL_LOG) as f:\n        log = json.load(f)\n    return any(goal_text in g.get(\"goal\", \"\") for g in log)",
  "scripts/auto_loop.py::def_create_new_goal": "def create_new_goal():\n    subprocess.run([\"python\", \"saci_remote_agent.py\"])\n    goal = analyze_repo_and_suggest_goal()\n    if already_done(goal):\n        print(f\"‚ö†Ô∏è –¶–µ–ª—å —É–∂–µ –≤—ã–ø–æ–ª–Ω—è–ª–∞—Å—å: {goal} ‚Äî –ø—Ä–æ–ø—É—Å–∫–∞–µ–º.\")\n        return False\n    goal_data = {\n        \"goal\": goal,\n        \"status\": \"in_progress\",\n        \"timestamp\": subprocess.getoutput(\"date '+%Y-%m-%d %H:%M'\"),\n        \"dev_done\": False,\n        \"test_done\": False\n    }\n    with open(GOAL_STATE, \"w\") as f:\n        json.dump(goal_data, f, indent=4, ensure_ascii=False)\n    print(f\"üéØ –ù–æ–≤–∞—è —Ü–µ–ª—å: {goal}\")\n    return True",
  "scripts/auto_loop.py::def_run_chain": "def run_chain():\n    subprocess.run([\"python\", \"agents/developer.py\"])\n    subprocess.run([\"python\", \"agents/tester.py\"])\n    subprocess.run([\"python\", \"agents/project_manager.py\"])\n    with open(GOAL_STATE) as f:\n        goal_data = json.load(f)\n    goal_data[\"status\"] = \"complete\"\n    with open(GOAL_STATE, \"w\") as f:\n        json.dump(goal_data, f, indent=4)\n    print(\"‚úÖ –¶–∏–∫–ª –∑–∞–≤–µ—Ä—à—ë–Ω.\")",
  "scripts/auto_loop.py::def_auto_loop": "def auto_loop():\n    print(\"üîÅ –ó–∞–ø—É—Å–∫ SACI AutoLoop v2.0\")\n    while True:\n        if os.path.exists(STOP_FILE):\n            print(\"üõë –ü–æ–ª—É—á–µ–Ω —Å–∏–≥–Ω–∞–ª –æ—Å—Ç–∞–Ω–æ–≤–∫–∏. –¶–∏–∫–ª –∑–∞–≤–µ—Ä—à—ë–Ω.\")\n            break\n        archive_completed()\n        success = create_new_goal()\n        if success:\n            run_chain()\n        else:\n            print(\"‚è≥ –ñ–¥—ë–º 60 —Å–µ–∫—É–Ω–¥ –ø–µ—Ä–µ–¥ –Ω–æ–≤–æ–π –ø–æ–ø—ã—Ç–∫–æ–π...\\n\")\n            time.sleep(60)\n\nif __name__ == \"__main__\":\n    auto_loop()",
  "scripts/module_gen_interactive.py::header": "import os\nfrom developer import (\n    generate_python_stub,\n    generate_py_test,\n    generate_markdown_doc,\n    generate_json_config,\n    generate_yaml_config,\n    ensure_path,\n    write_file\n)",
  "scripts/module_gen_interactive.py::def_auto_init_py": "def auto_init_py(directory):\n    parts = directory.split(\"/\")\n    for i in range(1, len(parts)+1):\n        path = os.path.join(*parts[:i])\n        init_path = os.path.join(path, \"__init__.py\")\n        if not os.path.exists(init_path):\n            with open(init_path, \"w\") as f:\n                f.write(\"# auto-generated by SACI\\n\")",
  "scripts/module_gen_interactive.py::def_register_module": "def register_module(path):\n    registry = \"modules/module_registry.py\"\n    os.makedirs(\"modules\", exist_ok=True)\n    if not os.path.exists(registry):\n        with open(registry, \"w\") as f:\n            f.write(\"# SACI Module Registry\\nregistered_modules = []\\n\")\n\n    with open(registry, \"a\") as f:\n        f.write(f'registered_modules.append(\"{path}\")\\n')\n    print(f\"üßæ –ó–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω–æ –≤ module_registry.py: {path}\")",
  "scripts/module_gen_interactive.py::def_generate_module": "def generate_module(path, mtype):\n    if mtype == \"py\":\n        generate_python_stub(path)\n    elif mtype == \"test\":\n        generate_py_test(path)\n    elif mtype == \"md\":\n        generate_markdown_doc(path, path)\n    elif mtype == \"json\":\n        generate_json_config(path)\n    elif mtype in [\"yml\", \"yaml\"]:\n        generate_yaml_config(path)\n    else:\n        print(\"‚ùå –ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π —Ç–∏–ø.\")\n        return\n\n    if \"/\" in path:\n        auto_init_py(\"/\".join(path.split(\"/\")[:-1]))\n    register_module(path)",
  "scripts/module_gen_interactive.py::def_interactive": "def interactive():\n    print(\"\\nüéõ SACI Module Generator [Interactive Mode]\\n\")\n    path = input(\"üìÑ –í–≤–µ–¥–∏—Ç–µ –ø—É—Ç—å –∫ –º–æ–¥—É–ª—é (–Ω–∞–ø—Ä–∏–º–µ—Ä: core/saci_memory.py): \").strip()\n\n    print(\"\\nüß© –í—ã–±–µ—Ä–∏—Ç–µ —Ç–∏–ø –º–æ–¥—É–ª—è:\")\n    print(\"1. Python class [.py]\")\n    print(\"2. Unit test [.py]\")\n    print(\"3. Markdown [.md]\")\n    print(\"4. JSON config [.json]\")\n    print(\"5. YAML config [.yml]\")\n\n    choice = input(\"\\nüëâ –í–≤–µ–¥–∏—Ç–µ –Ω–æ–º–µ—Ä: \").strip()\n\n    type_map = {\n        \"1\": \"py\",\n        \"2\": \"test\",\n        \"3\": \"md\",\n        \"4\": \"json\",\n        \"5\": \"yml\"\n    }\n\n    mtype = type_map.get(choice)\n    if not mtype:\n        print(\"‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π –≤—ã–±–æ—Ä.\")\n        return\n\n    generate_module(path, mtype)\n\nif __name__ == \"__main__\":\n    interactive()",
  "scripts/module_gen.py::header": "import os\nimport argparse\nfrom developer import (\n    generate_python_stub,\n    generate_py_test,\n    generate_markdown_doc,\n    generate_json_config,\n    generate_yaml_config,\n    ensure_path,\n    write_file\n)",
  "scripts/module_gen.py::def_auto_init_py": "def auto_init_py(directory):\n    parts = directory.split(\"/\")\n    for i in range(1, len(parts)+1):\n        path = os.path.join(*parts[:i])\n        init_path = os.path.join(path, \"__init__.py\")\n        if not os.path.exists(init_path):\n            with open(init_path, \"w\") as f:\n                f.write(\"# auto-generated by SACI\\n\")",
  "scripts/module_gen.py::def_register_module": "def register_module(path):\n    registry = \"modules/module_registry.py\"\n    os.makedirs(\"modules\", exist_ok=True)\n    if not os.path.exists(registry):\n        with open(registry, \"w\") as f:\n            f.write(\"# SACI Module Registry\\nregistered_modules = []\\n\")\n\n    with open(registry, \"a\") as f:\n        f.write(f'registered_modules.append(\"{path}\")\\n')\n    print(f\"üßæ –ó–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω–æ –≤ module_registry.py: {path}\")",
  "scripts/module_gen.py::def_generate_module": "def generate_module(path, mtype):\n    ext = os.path.splitext(path)[-1]\n    if mtype == \"py\":\n        generate_python_stub(path)\n    elif mtype == \"test\":\n        generate_py_test(path)\n    elif mtype == \"md\":\n        generate_markdown_doc(path, path)\n    elif mtype == \"json\":\n        generate_json_config(path)\n    elif mtype in [\"yml\", \"yaml\"]:\n        generate_yaml_config(path)\n    else:\n        print(\"‚ùå –ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π —Ç–∏–ø.\")\n        return\n\n    # ‚õì auto init + registry\n    if \"/\" in path:\n        auto_init_py(\"/\".join(path.split(\"/\")[:-1]))\n    register_module(path)\n\nif __name__ == \"__main__\":\n    parser = argparse.ArgumentParser(description=\"üß† SACI Module Generator CLI\")\n    parser.add_argument(\"--name\", required=True, help=\"–ò–º—è –º–æ–¥—É–ª—è —Å —Ä–∞—Å—à–∏—Ä–µ–Ω–∏–µ–º (–Ω–∞–ø—Ä–∏–º–µ—Ä: core/saci_memory.py)\")\n    parser.add_argument(\"--type\", required=True, choices=[\"py\", \"test\", \"md\", \"json\", \"yml\", \"yaml\"], help=\"–¢–∏–ø —Ñ–∞–π–ª–∞\")\n    args = parser.parse_args()\n\n    generate_module(args.name, args.type)",
  "modules/gen_module.py::header": "patch_agent_task.py ‚Äî –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è –∫–ª–∞—Å—Å–æ–≤ Task –∏ Agent –≤ –ø—Ä–æ–µ–∫—Ç SACI\n\nimport os from pathlib import Path\n\nCORE_FILE = Path(\"core/tasks.py\") AGENT_FILE = Path(\"agents/strategist.py\")\n\nTASK_CLASS = '''class Task: \"\"\" –ö–ª–∞—Å—Å Task –ø—Ä–µ–¥—Å—Ç–∞–≤–ª—è–µ—Ç —Å–æ–±–æ–π –∑–∞–¥–∞–Ω–∏–µ, –∫–æ—Ç–æ—Ä–æ–µ –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å –ø–µ—Ä–µ–¥–∞–Ω–æ –¥–∞–ª—å—à–µ –ø–æ —Ü–µ–ø–æ—á–∫–µ. \"\"\" def init(self, task_name, task_description): self.task_name = task_name self.task_description = task_description self.task_status = \"Not started\" self.task_start_time = None self.task_end_time = None",
  "modules/gen_module.py::def_start_task": "def start_task(self):\n    self.task_status = \"In progress\"\n        from datetime import datetime\n            self.task_start_time = datetime.now()\n\n            def end_task(self):\n                self.task_status = \"Completed\"\n                    from datetime import datetime\n                        self.task_end_time = datetime.now()\n\n                        '''\n\n                        AGENT_CLASS = '''class Agent: \"\"\" –ê–≥–µ–Ω—Ç, –∫–æ—Ç–æ—Ä—ã–π –≤—ã–ø–æ–ª–Ω—è–µ—Ç –∏ –ø–µ—Ä–µ–¥–∞—ë—Ç –∑–∞–¥–∞–Ω–∏–µ —Å–ª–µ–¥—É—é—â–µ–º—É –∞–≥–µ–Ω—Ç—É. \"\"\" def init(self, name): self.name = name\n\n                        def assign_task(self, task):\n                            task.start_task()\n                                print(f\"Task '{task.task_name}' is assigned to agent '{self.name}'.\")\n\n                                def complete_task(self, task):\n                                    task.end_task()\n                                        print(f\"Task '{task.task_name}' is completed by agent '{self.name}'.\")\n\n                                        def pass_task(self, task, next_agent):\n                                            self.complete_task(task)\n                                                next_agent.assign_task(task)\n\n                                                '''\n\n                                                def patch_file(path: Path, class_code: str, class_name: str): if not path.exists(): path.parent.mkdir(parents=True, exist_ok=True) path.write_text(f\"{class_code}\\n\", encoding=\"utf-8\") print(f\"‚úÖ –°–æ–∑–¥–∞–Ω —Ñ–∞–π–ª {path} —Å –∫–ª–∞—Å—Å–æ–º {class_name}\") else: content = path.read_text(encoding=\"utf-8\") if class_name in content: print(f\"‚ö†Ô∏è –ö–ª–∞—Å—Å {class_name} —É–∂–µ –µ—Å—Ç—å –≤ {path}, –ø—Ä–æ–ø—É—Å–∫–∞–µ–º\") else: with open(path, \"a\", encoding=\"utf-8\") as f: f.write(f\"\\n\\n{class_code}\\n\") print(f\"‚úÖ –î–æ–±–∞–≤–ª–µ–Ω –∫–ª–∞—Å—Å {class_name} –≤ {path}\")\n\n                                                def main(): patch_file(CORE_FILE, TASK_CLASS, \"Task\") patch_file(AGENT_FILE, AGENT_CLASS, \"Agent\")\n\n                                                if name == \"main\": main()",
  "vendor/tree-sitter-python/setup.py::header": "from os.path import isdir, join\nfrom platform import system\n\nfrom setuptools import Extension, find_packages, setup\nfrom setuptools.command.build import build\nfrom wheel.bdist_wheel import bdist_wheel",
  "vendor/tree-sitter-python/setup.py::class_Build": "class Build(build):\n    def run(self):\n        if isdir(\"queries\"):\n            dest = join(self.build_lib, \"tree_sitter_python\", \"queries\")\n            self.copy_tree(\"queries\", dest)\n        super().run()",
  "vendor/tree-sitter-python/setup.py::class_BdistWheel": "class BdistWheel(bdist_wheel):\n    def get_tag(self):\n        python, abi, platform = super().get_tag()\n        if python.startswith(\"cp\"):\n            python, abi = \"cp39\", \"abi3\"\n        return python, abi, platform\n\n\nsetup(\n    packages=find_packages(\"bindings/python\"),\n    package_dir={\"\": \"bindings/python\"},\n    package_data={\n        \"tree_sitter_python\": [\"*.pyi\", \"py.typed\"],\n        \"tree_sitter_python.queries\": [\"*.scm\"],\n    },\n    ext_package=\"tree_sitter_python\",\n    ext_modules=[\n        Extension(\n            name=\"_binding\",\n            sources=[\n                \"bindings/python/tree_sitter_python/binding.c\",\n                \"src/parser.c\",\n                \"src/scanner.c\",\n            ],\n            extra_compile_args=[\n                \"-std=c11\",\n                \"-fvisibility=hidden\",\n            ] if system() != \"Windows\" else [\n                \"/std:c11\",\n                \"/utf-8\",\n            ],\n            define_macros=[\n                (\"Py_LIMITED_API\", \"0x03090000\"),\n                (\"PY_SSIZE_T_CLEAN\", None),\n                (\"TREE_SITTER_HIDE_SYMBOLS\", None),\n            ],\n            include_dirs=[\"src\"],\n            py_limited_api=True,\n        )\n    ],\n    cmdclass={\n        \"build\": Build,\n        \"bdist_wheel\": BdistWheel\n    },\n    zip_safe=False\n)",
  "vendor/tree-sitter-python/test/highlight/keywords.py::header": "if foo():\n# <- keyword\n    pass\n    # <- keyword\nelif bar():\n# <- keyword\n    pass\nelse:\n# <- keyword\n    foo\n\nreturn\n# ^ keyword\nraise e\n# ^ keyword\n\nfor i in foo():\n# <- keyword\n#   ^ variable\n#     ^ operator\n#        ^ function\n    continue\n    # <- keyword\n    break\n    # <- keyword\n\na and b or c\n# ^ operator\n#     ^ variable\n#       ^ operator",
  "vendor/tree-sitter-python/test/highlight/pattern_matching.py::header": "match command.split():\n# ^ keyword\n    case [\"quit\"]:\n    # ^ keyword\n        print(\"Goodbye!\")\n        quit_game()\n    case [\"look\"]:\n    # ^ keyword\n        current_room.describe()\n    case [\"get\", obj]:\n    # ^ keyword\n        character.get(obj, current_room)\n    case [\"go\", direction]:\n    # ^ keyword\n        current_room = current_room.neighbor(direction)\n    # The rest of your commands go here\n\nmatch command.split():\n# ^ keyword\n    case [\"drop\", *objects]:\n    # ^ keyword\n        for obj in objects:\n            character.drop(obj, current_room)\n\nmatch command.split():\n# ^ keyword\n    case [\"quit\"]: ... # Code omitted for brevity\n    case [\"go\", direction]: pass\n    case [\"drop\", *objects]: pass\n    case _:\n        print(f\"Sorry, I couldn't understand {command!r}\")\n\nmatch command.split():\n# ^ keyword\n    case [\"north\"] | [\"go\", \"north\"]:\n    # ^ keyword\n        current_room = current_room.neighbor(\"north\")\n    case [\"get\", obj] | [\"pick\", \"up\", obj] | [\"pick\", obj, \"up\"]:\n    # ^ keyword\n        pass\n\nmatch = 2\n#   ^ variable\nmatch, a = 2, 3\n#   ^ variable\nmatch: int = secret\n#   ^ variable\nx, match: str = 2, \"hey, what's up?\"\n# <- variable\n#   ^ variable\n\nif match := re.fullmatch(r\"(-)?(\\d+:)?\\d?\\d:\\d\\d(\\.\\d*)?\", time, flags=re.ASCII):\n    # ^ variable\n    return match",
  "vendor/tree-sitter-python/test/highlight/parameters.py::def_g": "def g(h, i, /, j, *, k=100, **kwarg):\n    #       ^ operator\n    #             ^ operator\n    pass",
  "vendor/tree-sitter-python/test/tags/main.py::class_MyClass": "class MyClass:\n  #    ^ definition.class\n  def hello():\n    #  ^ definition.function\n    print \"hello from MyClass\"\n\nMyClass.hello()\n#        ^ reference.call",
  "vendor/tree-sitter-python/test/tags/main.py::def_main": "def main():\n  #  ^ definition.function\n  print \"Hello, world!\"\n\nmain()\n# <- reference.call",
  "vendor/tree-sitter-python/bindings/python/tests/test_binding.py::header": "from unittest import TestCase\n\nimport tree_sitter, tree_sitter_python",
  "vendor/tree-sitter-python/bindings/python/tests/test_binding.py::class_TestLanguage": "class TestLanguage(TestCase):\n    def test_can_load_grammar(self):\n        try:\n            tree_sitter.Language(tree_sitter_python.language())\n        except Exception:\n            self.fail(\"Error loading Python grammar\")",
  "vendor/tree-sitter-python/bindings/python/tree_sitter_python/__init__.py::header": "\"\"\"Python grammar for tree-sitter\"\"\"\n\nfrom importlib.resources import files as _files\n\nfrom ._binding import language",
  "vendor/tree-sitter-python/bindings/python/tree_sitter_python/__init__.py::def__get_query": "def _get_query(name, file):\n    query = _files(f\"{__package__}.queries\") / file\n    globals()[name] = query.read_text()\n    return globals()[name]",
  "vendor/tree-sitter-python/bindings/python/tree_sitter_python/__init__.py::def___getattr__": "def __getattr__(name):\n    if name == \"HIGHLIGHTS_QUERY\":\n        return _get_query(\"HIGHLIGHTS_QUERY\", \"highlights.scm\")\n    if name == \"TAGS_QUERY\":\n        return _get_query(\"TAGS_QUERY\", \"tags.scm\")\n\n    raise AttributeError(f\"module {__name__!r} has no attribute {name!r}\")\n\n\n__all__ = [\n    \"language\",\n    \"HIGHLIGHTS_QUERY\",\n    \"TAGS_QUERY\",\n]",
  "vendor/tree-sitter-python/bindings/python/tree_sitter_python/__init__.py::def___dir__": "def __dir__():\n    return sorted(__all__ + [\n        \"__all__\", \"__builtins__\", \"__cached__\", \"__doc__\", \"__file__\",\n        \"__loader__\", \"__name__\", \"__package__\", \"__path__\", \"__spec__\",\n    ])",
  "vendor/tree-sitter-python/examples/crlf-line-endings.py::header": "print a\n\nif b:    \n    if c:\n        d\n    e",
  "vendor/tree-sitter-python/examples/tabs.py::def_set_password": "def set_password(args):\n\tpassword = args.password\n\twhile not password  :\n\t\tpassword1 = getpass(\"\" if args.quiet else \"Provide password: \")\n\t\tpassword_repeat = getpass(\"\" if args.quiet else \"Repeat password:  \")\n\t\tif password1 != password_repeat:\n\t\t\tprint(\"Passwords do not match, try again\")\n\t\telif len(password1) < 4:\n\t\t\tprint(\"Please provide at least 4 characters\")\n\t\telse:\n\t\t\tpassword = password1\n\n\tpassword_hash = passwd(password)\n\tcfg = BaseJSONConfigManager(config_dir=jupyter_config_dir())\n\tcfg.update('jupyter_notebook_config', {\n\t\t'NotebookApp': {\n\t\t\t'password': password_hash,\n\t\t}\n\t})\n\tif not args.quiet:\n\t\tprint(\"password stored in config dir: %s\" % jupyter_config_dir())",
  "vendor/tree-sitter-python/examples/tabs.py::def_main": "def main(argv):\n\tparser = argparse.ArgumentParser(argv[0])\n\tsubparsers = parser.add_subparsers()\n\tparser_password = subparsers.add_parser('password', help='sets a password for your notebook server')\n\tparser_password.add_argument(\"password\", help=\"password to set, if not given, a password will be queried for (NOTE: this may not be safe)\",\n\t\t\tnargs=\"?\")\n\tparser_password.add_argument(\"--quiet\", help=\"suppress messages\", action=\"store_true\")\n\tparser_password.set_defaults(function=set_password)\n\targs = parser.parse_args(argv[1:])\n\targs.function(args)",
  "vendor/tree-sitter-python/examples/simple-statements-without-trailing-newline.py::header": "pass; print \"hi\"",
  "vendor/tree-sitter-python/examples/python2-grammar-crlf.py::header": "# Python test set -- part 1, grammar.\n# This just tests whether the parser accepts them all.\n\n# NOTE: When you run this test as a script from the command line, you\n# get warnings about certain hex/oct constants.  Since those are\n# issued by the parser, you can't suppress them by adding a\n# filterwarnings() call to this module.  Therefore, to shut up the\n# regression test, the filterwarnings() call has been added to\n# regrtest.py.\n\nfrom test.test_support import run_unittest, check_syntax_error\nimport unittest\nimport sys\n# testing import *\nfrom sys import *",
  "vendor/tree-sitter-python/examples/python2-grammar-crlf.py::class_TokenTests": "class TokenTests(unittest.TestCase):\n\n    def testBackslash(self):\n        # Backslash means line continuation:\n        x = 1 \\\n        + 1\n        self.assertEquals(x, 2, 'backslash for line continuation')\n\n        # Backslash does not means continuation in comments :\\\n        x = 0\n        self.assertEquals(x, 0, 'backslash ending comment')\n\n    def testPlainIntegers(self):\n        self.assertEquals(0xff, 255)\n        self.assertEquals(0377, 255)\n        self.assertEquals(2147483647, 017777777777)\n        # \"0x\" is not a valid literal\n        self.assertRaises(SyntaxError, eval, \"0x\")\n        from sys import maxint\n        if maxint == 2147483647:\n            self.assertEquals(-2147483647-1, -020000000000)\n            # XXX -2147483648\n            self.assert_(037777777777 > 0)\n            self.assert_(0xffffffff > 0)\n            for s in '2147483648', '040000000000', '0x100000000':\n                try:\n                    x = eval(s)\n                except OverflowError:\n                    self.fail(\"OverflowError on huge integer literal %r\" % s)\n        elif maxint == 9223372036854775807:\n            self.assertEquals(-9223372036854775807-1, -01000000000000000000000)\n            self.assert_(01777777777777777777777 > 0)\n            self.assert_(0xffffffffffffffff > 0)\n            for s in '9223372036854775808', '02000000000000000000000','0x10000000000000000':\n                try:\n                    x = eval(s)\n                except OverflowError:\n                    self.fail(\"OverflowError on huge integer literal %r\" % s)\n        else:\n            self.fail('Weird maxint value %r' % maxint)\n\n    def testLongIntegers(self):\n        x = 0L\n        x = 0l\n        x = 0xffffffffffffffffL\n        x = 0xffffffffffffffffl\n        x = 077777777777777777L\n        x = 077777777777777777l\n        x = 123456789012345678901234567890L\n        x = 123456789012345678901234567890l\n\n    def testFloats(self):\n        x = 3.14\n        x = 314.\n        x = 0.314\n        # XXX x = 000.314\n        x = .314\n        x = 3e14\n        x = 3E14\n        x = 3e-14\n        x = 3e+14\n        x = 3.e14\n        x = .3e14\n        x = 3.1e4",
  "vendor/tree-sitter-python/examples/python2-grammar-crlf.py::class_GrammarTests": "class GrammarTests(unittest.TestCase):\n\n    # single_input: NEWLINE | simple_stmt | compound_stmt NEWLINE\n    # XXX can't test in a script -- this rule is only used when interactive\n\n    # file_input: (NEWLINE | stmt)* ENDMARKER\n    # Being tested as this very moment this very module\n\n    # expr_input: testlist NEWLINE\n    # XXX Hard to test -- used only in calls to input()\n\n    def testEvalInput(self):\n        # testlist ENDMARKER\n        x = eval('1, 0 or 1')\n\n    def testFuncdef(self):\n        ### 'def' NAME parameters ':' suite\n        ### parameters: '(' [varargslist] ')'\n        ### varargslist: (fpdef ['=' test] ',')* ('*' NAME [',' ('**'|'*' '*') NAME]\n        ###            | ('**'|'*' '*') NAME)\n        ###            | fpdef ['=' test] (',' fpdef ['=' test])* [',']\n        ### fpdef: NAME | '(' fplist ')'\n        ### fplist: fpdef (',' fpdef)* [',']\n        ### arglist: (argument ',')* (argument | *' test [',' '**' test] | '**' test)\n        ### argument: [test '='] test   # Really [keyword '='] test\n        def f1(): pass\n        f1()\n        f1(*())\n        f1(*(), **{})\n        def f2(one_argument): pass\n        def f3(two, arguments): pass\n        def f4(two, (compound, (argument, list))): pass\n        def f5((compound, first), two): pass\n        self.assertEquals(f2.func_code.co_varnames, ('one_argument',))\n        self.assertEquals(f3.func_code.co_varnames, ('two', 'arguments'))\n        if sys.platform.startswith('java'):\n            self.assertEquals(f4.func_code.co_varnames,\n                   ('two', '(compound, (argument, list))', 'compound', 'argument',\n                                'list',))\n            self.assertEquals(f5.func_code.co_varnames,\n                   ('(compound, first)', 'two', 'compound', 'first'))\n        else:\n            self.assertEquals(f4.func_code.co_varnames,\n                  ('two', '.1', 'compound', 'argument',  'list'))\n            self.assertEquals(f5.func_code.co_varnames,\n                  ('.0', 'two', 'compound', 'first'))\n        def a1(one_arg,): pass\n        def a2(two, args,): pass\n        def v0(*rest): pass\n        def v1(a, *rest): pass\n        def v2(a, b, *rest): pass\n        def v3(a, (b, c), *rest): return a, b, c, rest\n\n        f1()\n        f2(1)\n        f2(1,)\n        f3(1, 2)\n        f3(1, 2,)\n        f4(1, (2, (3, 4)))\n        v0()\n        v0(1)\n        v0(1,)\n        v0(1,2)\n        v0(1,2,3,4,5,6,7,8,9,0)\n        v1(1)\n        v1(1,)\n        v1(1,2)\n        v1(1,2,3)\n        v1(1,2,3,4,5,6,7,8,9,0)\n        v2(1,2)\n        v2(1,2,3)\n        v2(1,2,3,4)\n        v2(1,2,3,4,5,6,7,8,9,0)\n        v3(1,(2,3))\n        v3(1,(2,3),4)\n        v3(1,(2,3),4,5,6,7,8,9,0)\n\n        # ceval unpacks the formal arguments into the first argcount names;\n        # thus, the names nested inside tuples must appear after these names.\n        if sys.platform.startswith('java'):\n            self.assertEquals(v3.func_code.co_varnames, ('a', '(b, c)', 'rest', 'b', 'c'))\n        else:\n            self.assertEquals(v3.func_code.co_varnames, ('a', '.1', 'rest', 'b', 'c'))\n        self.assertEquals(v3(1, (2, 3), 4), (1, 2, 3, (4,)))\n        def d01(a=1): pass\n        d01()\n        d01(1)\n        d01(*(1,))\n        d01(**{'a':2})\n        def d11(a, b=1): pass\n        d11(1)\n        d11(1, 2)\n        d11(1, **{'b':2})\n        def d21(a, b, c=1): pass\n        d21(1, 2)\n        d21(1, 2, 3)\n        d21(*(1, 2, 3))\n        d21(1, *(2, 3))\n        d21(1, 2, *(3,))\n        d21(1, 2, **{'c':3})\n        def d02(a=1, b=2): pass\n        d02()\n        d02(1)\n        d02(1, 2)\n        d02(*(1, 2))\n        d02(1, *(2,))\n        d02(1, **{'b':2})\n        d02(**{'a': 1, 'b': 2})\n        def d12(a, b=1, c=2): pass\n        d12(1)\n        d12(1, 2)\n        d12(1, 2, 3)\n        def d22(a, b, c=1, d=2): pass\n        d22(1, 2)\n        d22(1, 2, 3)\n        d22(1, 2, 3, 4)\n        def d01v(a=1, *rest): pass\n        d01v()\n        d01v(1)\n        d01v(1, 2)\n        d01v(*(1, 2, 3, 4))\n        d01v(*(1,))\n        d01v(**{'a':2})\n        def d11v(a, b=1, *rest): pass\n        d11v(1)\n        d11v(1, 2)\n        d11v(1, 2, 3)\n        def d21v(a, b, c=1, *rest): pass\n        d21v(1, 2)\n        d21v(1, 2, 3)\n        d21v(1, 2, 3, 4)\n        d21v(*(1, 2, 3, 4))\n        d21v(1, 2, **{'c': 3})\n        def d02v(a=1, b=2, *rest): pass\n        d02v()\n        d02v(1)\n        d02v(1, 2)\n        d02v(1, 2, 3)\n        d02v(1, *(2, 3, 4))\n        d02v(**{'a': 1, 'b': 2})\n        def d12v(a, b=1, c=2, *rest): pass\n        d12v(1)\n        d12v(1, 2)\n        d12v(1, 2, 3)\n        d12v(1, 2, 3, 4)\n        d12v(*(1, 2, 3, 4))\n        d12v(1, 2, *(3, 4, 5))\n        d12v(1, *(2,), **{'c': 3})\n        def d22v(a, b, c=1, d=2, *rest): pass\n        d22v(1, 2)\n        d22v(1, 2, 3)\n        d22v(1, 2, 3, 4)\n        d22v(1, 2, 3, 4, 5)\n        d22v(*(1, 2, 3, 4))\n        d22v(1, 2, *(3, 4, 5))\n        d22v(1, *(2, 3), **{'d': 4})\n        def d31v((x)): pass\n        d31v(1)\n        def d32v((x,)): pass\n        d32v((1,))\n\n        # keyword arguments after *arglist\n        def f(*args, **kwargs):\n            return args, kwargs\n        self.assertEquals(f(1, x=2, *[3, 4], y=5), ((1, 3, 4),\n                                                    {'x':2, 'y':5}))\n        self.assertRaises(SyntaxError, eval, \"f(1, *(2,3), 4)\")\n        self.assertRaises(SyntaxError, eval, \"f(1, x=2, *(3,4), x=5)\")\n\n        # Check ast errors in *args and *kwargs\n        check_syntax_error(self, \"f(*g(1=2))\")\n        check_syntax_error(self, \"f(**g(1=2))\")\n\n    def testLambdef(self):\n        ### lambdef: 'lambda' [varargslist] ':' test\n        l1 = lambda : 0\n        self.assertEquals(l1(), 0)\n        l2 = lambda : a[d] # XXX just testing the expression\n        l3 = lambda : [2 < x for x in [-1, 3, 0L]]\n        self.assertEquals(l3(), [0, 1, 0])\n        l4 = lambda x = lambda y = lambda z=1 : z : y() : x()\n        self.assertEquals(l4(), 1)\n        l5 = lambda x, y, z=2: x + y + z\n        self.assertEquals(l5(1, 2), 5)\n        self.assertEquals(l5(1, 2, 3), 6)\n        check_syntax_error(self, \"lambda x: x = 2\")\n        check_syntax_error(self, \"lambda (None,): None\")\n\n    ### stmt: simple_stmt | compound_stmt\n    # Tested below\n\n    def testSimpleStmt(self):\n        ### simple_stmt: small_stmt (';' small_stmt)* [';']\n        x = 1; pass; del x\n        def foo():\n            # verify statements that end with semi-colons\n            x = 1; pass; del x;\n        foo()\n\n    ### small_stmt: expr_stmt | print_stmt  | pass_stmt | del_stmt | flow_stmt | import_stmt | global_stmt | access_stmt | exec_stmt\n    # Tested below\n\n    def testExprStmt(self):\n        # (exprlist '=')* exprlist\n        1\n        1, 2, 3\n        x = 1\n        x = 1, 2, 3\n        x = y = z = 1, 2, 3\n        x, y, z = 1, 2, 3\n        abc = a, b, c = x, y, z = xyz = 1, 2, (3, 4)\n\n        check_syntax_error(self, \"x + 1 = 1\")\n        check_syntax_error(self, \"a + 1 = b + 2\")\n\n    def testPrintStmt(self):\n        # 'print' (test ',')* [test]\n        import StringIO\n\n        # Can't test printing to real stdout without comparing output\n        # which is not available in unittest.\n        save_stdout = sys.stdout\n        sys.stdout = StringIO.StringIO()\n\n        print 1, 2, 3\n        print 1, 2, 3,\n        print\n        print 0 or 1, 0 or 1,\n        print 0 or 1\n\n        # 'print' '>>' test ','\n        print >> sys.stdout, 1, 2, 3\n        print >> sys.stdout, 1, 2, 3,\n        print >> sys.stdout\n        print >> sys.stdout, 0 or 1, 0 or 1,\n        print >> sys.stdout, 0 or 1\n\n        # test printing to an instance\n        class Gulp:\n            def write(self, msg): pass\n\n        gulp = Gulp()\n        print >> gulp, 1, 2, 3\n        print >> gulp, 1, 2, 3,\n        print >> gulp\n        print >> gulp, 0 or 1, 0 or 1,\n        print >> gulp, 0 or 1\n\n        # test print >> None\n        def driver():\n            oldstdout = sys.stdout\n            sys.stdout = Gulp()\n            try:\n                tellme(Gulp())\n                tellme()\n            finally:\n                sys.stdout = oldstdout\n\n        # we should see this once\n        def tellme(file=sys.stdout):\n            print >> file, 'hello world'\n\n        driver()\n\n        # we should not see this at all\n        def tellme(file=None):\n            print >> file, 'goodbye universe'\n\n        driver()\n\n        self.assertEqual(sys.stdout.getvalue(), '''\\\n1 2 3\n1 2 3\n1 1 1\n1 2 3\n1 2 3\n1 1 1\nhello world\n''')\n        sys.stdout = save_stdout\n\n        # syntax errors\n        check_syntax_error(self, 'print ,')\n        check_syntax_error(self, 'print >> x,')\n\n    def testDelStmt(self):\n        # 'del' exprlist\n        abc = [1,2,3]\n        x, y, z = abc\n        xyz = x, y, z\n\n        del abc\n        del x, y, (z, xyz)\n\n    def testPassStmt(self):\n        # 'pass'\n        pass\n\n    # flow_stmt: break_stmt | continue_stmt | return_stmt | raise_stmt\n    # Tested below\n\n    def testBreakStmt(self):\n        # 'break'\n        while 1: break\n\n    def testContinueStmt(self):\n        # 'continue'\n        i = 1\n        while i: i = 0; continue\n\n        msg = \"\"\n        while not msg:\n            msg = \"ok\"\n            try:\n                continue\n                msg = \"continue failed to continue inside try\"\n            except:\n                msg = \"continue inside try called except block\"\n        if msg != \"ok\":\n            self.fail(msg)\n\n        msg = \"\"\n        while not msg:\n            msg = \"finally block not called\"\n            try:\n                continue\n            finally:\n                msg = \"ok\"\n        if msg != \"ok\":\n            self.fail(msg)\n\n    def test_break_continue_loop(self):\n        # This test warrants an explanation. It is a test specifically for SF bugs\n        # #463359 and #462937. The bug is that a 'break' statement executed or\n        # exception raised inside a try/except inside a loop, *after* a continue\n        # statement has been executed in that loop, will cause the wrong number of\n        # arguments to be popped off the stack and the instruction pointer reset to\n        # a very small number (usually 0.) Because of this, the following test\n        # *must* written as a function, and the tracking vars *must* be function\n        # arguments with default values. Otherwise, the test will loop and loop.\n\n        def test_inner(extra_burning_oil = 1, count=0):\n            big_hippo = 2\n            while big_hippo:\n                count += 1\n                try:\n                    if extra_burning_oil and big_hippo == 1:\n                        extra_burning_oil -= 1\n                        break\n                    big_hippo -= 1\n                    continue\n                except:\n                    raise\n            if count > 2 or big_hippo <> 1:\n                self.fail(\"continue then break in try/except in loop broken!\")\n        test_inner()\n\n    def testReturn(self):\n        # 'return' [testlist]\n        def g1(): return\n        def g2(): return 1\n        g1()\n        x = g2()\n        check_syntax_error(self, \"class foo:return 1\")\n\n    def testYield(self):\n        check_syntax_error(self, \"class foo:yield 1\")\n\n    def testRaise(self):\n        # 'raise' test [',' test]\n        try: raise RuntimeError, 'just testing'\n        except RuntimeError: pass\n        try: raise KeyboardInterrupt\n        except KeyboardInterrupt: pass\n\n    def testImport(self):\n        # 'import' dotted_as_names\n        import sys\n        import time, sys\n        # 'from' dotted_name 'import' ('*' | '(' import_as_names ')' | import_as_names)\n        from time import time\n        from time import (time)\n        # not testable inside a function, but already done at top of the module\n        # from sys import *\n        from sys import path, argv\n        from sys import (path, argv)\n        from sys import (path, argv,)\n\n    def testGlobal(self):\n        # 'global' NAME (',' NAME)*\n        global a\n        global a, b\n        global one, two, three, four, five, six, seven, eight, nine, ten\n\n    def testExec(self):\n        # 'exec' expr ['in' expr [',' expr]]\n        z = None\n        del z\n        exec 'z=1+1\\n'\n        if z != 2: self.fail('exec \\'z=1+1\\'\\\\n')\n        del z\n        exec 'z=1+1'\n        if z != 2: self.fail('exec \\'z=1+1\\'')\n        z = None\n        del z\n        import types\n        if hasattr(types, \"UnicodeType\"):\n            exec r\"\"\"if 1:\n            exec u'z=1+1\\n'\n            if z != 2: self.fail('exec u\\'z=1+1\\'\\\\n')\n            del z\n            exec u'z=1+1'\n            if z != 2: self.fail('exec u\\'z=1+1\\'')\"\"\"\n        g = {}\n        exec 'z = 1' in g\n        if g.has_key('__builtins__'): del g['__builtins__']\n        if g != {'z': 1}: self.fail('exec \\'z = 1\\' in g')\n        g = {}\n        l = {}\n\n        import warnings\n        warnings.filterwarnings(\"ignore\", \"global statement\", module=\"<string>\")\n        exec 'global a; a = 1; b = 2' in g, l\n        if g.has_key('__builtins__'): del g['__builtins__']\n        if l.has_key('__builtins__'): del l['__builtins__']\n        if (g, l) != ({'a':1}, {'b':2}):\n            self.fail('exec ... in g (%s), l (%s)' %(g,l))\n\n    def testAssert(self):\n        # assert_stmt: 'assert' test [',' test]\n        assert 1\n        assert 1, 1\n        assert lambda x:x\n        assert 1, lambda x:x+1\n        try:\n            assert 0, \"msg\"\n        except AssertionError, e:\n            self.assertEquals(e.args[0], \"msg\")\n        else:\n            if __debug__:\n                self.fail(\"AssertionError not raised by assert 0\")\n\n    ### compound_stmt: if_stmt | while_stmt | for_stmt | try_stmt | funcdef | classdef\n    # Tested below\n\n    def testIf(self):\n        # 'if' test ':' suite ('elif' test ':' suite)* ['else' ':' suite]\n        if 1: pass\n        if 1: pass\n        else: pass\n        if 0: pass\n        elif 0: pass\n        if 0: pass\n        elif 0: pass\n        elif 0: pass\n        elif 0: pass\n        else: pass\n\n    def testWhile(self):\n        # 'while' test ':' suite ['else' ':' suite]\n        while 0: pass\n        while 0: pass\n        else: pass\n\n        # Issue1920: \"while 0\" is optimized away,\n        # ensure that the \"else\" clause is still present.\n        x = 0\n        while 0:\n            x = 1\n        else:\n            x = 2\n        self.assertEquals(x, 2)\n\n    def testFor(self):\n        # 'for' exprlist 'in' exprlist ':' suite ['else' ':' suite]\n        for i in 1, 2, 3: pass\n        for i, j, k in (): pass\n        else: pass\n        class Squares:\n            def __init__(self, max):\n                self.max = max\n                self.sofar = []\n            def __len__(self): return len(self.sofar)\n            def __getitem__(self, i):\n                if not 0 <= i < self.max: raise IndexError\n                n = len(self.sofar)\n                while n <= i:\n                    self.sofar.append(n*n)\n                    n = n+1\n                return self.sofar[i]\n        n = 0\n        for x in Squares(10): n = n+x\n        if n != 285:\n            self.fail('for over growing sequence')\n\n        result = []\n        for x, in [(1,), (2,), (3,)]:\n            result.append(x)\n        self.assertEqual(result, [1, 2, 3])\n\n    def testTry(self):\n        ### try_stmt: 'try' ':' suite (except_clause ':' suite)+ ['else' ':' suite]\n        ###         | 'try' ':' suite 'finally' ':' suite\n        ### except_clause: 'except' [expr [('as' | ',') expr]]\n        try:\n            1/0\n        except ZeroDivisionError:\n            pass\n        else:\n            pass\n        try: 1/0\n        except EOFError: pass\n        except TypeError as msg: pass\n        except RuntimeError, msg: pass\n        except: pass\n        else: pass\n        try: 1/0\n        except (EOFError, TypeError, ZeroDivisionError): pass\n        try: 1/0\n        except (EOFError, TypeError, ZeroDivisionError), msg: pass\n        try: pass\n        finally: pass\n\n    def testSuite(self):\n        # simple_stmt | NEWLINE INDENT NEWLINE* (stmt NEWLINE*)+ DEDENT\n        if 1: pass\n        if 1:\n            pass\n        if 1:\n            #\n            #\n            #\n            pass\n            pass\n            #\n            pass\n            #\n\n    def testTest(self):\n        ### and_test ('or' and_test)*\n        ### and_test: not_test ('and' not_test)*\n        ### not_test: 'not' not_test | comparison\n        if not 1: pass\n        if 1 and 1: pass\n        if 1 or 1: pass\n        if not not not 1: pass\n        if not 1 and 1 and 1: pass\n        if 1 and 1 or 1 and 1 and 1 or not 1 and 1: pass\n\n    def testComparison(self):\n        ### comparison: expr (comp_op expr)*\n        ### comp_op: '<'|'>'|'=='|'>='|'<='|'<>'|'!='|'in'|'not' 'in'|'is'|'is' 'not'\n        if 1: pass\n        x = (1 == 1)\n        if 1 == 1: pass\n        if 1 != 1: pass\n        if 1 <> 1: pass\n        if 1 < 1: pass\n        if 1 > 1: pass\n        if 1 <= 1: pass\n        if 1 >= 1: pass\n        if 1 is 1: pass\n        if 1 is not 1: pass\n        if 1 in (): pass\n        if 1 not in (): pass\n        if 1 < 1 > 1 == 1 >= 1 <= 1 <> 1 != 1 in 1 not in 1 is 1 is not 1: pass\n\n    def testBinaryMaskOps(self):\n        x = 1 & 1\n        x = 1 ^ 1\n        x = 1 | 1\n\n    def testShiftOps(self):\n        x = 1 << 1\n        x = 1 >> 1\n        x = 1 << 1 >> 1\n\n    def testAdditiveOps(self):\n        x = 1\n        x = 1 + 1\n        x = 1 - 1 - 1\n        x = 1 - 1 + 1 - 1 + 1\n\n    def testMultiplicativeOps(self):\n        x = 1 * 1\n        x = 1 / 1\n        x = 1 % 1\n        x = 1 / 1 * 1 % 1\n\n    def testUnaryOps(self):\n        x = +1\n        x = -1\n        x = ~1\n        x = ~1 ^ 1 & 1 | 1 & 1 ^ -1\n        x = -1*1/1 + 1*1 - ---1*1\n\n    def testSelectors(self):\n        ### trailer: '(' [testlist] ')' | '[' subscript ']' | '.' NAME\n        ### subscript: expr | [expr] ':' [expr]\n\n        import sys, time\n        c = sys.path[0]\n        x = time.time()\n        x = sys.modules['time'].time()\n        a = '01234'\n        c = a[0]\n        c = a[-1]\n        s = a[0:5]\n        s = a[:5]\n        s = a[0:]\n        s = a[:]\n        s = a[-5:]\n        s = a[:-1]\n        s = a[-4:-3]\n        # A rough test of SF bug 1333982.  http://python.org/sf/1333982\n        # The testing here is fairly incomplete.\n        # Test cases should include: commas with 1 and 2 colons\n        d = {}\n        d[1] = 1\n        d[1,] = 2\n        d[1,2] = 3\n        d[1,2,3] = 4\n        L = list(d)\n        L.sort()\n        self.assertEquals(str(L), '[1, (1,), (1, 2), (1, 2, 3)]')\n\n    def testAtoms(self):\n        ### atom: '(' [testlist] ')' | '[' [testlist] ']' | '{' [dictmaker] '}' | '`' testlist '`' | NAME | NUMBER | STRING\n        ### dictmaker: test ':' test (',' test ':' test)* [',']\n\n        x = (1)\n        x = (1 or 2 or 3)\n        x = (1 or 2 or 3, 2, 3)\n\n        x = []\n        x = [1]\n        x = [1 or 2 or 3]\n        x = [1 or 2 or 3, 2, 3]\n        x = []\n\n        x = {}\n        x = {'one': 1}\n        x = {'one': 1,}\n        x = {'one' or 'two': 1 or 2}\n        x = {'one': 1, 'two': 2}\n        x = {'one': 1, 'two': 2,}\n        x = {'one': 1, 'two': 2, 'three': 3, 'four': 4, 'five': 5, 'six': 6}\n\n        x = `x`\n        x = `1 or 2 or 3`\n        self.assertEqual(`1,2`, '(1, 2)')\n\n        x = x\n        x = 'x'\n        x = 123\n\n    ### exprlist: expr (',' expr)* [',']\n    ### testlist: test (',' test)* [',']\n    # These have been exercised enough above\n\n    def testClassdef(self):\n        # 'class' NAME ['(' [testlist] ')'] ':' suite\n        class B: pass\n        class B2(): pass\n        class C1(B): pass\n        class C2(B): pass\n        class D(C1, C2, B): pass\n        class C:\n            def meth1(self): pass\n            def meth2(self, arg): pass\n            def meth3(self, a1, a2): pass\n        # decorator: '@' dotted_name [ '(' [arglist] ')' ] NEWLINE\n        # decorators: decorator+\n        # decorated: decorators (classdef | funcdef)\n        def class_decorator(x):\n            x.decorated = True\n            return x\n        @class_decorator\n        class G:\n            pass\n        self.assertEqual(G.decorated, True)\n\n    def testListcomps(self):\n        # list comprehension tests\n        nums = [1, 2, 3, 4, 5]\n        strs = [\"Apple\", \"Banana\", \"Coconut\"]\n        spcs = [\"  Apple\", \" Banana \", \"Coco  nut  \"]\n\n        self.assertEqual([s.strip() for s in spcs], ['Apple', 'Banana', 'Coco  nut'])\n        self.assertEqual([3 * x for x in nums], [3, 6, 9, 12, 15])\n        self.assertEqual([x for x in nums if x > 2], [3, 4, 5])\n        self.assertEqual([(i, s) for i in nums for s in strs],\n                         [(1, 'Apple'), (1, 'Banana'), (1, 'Coconut'),\n                          (2, 'Apple'), (2, 'Banana'), (2, 'Coconut'),\n                          (3, 'Apple'), (3, 'Banana'), (3, 'Coconut'),\n                          (4, 'Apple'), (4, 'Banana'), (4, 'Coconut'),\n                          (5, 'Apple'), (5, 'Banana'), (5, 'Coconut')])\n        self.assertEqual([(i, s) for i in nums for s in [f for f in strs if \"n\" in f]],\n                         [(1, 'Banana'), (1, 'Coconut'), (2, 'Banana'), (2, 'Coconut'),\n                          (3, 'Banana'), (3, 'Coconut'), (4, 'Banana'), (4, 'Coconut'),\n                          (5, 'Banana'), (5, 'Coconut')])\n        self.assertEqual([(lambda a:[a**i for i in range(a+1)])(j) for j in range(5)],\n                         [[1], [1, 1], [1, 2, 4], [1, 3, 9, 27], [1, 4, 16, 64, 256]])\n\n        def test_in_func(l):\n            return [None < x < 3 for x in l if x > 2]\n\n        self.assertEqual(test_in_func(nums), [False, False, False])\n\n        def test_nested_front():\n            self.assertEqual([[y for y in [x, x + 1]] for x in [1,3,5]],\n                             [[1, 2], [3, 4], [5, 6]])\n\n        test_nested_front()\n\n        check_syntax_error(self, \"[i, s for i in nums for s in strs]\")\n        check_syntax_error(self, \"[x if y]\")\n\n        suppliers = [\n          (1, \"Boeing\"),\n          (2, \"Ford\"),\n          (3, \"Macdonalds\")\n        ]\n\n        parts = [\n          (10, \"Airliner\"),\n          (20, \"Engine\"),\n          (30, \"Cheeseburger\")\n        ]\n\n        suppart = [\n          (1, 10), (1, 20), (2, 20), (3, 30)\n        ]\n\n        x = [\n          (sname, pname)\n            for (sno, sname) in suppliers\n              for (pno, pname) in parts\n                for (sp_sno, sp_pno) in suppart\n                  if sno == sp_sno and pno == sp_pno\n        ]\n\n        self.assertEqual(x, [('Boeing', 'Airliner'), ('Boeing', 'Engine'), ('Ford', 'Engine'),\n                             ('Macdonalds', 'Cheeseburger')])\n\n    def testGenexps(self):\n        # generator expression tests\n        g = ([x for x in range(10)] for x in range(1))\n        self.assertEqual(g.next(), [x for x in range(10)])\n        try:\n            g.next()\n            self.fail('should produce StopIteration exception')\n        except StopIteration:\n            pass\n\n        a = 1\n        try:\n            g = (a for d in a)\n            g.next()\n            self.fail('should produce TypeError')\n        except TypeError:\n            pass\n\n        self.assertEqual(list((x, y) for x in 'abcd' for y in 'abcd'), [(x, y) for x in 'abcd' for y in 'abcd'])\n        self.assertEqual(list((x, y) for x in 'ab' for y in 'xy'), [(x, y) for x in 'ab' for y in 'xy'])\n\n        a = [x for x in range(10)]\n        b = (x for x in (y for y in a))\n        self.assertEqual(sum(b), sum([x for x in range(10)]))\n\n        self.assertEqual(sum(x**2 for x in range(10)), sum([x**2 for x in range(10)]))\n        self.assertEqual(sum(x*x for x in range(10) if x%2), sum([x*x for x in range(10) if x%2]))\n        self.assertEqual(sum(x for x in (y for y in range(10))), sum([x for x in range(10)]))\n        self.assertEqual(sum(x for x in (y for y in (z for z in range(10)))), sum([x for x in range(10)]))\n        self.assertEqual(sum(x for x in [y for y in (z for z in range(10))]), sum([x for x in range(10)]))\n        self.assertEqual(sum(x for x in (y for y in (z for z in range(10) if True)) if True), sum([x for x in range(10)]))\n        self.assertEqual(sum(x for x in (y for y in (z for z in range(10) if True) if False) if True), 0)\n        check_syntax_error(self, \"foo(x for x in range(10), 100)\")\n        check_syntax_error(self, \"foo(100, x for x in range(10))\")\n\n    def testComprehensionSpecials(self):\n        # test for outmost iterable precomputation\n        x = 10; g = (i for i in range(x)); x = 5\n        self.assertEqual(len(list(g)), 10)\n\n        # This should hold, since we're only precomputing outmost iterable.\n        x = 10; t = False; g = ((i,j) for i in range(x) if t for j in range(x))\n        x = 5; t = True;\n        self.assertEqual([(i,j) for i in range(10) for j in range(5)], list(g))\n\n        # Grammar allows multiple adjacent 'if's in listcomps and genexps,\n        # even though it's silly. Make sure it works (ifelse broke this.)\n        self.assertEqual([ x for x in range(10) if x % 2 if x % 3 ], [1, 5, 7])\n        self.assertEqual(list(x for x in range(10) if x % 2 if x % 3), [1, 5, 7])\n\n        # verify unpacking single element tuples in listcomp/genexp.\n        self.assertEqual([x for x, in [(4,), (5,), (6,)]], [4, 5, 6])\n        self.assertEqual(list(x for x, in [(7,), (8,), (9,)]), [7, 8, 9])\n\n    def test_with_statement(self):\n        class manager(object):\n            def __enter__(self):\n                return (1, 2)\n            def __exit__(self, *args):\n                pass\n\n        with manager():\n            pass\n        with manager() as x:\n            pass\n        with manager() as (x, y):\n            pass\n        with manager(), manager():\n            pass\n        with manager() as x, manager() as y:\n            pass\n        with manager() as x, manager():\n            pass\n\n    def testIfElseExpr(self):\n        # Test ifelse expressions in various cases\n        def _checkeval(msg, ret):\n            \"helper to check that evaluation of expressions is done correctly\"\n            print x\n            return ret\n\n        self.assertEqual([ x() for x in lambda: True, lambda: False if x() ], [True])\n        self.assertEqual([ x() for x in (lambda: True, lambda: False) if x() ], [True])\n        self.assertEqual([ x(False) for x in (lambda x: False if x else True, lambda x: True if x else False) if x(False) ], [True])\n        self.assertEqual((5 if 1 else _checkeval(\"check 1\", 0)), 5)\n        self.assertEqual((_checkeval(\"check 2\", 0) if 0 else 5), 5)\n        self.assertEqual((5 and 6 if 0 else 1), 1)\n        self.assertEqual(((5 and 6) if 0 else 1), 1)\n        self.assertEqual((5 and (6 if 1 else 1)), 6)\n        self.assertEqual((0 or _checkeval(\"check 3\", 2) if 0 else 3), 3)\n        self.assertEqual((1 or _checkeval(\"check 4\", 2) if 1 else _checkeval(\"check 5\", 3)), 1)\n        self.assertEqual((0 or 5 if 1 else _checkeval(\"check 6\", 3)), 5)\n        self.assertEqual((not 5 if 1 else 1), False)\n        self.assertEqual((not 5 if 0 else 1), 1)\n        self.assertEqual((6 + 1 if 1 else 2), 7)\n        self.assertEqual((6 - 1 if 1 else 2), 5)\n        self.assertEqual((6 * 2 if 1 else 4), 12)\n        self.assertEqual((6 / 2 if 1 else 3), 3)\n        self.assertEqual((6 < 4 if 0 else 2), 2)\n\n    def testStringLiterals(self):\n        x = ''; y = \"\"; self.assert_(len(x) == 0 and x == y)\n        x = '\\''; y = \"'\"; self.assert_(len(x) == 1 and x == y and ord(x) == 39)\n        x = '\"'; y = \"\\\"\"; self.assert_(len(x) == 1 and x == y and ord(x) == 34)\n        x = \"doesn't \\\"shrink\\\" does it\"\n        y = 'doesn\\'t \"shrink\" does it'\n        self.assert_(len(x) == 24 and x == y)\n        x = \"does \\\"shrink\\\" doesn't it\"\n        y = 'does \"shrink\" doesn\\'t it'\n        self.assert_(len(x) == 24 and x == y)\n        x = \"\"\"\nThe \"quick\"\nbrown fox\njumps over\nthe 'lazy' dog.\n\"\"\"\n        y = '\\nThe \"quick\"\\nbrown fox\\njumps over\\nthe \\'lazy\\' dog.\\n'\n        self.assertEquals(x, y)\n        y = '''\nThe \"quick\"\nbrown fox\njumps over\nthe 'lazy' dog.\n'''\n        self.assertEquals(x, y)\n        y = \"\\n\\\nThe \\\"quick\\\"\\n\\\nbrown fox\\n\\\njumps over\\n\\\nthe 'lazy' dog.\\n\\\n\"\n        self.assertEquals(x, y)\n        y = '\\n\\\nThe \\\"quick\\\"\\n\\\nbrown fox\\n\\\njumps over\\n\\\nthe \\'lazy\\' dog.\\n\\\n'\n        self.assertEquals(x, y)",
  "vendor/tree-sitter-python/examples/python2-grammar-crlf.py::def_test_main": "def test_main():\n    run_unittest(TokenTests, GrammarTests)\n\nif __name__ == '__main__':\n    test_main()",
  "vendor/tree-sitter-python/examples/python3-grammar-crlf.py::header": "# Python test set -- part 1, grammar.\n# This just tests whether the parser accepts them all.\n\n# NOTE: When you run this test as a script from the command line, you\n# get warnings about certain hex/oct constants.  Since those are\n# issued by the parser, you can't suppress them by adding a\n# filterwarnings() call to this module.  Therefore, to shut up the\n# regression test, the filterwarnings() call has been added to\n# regrtest.py.\n\nfrom test.support import run_unittest, check_syntax_error\nimport unittest\nimport sys\n# testing import *\nfrom sys import *",
  "vendor/tree-sitter-python/examples/python3-grammar-crlf.py::class_TokenTests": "class TokenTests(unittest.TestCase):\n\n    def testBackslash(self):\n        # Backslash means line continuation:\n        x = 1 \\\n        + 1\n        self.assertEquals(x, 2, 'backslash for line continuation')\n\n        # Backslash does not means continuation in comments :\\\n        x = 0\n        self.assertEquals(x, 0, 'backslash ending comment')\n\n    def testPlainIntegers(self):\n        self.assertEquals(type(000), type(0))\n        self.assertEquals(0xff, 255)\n        self.assertEquals(0o377, 255)\n        self.assertEquals(2147483647, 0o17777777777)\n        self.assertEquals(0b1001, 9)\n        # \"0x\" is not a valid literal\n        self.assertRaises(SyntaxError, eval, \"0x\")\n        from sys import maxsize\n        if maxsize == 2147483647:\n            self.assertEquals(-2147483647-1, -0o20000000000)\n            # XXX -2147483648\n            self.assert_(0o37777777777 > 0)\n            self.assert_(0xffffffff > 0)\n            self.assert_(0b1111111111111111111111111111111 > 0)\n            for s in ('2147483648', '0o40000000000', '0x100000000',\n                      '0b10000000000000000000000000000000'):\n                try:\n                    x = eval(s)\n                except OverflowError:\n                    self.fail(\"OverflowError on huge integer literal %r\" % s)\n        elif maxsize == 9223372036854775807:\n            self.assertEquals(-9223372036854775807-1, -0o1000000000000000000000)\n            self.assert_(0o1777777777777777777777 > 0)\n            self.assert_(0xffffffffffffffff > 0)\n            self.assert_(0b11111111111111111111111111111111111111111111111111111111111111 > 0)\n            for s in '9223372036854775808', '0o2000000000000000000000', \\\n                     '0x10000000000000000', \\\n                     '0b100000000000000000000000000000000000000000000000000000000000000':\n                try:\n                    x = eval(s)\n                except OverflowError:\n                    self.fail(\"OverflowError on huge integer literal %r\" % s)\n        else:\n            self.fail('Weird maxsize value %r' % maxsize)\n\n    def testLongIntegers(self):\n        x = 0\n        x = 0xffffffffffffffff\n        x = 0Xffffffffffffffff\n        x = 0o77777777777777777\n        x = 0O77777777777777777\n        x = 123456789012345678901234567890\n        x = 0b100000000000000000000000000000000000000000000000000000000000000000000\n        x = 0B111111111111111111111111111111111111111111111111111111111111111111111\n\n    def testUnderscoresInNumbers(self):\n        # Integers\n        x = 1_0\n        x = 123_456_7_89\n        x = 0xabc_123_4_5\n        x = 0X_abc_123\n        x = 0B11_01\n        x = 0b_11_01\n        x = 0o45_67\n        x = 0O_45_67\n\n        # Floats\n        x = 3_1.4\n        x = 03_1.4\n        x = 3_1.\n        x = .3_1\n        x = 3.1_4\n        x = 0_3.1_4\n        x = 3e1_4\n        x = 3_1e+4_1\n        x = 3_1E-4_1\n\n    def testFloats(self):\n        x = 3.14\n        x = 314.\n        x = 0.314\n        # XXX x = 000.314\n        x = .314\n        x = 3e14\n        x = 3E14\n        x = 3e-14\n        x = 3e+14\n        x = 3.e14\n        x = .3e14\n        x = 3.1e4\n\n    def testEllipsis(self):\n        x = ...\n        self.assert_(x is Ellipsis)\n        self.assertRaises(SyntaxError, eval, \".. .\")",
  "vendor/tree-sitter-python/examples/python3-grammar-crlf.py::class_GrammarTests": "class GrammarTests(unittest.TestCase):\n\n    # single_input: NEWLINE | simple_stmt | compound_stmt NEWLINE\n    # XXX can't test in a script -- this rule is only used when interactive\n\n    # file_input: (NEWLINE | stmt)* ENDMARKER\n    # Being tested as this very moment this very module\n\n    # expr_input: testlist NEWLINE\n    # XXX Hard to test -- used only in calls to input()\n\n    def testEvalInput(self):\n        # testlist ENDMARKER\n        x = eval('1, 0 or 1')\n\n    def testFuncdef(self):\n        ### [decorators] 'def' NAME parameters ['->' test] ':' suite\n        ### decorator: '@' dotted_name [ '(' [arglist] ')' ] NEWLINE\n        ### decorators: decorator+\n        ### parameters: '(' [typedargslist] ')'\n        ### typedargslist: ((tfpdef ['=' test] ',')*\n        ###                ('*' [tfpdef] (',' tfpdef ['=' test])* [',' '**' tfpdef] | '**' tfpdef)\n        ###                | tfpdef ['=' test] (',' tfpdef ['=' test])* [','])\n        ### tfpdef: NAME [':' test]\n        ### varargslist: ((vfpdef ['=' test] ',')*\n        ###              ('*' [vfpdef] (',' vfpdef ['=' test])*  [',' '**' vfpdef] | '**' vfpdef)\n        ###              | vfpdef ['=' test] (',' vfpdef ['=' test])* [','])\n        ### vfpdef: NAME\n        def f1(): pass\n        f1()\n        f1(*())\n        f1(*(), **{})\n        def f2(one_argument): pass\n        def f3(two, arguments): pass\n        self.assertEquals(f2.__code__.co_varnames, ('one_argument',))\n        self.assertEquals(f3.__code__.co_varnames, ('two', 'arguments'))\n        def a1(one_arg,): pass\n        def a2(two, args,): pass\n        def v0(*rest): pass\n        def v1(a, *rest): pass\n        def v2(a, b, *rest): pass\n\n        f1()\n        f2(1)\n        f2(1,)\n        f3(1, 2)\n        f3(1, 2,)\n        v0()\n        v0(1)\n        v0(1,)\n        v0(1,2)\n        v0(1,2,3,4,5,6,7,8,9,0)\n        v1(1)\n        v1(1,)\n        v1(1,2)\n        v1(1,2,3)\n        v1(1,2,3,4,5,6,7,8,9,0)\n        v2(1,2)\n        v2(1,2,3)\n        v2(1,2,3,4)\n        v2(1,2,3,4,5,6,7,8,9,0)\n\n        def d01(a=1): pass\n        d01()\n        d01(1)\n        d01(*(1,))\n        d01(**{'a':2})\n        def d11(a, b=1): pass\n        d11(1)\n        d11(1, 2)\n        d11(1, **{'b':2})\n        def d21(a, b, c=1): pass\n        d21(1, 2)\n        d21(1, 2, 3)\n        d21(*(1, 2, 3))\n        d21(1, *(2, 3))\n        d21(1, 2, *(3,))\n        d21(1, 2, **{'c':3})\n        def d02(a=1, b=2): pass\n        d02()\n        d02(1)\n        d02(1, 2)\n        d02(*(1, 2))\n        d02(1, *(2,))\n        d02(1, **{'b':2})\n        d02(**{'a': 1, 'b': 2})\n        def d12(a, b=1, c=2): pass\n        d12(1)\n        d12(1, 2)\n        d12(1, 2, 3)\n        def d22(a, b, c=1, d=2): pass\n        d22(1, 2)\n        d22(1, 2, 3)\n        d22(1, 2, 3, 4)\n        def d01v(a=1, *rest): pass\n        d01v()\n        d01v(1)\n        d01v(1, 2)\n        d01v(*(1, 2, 3, 4))\n        d01v(*(1,))\n        d01v(**{'a':2})\n        def d11v(a, b=1, *rest): pass\n        d11v(1)\n        d11v(1, 2)\n        d11v(1, 2, 3)\n        def d21v(a, b, c=1, *rest): pass\n        d21v(1, 2)\n        d21v(1, 2, 3)\n        d21v(1, 2, 3, 4)\n        d21v(*(1, 2, 3, 4))\n        d21v(1, 2, **{'c': 3})\n        def d02v(a=1, b=2, *rest): pass\n        d02v()\n        d02v(1)\n        d02v(1, 2)\n        d02v(1, 2, 3)\n        d02v(1, *(2, 3, 4))\n        d02v(**{'a': 1, 'b': 2})\n        def d12v(a, b=1, c=2, *rest): pass\n        d12v(1)\n        d12v(1, 2)\n        d12v(1, 2, 3)\n        d12v(1, 2, 3, 4)\n        d12v(*(1, 2, 3, 4))\n        d12v(1, 2, *(3, 4, 5))\n        d12v(1, *(2,), **{'c': 3})\n        def d22v(a, b, c=1, d=2, *rest): pass\n        d22v(1, 2)\n        d22v(1, 2, 3)\n        d22v(1, 2, 3, 4)\n        d22v(1, 2, 3, 4, 5)\n        d22v(*(1, 2, 3, 4))\n        d22v(1, 2, *(3, 4, 5))\n        d22v(1, *(2, 3), **{'d': 4})\n\n        # keyword argument type tests\n        try:\n            str('x', **{b'foo':1 })\n        except TypeError:\n            pass\n        else:\n            self.fail('Bytes should not work as keyword argument names')\n        # keyword only argument tests\n        def pos0key1(*, key): return key\n        pos0key1(key=100)\n        def pos2key2(p1, p2, *, k1, k2=100): return p1,p2,k1,k2\n        pos2key2(1, 2, k1=100)\n        pos2key2(1, 2, k1=100, k2=200)\n        pos2key2(1, 2, k2=100, k1=200)\n        def pos2key2dict(p1, p2, *, k1=100, k2, **kwarg): return p1,p2,k1,k2,kwarg\n        pos2key2dict(1,2,k2=100,tokwarg1=100,tokwarg2=200)\n        pos2key2dict(1,2,tokwarg1=100,tokwarg2=200, k2=100)\n\n        # keyword arguments after *arglist\n        def f(*args, **kwargs):\n            return args, kwargs\n        self.assertEquals(f(1, x=2, *[3, 4], y=5), ((1, 3, 4),\n                                                    {'x':2, 'y':5}))\n        self.assertRaises(SyntaxError, eval, \"f(1, *(2,3), 4)\")\n        self.assertRaises(SyntaxError, eval, \"f(1, x=2, *(3,4), x=5)\")\n\n        # argument annotation tests\n        def f(x) -> list: pass\n        self.assertEquals(f.__annotations__, {'return': list})\n        def f(x:int): pass\n        self.assertEquals(f.__annotations__, {'x': int})\n        def f(*x:str): pass\n        self.assertEquals(f.__annotations__, {'x': str})\n        def f(**x:float): pass\n        self.assertEquals(f.__annotations__, {'x': float})\n        def f(x, y:1+2): pass\n        self.assertEquals(f.__annotations__, {'y': 3})\n        def f(a, b:1, c:2, d): pass\n        self.assertEquals(f.__annotations__, {'b': 1, 'c': 2})\n        def f(a, b:1, c:2, d, e:3=4, f=5, *g:6): pass\n        self.assertEquals(f.__annotations__,\n                          {'b': 1, 'c': 2, 'e': 3, 'g': 6})\n        def f(a, b:1, c:2, d, e:3=4, f=5, *g:6, h:7, i=8, j:9=10,\n              **k:11) -> 12: pass\n        self.assertEquals(f.__annotations__,\n                          {'b': 1, 'c': 2, 'e': 3, 'g': 6, 'h': 7, 'j': 9,\n                           'k': 11, 'return': 12})\n        # Check for SF Bug #1697248 - mixing decorators and a return annotation\n        def null(x): return x\n        @null\n        def f(x) -> list: pass\n        self.assertEquals(f.__annotations__, {'return': list})\n\n        # test closures with a variety of oparg's\n        closure = 1\n        def f(): return closure\n        def f(x=1): return closure\n        def f(*, k=1): return closure\n        def f() -> int: return closure\n\n        # Check ast errors in *args and *kwargs\n        check_syntax_error(self, \"f(*g(1=2))\")\n        check_syntax_error(self, \"f(**g(1=2))\")\n\n    def testLambdef(self):\n        ### lambdef: 'lambda' [varargslist] ':' test\n        l1 = lambda : 0\n        self.assertEquals(l1(), 0)\n        l2 = lambda : a[d] # XXX just testing the expression\n        l3 = lambda : [2 < x for x in [-1, 3, 0]]\n        self.assertEquals(l3(), [0, 1, 0])\n        l4 = lambda x = lambda y = lambda z=1 : z : y() : x()\n        self.assertEquals(l4(), 1)\n        l5 = lambda x, y, z=2: x + y + z\n        self.assertEquals(l5(1, 2), 5)\n        self.assertEquals(l5(1, 2, 3), 6)\n        check_syntax_error(self, \"lambda x: x = 2\")\n        check_syntax_error(self, \"lambda (None,): None\")\n        l6 = lambda x, y, *, k=20: x+y+k\n        self.assertEquals(l6(1,2), 1+2+20)\n        self.assertEquals(l6(1,2,k=10), 1+2+10)\n\n\n    ### stmt: simple_stmt | compound_stmt\n    # Tested below\n\n    def testSimpleStmt(self):\n        ### simple_stmt: small_stmt (';' small_stmt)* [';']\n        x = 1; pass; del x\n        def foo():\n            # verify statements that end with semi-colons\n            x = 1; pass; del x;\n        foo()\n\n    ### small_stmt: expr_stmt | pass_stmt | del_stmt | flow_stmt | import_stmt | global_stmt | access_stmt\n    # Tested below\n\n    def testExprStmt(self):\n        # (exprlist '=')* exprlist\n        1\n        1, 2, 3\n        x = 1\n        x = 1, 2, 3\n        x = y = z = 1, 2, 3\n        x, y, z = 1, 2, 3\n        abc = a, b, c = x, y, z = xyz = 1, 2, (3, 4)\n\n        check_syntax_error(self, \"x + 1 = 1\")\n        check_syntax_error(self, \"a + 1 = b + 2\")\n\n    def testDelStmt(self):\n        # 'del' exprlist\n        abc = [1,2,3]\n        x, y, z = abc\n        xyz = x, y, z\n\n        del abc\n        del x, y, (z, xyz)\n\n    def testPassStmt(self):\n        # 'pass'\n        pass\n\n    # flow_stmt: break_stmt | continue_stmt | return_stmt | raise_stmt\n    # Tested below\n\n    def testBreakStmt(self):\n        # 'break'\n        while 1: break\n\n    def testContinueStmt(self):\n        # 'continue'\n        i = 1\n        while i: i = 0; continue\n\n        msg = \"\"\n        while not msg:\n            msg = \"ok\"\n            try:\n                continue\n                msg = \"continue failed to continue inside try\"\n            except:\n                msg = \"continue inside try called except block\"\n        if msg != \"ok\":\n            self.fail(msg)\n\n        msg = \"\"\n        while not msg:\n            msg = \"finally block not called\"\n            try:\n                continue\n            finally:\n                msg = \"ok\"\n        if msg != \"ok\":\n            self.fail(msg)\n\n    def test_break_continue_loop(self):\n        # This test warrants an explanation. It is a test specifically for SF bugs\n        # #463359 and #462937. The bug is that a 'break' statement executed or\n        # exception raised inside a try/except inside a loop, *after* a continue\n        # statement has been executed in that loop, will cause the wrong number of\n        # arguments to be popped off the stack and the instruction pointer reset to\n        # a very small number (usually 0.) Because of this, the following test\n        # *must* written as a function, and the tracking vars *must* be function\n        # arguments with default values. Otherwise, the test will loop and loop.\n\n        def test_inner(extra_burning_oil = 1, count=0):\n            big_hippo = 2\n            while big_hippo:\n                count += 1\n                try:\n                    if extra_burning_oil and big_hippo == 1:\n                        extra_burning_oil -= 1\n                        break\n                    big_hippo -= 1\n                    continue\n                except:\n                    raise\n            if count > 2 or big_hippo != 1:\n                self.fail(\"continue then break in try/except in loop broken!\")\n        test_inner()\n\n    def testReturn(self):\n        # 'return' [testlist]\n        def g1(): return\n        def g2(): return 1\n        g1()\n        x = g2()\n        check_syntax_error(self, \"class foo:return 1\")\n\n    def testYield(self):\n        check_syntax_error(self, \"class foo:yield 1\")\n\n    def testRaise(self):\n        # 'raise' test [',' test]\n        try: raise RuntimeError('just testing')\n        except RuntimeError: pass\n        try: raise KeyboardInterrupt\n        except KeyboardInterrupt: pass\n\n    def testImport(self):\n        # 'import' dotted_as_names\n        import sys\n        import time, sys\n        # 'from' dotted_name 'import' ('*' | '(' import_as_names ')' | import_as_names)\n        from time import time\n        from time import (time)\n        # not testable inside a function, but already done at top of the module\n        # from sys import *\n        from sys import path, argv\n        from sys import (path, argv)\n        from sys import (path, argv,)\n\n    def testGlobal(self):\n        # 'global' NAME (',' NAME)*\n        global a\n        global a, b\n        global one, two, three, four, five, six, seven, eight, nine, ten\n\n    def testNonlocal(self):\n        # 'nonlocal' NAME (',' NAME)*\n        x = 0\n        y = 0\n        def f():\n            nonlocal x\n            nonlocal x, y\n\n    def testAssert(self):\n        # assert_stmt: 'assert' test [',' test]\n        assert 1\n        assert 1, 1\n        assert lambda x:x\n        assert 1, lambda x:x+1\n        try:\n            assert 0, \"msg\"\n        except AssertionError as e:\n            self.assertEquals(e.args[0], \"msg\")\n        else:\n            if __debug__:\n                self.fail(\"AssertionError not raised by assert 0\")\n\n    ### compound_stmt: if_stmt | while_stmt | for_stmt | try_stmt | funcdef | classdef\n    # Tested below\n\n    def testIf(self):\n        # 'if' test ':' suite ('elif' test ':' suite)* ['else' ':' suite]\n        if 1: pass\n        if 1: pass\n        else: pass\n        if 0: pass\n        elif 0: pass\n        if 0: pass\n        elif 0: pass\n        elif 0: pass\n        elif 0: pass\n        else: pass\n\n    def testWhile(self):\n        # 'while' test ':' suite ['else' ':' suite]\n        while 0: pass\n        while 0: pass\n        else: pass\n\n        # Issue1920: \"while 0\" is optimized away,\n        # ensure that the \"else\" clause is still present.\n        x = 0\n        while 0:\n            x = 1\n        else:\n            x = 2\n        self.assertEquals(x, 2)\n\n    def testFor(self):\n        # 'for' exprlist 'in' exprlist ':' suite ['else' ':' suite]\n        for i in 1, 2, 3: pass\n        for i, j, k in (): pass\n        else: pass\n        class Squares:\n            def __init__(self, max):\n                self.max = max\n                self.sofar = []\n            def __len__(self): return len(self.sofar)\n            def __getitem__(self, i):\n                if not 0 <= i < self.max: raise IndexError\n                n = len(self.sofar)\n                while n <= i:\n                    self.sofar.append(n*n)\n                    n = n+1\n                return self.sofar[i]\n        n = 0\n        for x in Squares(10): n = n+x\n        if n != 285:\n            self.fail('for over growing sequence')\n\n        result = []\n        for x, in [(1,), (2,), (3,)]:\n            result.append(x)\n        self.assertEqual(result, [1, 2, 3])\n\n    def testTry(self):\n        ### try_stmt: 'try' ':' suite (except_clause ':' suite)+ ['else' ':' suite]\n        ###         | 'try' ':' suite 'finally' ':' suite\n        ### except_clause: 'except' [expr ['as' expr]]\n        try:\n            1/0\n        except ZeroDivisionError:\n            pass\n        else:\n            pass\n        try: 1/0\n        except EOFError: pass\n        except TypeError as msg: pass\n        except RuntimeError as msg: pass\n        except: pass\n        else: pass\n        try: 1/0\n        except (EOFError, TypeError, ZeroDivisionError): pass\n        try: 1/0\n        except (EOFError, TypeError, ZeroDivisionError) as msg: pass\n        try: pass\n        finally: pass\n\n    def testSuite(self):\n        # simple_stmt | NEWLINE INDENT NEWLINE* (stmt NEWLINE*)+ DEDENT\n        if 1: pass\n        if 1:\n            pass\n        if 1:\n            #\n            #\n            #\n            pass\n            pass\n            #\n            pass\n            #\n\n    def testTest(self):\n        ### and_test ('or' and_test)*\n        ### and_test: not_test ('and' not_test)*\n        ### not_test: 'not' not_test | comparison\n        if not 1: pass\n        if 1 and 1: pass\n        if 1 or 1: pass\n        if not not not 1: pass\n        if not 1 and 1 and 1: pass\n        if 1 and 1 or 1 and 1 and 1 or not 1 and 1: pass\n\n    def testComparison(self):\n        ### comparison: expr (comp_op expr)*\n        ### comp_op: '<'|'>'|'=='|'>='|'<='|'!='|'in'|'not' 'in'|'is'|'is' 'not'\n        if 1: pass\n        x = (1 == 1)\n        if 1 == 1: pass\n        if 1 != 1: pass\n        if 1 < 1: pass\n        if 1 > 1: pass\n        if 1 <= 1: pass\n        if 1 >= 1: pass\n        if 1 is 1: pass\n        if 1 is not 1: pass\n        if 1 in (): pass\n        if 1 not in (): pass\n        if 1 < 1 > 1 == 1 >= 1 <= 1 != 1 in 1 not in 1 is 1 is not 1: pass\n\n    def testBinaryMaskOps(self):\n        x = 1 & 1\n        x = 1 ^ 1\n        x = 1 | 1\n\n    def testShiftOps(self):\n        x = 1 << 1\n        x = 1 >> 1\n        x = 1 << 1 >> 1\n\n    def testAdditiveOps(self):\n        x = 1\n        x = 1 + 1\n        x = 1 - 1 - 1\n        x = 1 - 1 + 1 - 1 + 1\n\n    def testMultiplicativeOps(self):\n        x = 1 * 1\n        x = 1 / 1\n        x = 1 % 1\n        x = 1 / 1 * 1 % 1\n\n    def testUnaryOps(self):\n        x = +1\n        x = -1\n        x = ~1\n        x = ~1 ^ 1 & 1 | 1 & 1 ^ -1\n        x = -1*1/1 + 1*1 - ---1*1\n\n    def testSelectors(self):\n        ### trailer: '(' [testlist] ')' | '[' subscript ']' | '.' NAME\n        ### subscript: expr | [expr] ':' [expr]\n\n        import sys, time\n        c = sys.path[0]\n        x = time.time()\n        x = sys.modules['time'].time()\n        a = '01234'\n        c = a[0]\n        c = a[-1]\n        s = a[0:5]\n        s = a[:5]\n        s = a[0:]\n        s = a[:]\n        s = a[-5:]\n        s = a[:-1]\n        s = a[-4:-3]\n        # A rough test of SF bug 1333982.  http://python.org/sf/1333982\n        # The testing here is fairly incomplete.\n        # Test cases should include: commas with 1 and 2 colons\n        d = {}\n        d[1] = 1\n        d[1,] = 2\n        d[1,2] = 3\n        d[1,2,3] = 4\n        L = list(d)\n        L.sort(key=lambda x: x if isinstance(x, tuple) else ())\n        self.assertEquals(str(L), '[1, (1,), (1, 2), (1, 2, 3)]')\n\n    def testAtoms(self):\n        ### atom: '(' [testlist] ')' | '[' [testlist] ']' | '{' [dictsetmaker] '}' | NAME | NUMBER | STRING\n        ### dictsetmaker: (test ':' test (',' test ':' test)* [',']) | (test (',' test)* [','])\n\n        x = (1)\n        x = (1 or 2 or 3)\n        x = (1 or 2 or 3, 2, 3)\n\n        x = []\n        x = [1]\n        x = [1 or 2 or 3]\n        x = [1 or 2 or 3, 2, 3]\n        x = []\n\n        x = {}\n        x = {'one': 1}\n        x = {'one': 1,}\n        x = {'one' or 'two': 1 or 2}\n        x = {'one': 1, 'two': 2}\n        x = {'one': 1, 'two': 2,}\n        x = {'one': 1, 'two': 2, 'three': 3, 'four': 4, 'five': 5, 'six': 6}\n\n        x = {'one'}\n        x = {'one', 1,}\n        x = {'one', 'two', 'three'}\n        x = {2, 3, 4,}\n\n        x = x\n        x = 'x'\n        x = 123\n\n    ### exprlist: expr (',' expr)* [',']\n    ### testlist: test (',' test)* [',']\n    # These have been exercised enough above\n\n    def testClassdef(self):\n        # 'class' NAME ['(' [testlist] ')'] ':' suite\n        class B: pass\n        class B2(): pass\n        class C1(B): pass\n        class C2(B): pass\n        class D(C1, C2, B): pass\n        class C:\n            def meth1(self): pass\n            def meth2(self, arg): pass\n            def meth3(self, a1, a2): pass\n\n        # decorator: '@' dotted_name [ '(' [arglist] ')' ] NEWLINE\n        # decorators: decorator+\n        # decorated: decorators (classdef | funcdef)\n        def class_decorator(x): return x\n        @class_decorator\n        class G: pass\n\n    def testDictcomps(self):\n        # dictorsetmaker: ( (test ':' test (comp_for |\n        #                                   (',' test ':' test)* [','])) |\n        #                   (test (comp_for | (',' test)* [','])) )\n        nums = [1, 2, 3]\n        self.assertEqual({i:i+1 for i in nums}, {1: 2, 2: 3, 3: 4})\n\n    def testListcomps(self):\n        # list comprehension tests\n        nums = [1, 2, 3, 4, 5]\n        strs = [\"Apple\", \"Banana\", \"Coconut\"]\n        spcs = [\"  Apple\", \" Banana \", \"Coco  nut  \"]\n\n        self.assertEqual([s.strip() for s in spcs], ['Apple', 'Banana', 'Coco  nut'])\n        self.assertEqual([3 * x for x in nums], [3, 6, 9, 12, 15])\n        self.assertEqual([x for x in nums if x > 2], [3, 4, 5])\n        self.assertEqual([(i, s) for i in nums for s in strs],\n                         [(1, 'Apple'), (1, 'Banana'), (1, 'Coconut'),\n                          (2, 'Apple'), (2, 'Banana'), (2, 'Coconut'),\n                          (3, 'Apple'), (3, 'Banana'), (3, 'Coconut'),\n                          (4, 'Apple'), (4, 'Banana'), (4, 'Coconut'),\n                          (5, 'Apple'), (5, 'Banana'), (5, 'Coconut')])\n        self.assertEqual([(i, s) for i in nums for s in [f for f in strs if \"n\" in f]],\n                         [(1, 'Banana'), (1, 'Coconut'), (2, 'Banana'), (2, 'Coconut'),\n                          (3, 'Banana'), (3, 'Coconut'), (4, 'Banana'), (4, 'Coconut'),\n                          (5, 'Banana'), (5, 'Coconut')])\n        self.assertEqual([(lambda a:[a**i for i in range(a+1)])(j) for j in range(5)],\n                         [[1], [1, 1], [1, 2, 4], [1, 3, 9, 27], [1, 4, 16, 64, 256]])\n\n        def test_in_func(l):\n            return [0 < x < 3 for x in l if x > 2]\n\n        self.assertEqual(test_in_func(nums), [False, False, False])\n\n        def test_nested_front():\n            self.assertEqual([[y for y in [x, x + 1]] for x in [1,3,5]],\n                             [[1, 2], [3, 4], [5, 6]])\n\n        test_nested_front()\n\n        check_syntax_error(self, \"[i, s for i in nums for s in strs]\")\n        check_syntax_error(self, \"[x if y]\")\n\n        suppliers = [\n          (1, \"Boeing\"),\n          (2, \"Ford\"),\n          (3, \"Macdonalds\")\n        ]\n\n        parts = [\n          (10, \"Airliner\"),\n          (20, \"Engine\"),\n          (30, \"Cheeseburger\")\n        ]\n\n        suppart = [\n          (1, 10), (1, 20), (2, 20), (3, 30)\n        ]\n\n        x = [\n          (sname, pname)\n            for (sno, sname) in suppliers\n              for (pno, pname) in parts\n                for (sp_sno, sp_pno) in suppart\n                  if sno == sp_sno and pno == sp_pno\n        ]\n\n        self.assertEqual(x, [('Boeing', 'Airliner'), ('Boeing', 'Engine'), ('Ford', 'Engine'),\n                             ('Macdonalds', 'Cheeseburger')])\n\n    def testGenexps(self):\n        # generator expression tests\n        g = ([x for x in range(10)] for x in range(1))\n        self.assertEqual(next(g), [x for x in range(10)])\n        try:\n            next(g)\n            self.fail('should produce StopIteration exception')\n        except StopIteration:\n            pass\n\n        a = 1\n        try:\n            g = (a for d in a)\n            next(g)\n            self.fail('should produce TypeError')\n        except TypeError:\n            pass\n\n        self.assertEqual(list((x, y) for x in 'abcd' for y in 'abcd'), [(x, y) for x in 'abcd' for y in 'abcd'])\n        self.assertEqual(list((x, y) for x in 'ab' for y in 'xy'), [(x, y) for x in 'ab' for y in 'xy'])\n\n        a = [x for x in range(10)]\n        b = (x for x in (y for y in a))\n        self.assertEqual(sum(b), sum([x for x in range(10)]))\n\n        self.assertEqual(sum(x**2 for x in range(10)), sum([x**2 for x in range(10)]))\n        self.assertEqual(sum(x*x for x in range(10) if x%2), sum([x*x for x in range(10) if x%2]))\n        self.assertEqual(sum(x for x in (y for y in range(10))), sum([x for x in range(10)]))\n        self.assertEqual(sum(x for x in (y for y in (z for z in range(10)))), sum([x for x in range(10)]))\n        self.assertEqual(sum(x for x in [y for y in (z for z in range(10))]), sum([x for x in range(10)]))\n        self.assertEqual(sum(x for x in (y for y in (z for z in range(10) if True)) if True), sum([x for x in range(10)]))\n        self.assertEqual(sum(x for x in (y for y in (z for z in range(10) if True) if False) if True), 0)\n        check_syntax_error(self, \"foo(x for x in range(10), 100)\")\n        check_syntax_error(self, \"foo(100, x for x in range(10))\")\n\n    def testComprehensionSpecials(self):\n        # test for outmost iterable precomputation\n        x = 10; g = (i for i in range(x)); x = 5\n        self.assertEqual(len(list(g)), 10)\n\n        # This should hold, since we're only precomputing outmost iterable.\n        x = 10; t = False; g = ((i,j) for i in range(x) if t for j in range(x))\n        x = 5; t = True;\n        self.assertEqual([(i,j) for i in range(10) for j in range(5)], list(g))\n\n        # Grammar allows multiple adjacent 'if's in listcomps and genexps,\n        # even though it's silly. Make sure it works (ifelse broke this.)\n        self.assertEqual([ x for x in range(10) if x % 2 if x % 3 ], [1, 5, 7])\n        self.assertEqual(list(x for x in range(10) if x % 2 if x % 3), [1, 5, 7])\n\n        # verify unpacking single element tuples in listcomp/genexp.\n        self.assertEqual([x for x, in [(4,), (5,), (6,)]], [4, 5, 6])\n        self.assertEqual(list(x for x, in [(7,), (8,), (9,)]), [7, 8, 9])\n\n    def test_with_statement(self):\n        class manager(object):\n            def __enter__(self):\n                return (1, 2)\n            def __exit__(self, *args):\n                pass\n\n        with manager():\n            pass\n        with manager() as x:\n            pass\n        with manager() as (x, y):\n            pass\n        with manager(), manager():\n            pass\n        with manager() as x, manager() as y:\n            pass\n        with manager() as x, manager():\n            pass\n\n    def testIfElseExpr(self):\n        # Test ifelse expressions in various cases\n        def _checkeval(msg, ret):\n            \"helper to check that evaluation of expressions is done correctly\"\n            print(x)\n            return ret\n\n        # the next line is not allowed anymore\n        #self.assertEqual([ x() for x in lambda: True, lambda: False if x() ], [True])\n        self.assertEqual([ x() for x in (lambda: True, lambda: False) if x() ], [True])\n        self.assertEqual([ x(False) for x in (lambda x: False if x else True, lambda x: True if x else False) if x(False) ], [True])\n        self.assertEqual((5 if 1 else _checkeval(\"check 1\", 0)), 5)\n        self.assertEqual((_checkeval(\"check 2\", 0) if 0 else 5), 5)\n        self.assertEqual((5 and 6 if 0 else 1), 1)\n        self.assertEqual(((5 and 6) if 0 else 1), 1)\n        self.assertEqual((5 and (6 if 1 else 1)), 6)\n        self.assertEqual((0 or _checkeval(\"check 3\", 2) if 0 else 3), 3)\n        self.assertEqual((1 or _checkeval(\"check 4\", 2) if 1 else _checkeval(\"check 5\", 3)), 1)\n        self.assertEqual((0 or 5 if 1 else _checkeval(\"check 6\", 3)), 5)\n        self.assertEqual((not 5 if 1 else 1), False)\n        self.assertEqual((not 5 if 0 else 1), 1)\n        self.assertEqual((6 + 1 if 1 else 2), 7)\n        self.assertEqual((6 - 1 if 1 else 2), 5)\n        self.assertEqual((6 * 2 if 1 else 4), 12)\n        self.assertEqual((6 / 2 if 1 else 3), 3)\n        self.assertEqual((6 < 4 if 0 else 2), 2)\n\n    def testStringLiterals(self):\n        x = ''; y = \"\"; self.assert_(len(x) == 0 and x == y)\n        x = '\\''; y = \"'\"; self.assert_(len(x) == 1 and x == y and ord(x) == 39)\n        x = '\"'; y = \"\\\"\"; self.assert_(len(x) == 1 and x == y and ord(x) == 34)\n        x = \"doesn't \\\"shrink\\\" does it\"\n        y = 'doesn\\'t \"shrink\" does it'\n        self.assert_(len(x) == 24 and x == y)\n        x = \"does \\\"shrink\\\" doesn't it\"\n        y = 'does \"shrink\" doesn\\'t it'\n        self.assert_(len(x) == 24 and x == y)\n        x = \"\"\"\nThe \"quick\"\nbrown fox\njumps over\nthe 'lazy' dog.\n\"\"\"\n        y = '\\nThe \"quick\"\\nbrown fox\\njumps over\\nthe \\'lazy\\' dog.\\n'\n        self.assertEquals(x, y)\n        y = '''\nThe \"quick\"\nbrown fox\njumps over\nthe 'lazy' dog.\n'''\n        self.assertEquals(x, y)\n        y = \"\\n\\\nThe \\\"quick\\\"\\n\\\nbrown fox\\n\\\njumps over\\n\\\nthe 'lazy' dog.\\n\\\n\"\n        self.assertEquals(x, y)\n        y = '\\n\\\nThe \\\"quick\\\"\\n\\\nbrown fox\\n\\\njumps over\\n\\\nthe \\'lazy\\' dog.\\n\\\n'\n        self.assertEquals(x, y)",
  "vendor/tree-sitter-python/examples/python3-grammar-crlf.py::def_test_main": "def test_main():\n    run_unittest(TokenTests, GrammarTests)\n\nif __name__ == '__main__':\n    test_main()",
  "vendor/tree-sitter-python/examples/mixed-spaces-tabs.py::def_main": "def main():\n\tprint \"hello\"\n\t# 1 tab = 8 spaces in Python 2\n        return",
  "vendor/tree-sitter-python/examples/trailing-whitespace.py::header": "print a    \n\nif b:    \n    if c:    \n        d\n    e",
  "vendor/tree-sitter-python/examples/multiple-newlines.py::def_hi": "def hi():\n\n\n\n    print \"hi\"",
  "vendor/tree-sitter-python/examples/multiple-newlines.py::def_bye": "def bye():\n    print \"bye\"",
  "vendor/tree-sitter-python/examples/python2-grammar.py::header": "# Python test set -- part 1, grammar.\n# This just tests whether the parser accepts them all.\n\n# NOTE: When you run this test as a script from the command line, you\n# get warnings about certain hex/oct constants.  Since those are\n# issued by the parser, you can't suppress them by adding a\n# filterwarnings() call to this module.  Therefore, to shut up the\n# regression test, the filterwarnings() call has been added to\n# regrtest.py.\n\nfrom test.test_support import run_unittest, check_syntax_error\nimport unittest\nimport sys\n# testing import *\nfrom sys import *",
  "vendor/tree-sitter-python/examples/python2-grammar.py::class_TokenTests": "class TokenTests(unittest.TestCase):\n\n    def testBackslash(self):\n        # Backslash means line continuation:\n        x = 1 \\\n        + 1\n        self.assertEquals(x, 2, 'backslash for line continuation')\n\n        # Backslash does not means continuation in comments :\\\n        x = 0\n        self.assertEquals(x, 0, 'backslash ending comment')\n\n    def testPlainIntegers(self):\n        self.assertEquals(0xff, 255)\n        self.assertEquals(0377, 255)\n        self.assertEquals(2147483647, 017777777777)\n        # \"0x\" is not a valid literal\n        self.assertRaises(SyntaxError, eval, \"0x\")\n        from sys import maxint\n        if maxint == 2147483647:\n            self.assertEquals(-2147483647-1, -020000000000)\n            # XXX -2147483648\n            self.assert_(037777777777 > 0)\n            self.assert_(0xffffffff > 0)\n            for s in '2147483648', '040000000000', '0x100000000':\n                try:\n                    x = eval(s)\n                except OverflowError:\n                    self.fail(\"OverflowError on huge integer literal %r\" % s)\n        elif maxint == 9223372036854775807:\n            self.assertEquals(-9223372036854775807-1, -01000000000000000000000)\n            self.assert_(01777777777777777777777 > 0)\n            self.assert_(0xffffffffffffffff > 0)\n            for s in '9223372036854775808', '02000000000000000000000', \\\n                     '0x10000000000000000':\n                try:\n                    x = eval(s)\n                except OverflowError:\n                    self.fail(\"OverflowError on huge integer literal %r\" % s)\n        else:\n            self.fail('Weird maxint value %r' % maxint)\n\n    def testLongIntegers(self):\n        x = 0L\n        x = 0l\n        x = 0xffffffffffffffffL\n        x = 0xffffffffffffffffl\n        x = 077777777777777777L\n        x = 077777777777777777l\n        x = 123456789012345678901234567890L\n        x = 123456789012345678901234567890l\n\n    def testFloats(self):\n        x = 3.14\n        x = 314.\n        x = 0.314\n        # XXX x = 000.314\n        x = .314\n        x = 3e14\n        x = 3E14\n        x = 3e-14\n        x = 3e+14\n        x = 3.e14\n        x = .3e14\n        x = 3.1e4",
  "vendor/tree-sitter-python/examples/python2-grammar.py::class_GrammarTests": "class GrammarTests(unittest.TestCase):\n\n    # single_input: NEWLINE | simple_stmt | compound_stmt NEWLINE\n    # XXX can't test in a script -- this rule is only used when interactive\n\n    # file_input: (NEWLINE | stmt)* ENDMARKER\n    # Being tested as this very moment this very module\n\n    # expr_input: testlist NEWLINE\n    # XXX Hard to test -- used only in calls to input()\n\n    def testEvalInput(self):\n        # testlist ENDMARKER\n        x = eval('1, 0 or 1')\n\n    def testFuncdef(self):\n        ### 'def' NAME parameters ':' suite\n        ### parameters: '(' [varargslist] ')'\n        ### varargslist: (fpdef ['=' test] ',')* ('*' NAME [',' ('**'|'*' '*') NAME]\n        ###            | ('**'|'*' '*') NAME)\n        ###            | fpdef ['=' test] (',' fpdef ['=' test])* [',']\n        ### fpdef: NAME | '(' fplist ')'\n        ### fplist: fpdef (',' fpdef)* [',']\n        ### arglist: (argument ',')* (argument | *' test [',' '**' test] | '**' test)\n        ### argument: [test '='] test   # Really [keyword '='] test\n        def f1(): pass\n        f1()\n        f1(*())\n        f1(*(), **{})\n        def f2(one_argument): pass\n        def f3(two, arguments): pass\n        def f4(two, (compound, (argument, list))): pass\n        def f5((compound, first), two): pass\n        self.assertEquals(f2.func_code.co_varnames, ('one_argument',))\n        self.assertEquals(f3.func_code.co_varnames, ('two', 'arguments'))\n        if sys.platform.startswith('java'):\n            self.assertEquals(f4.func_code.co_varnames,\n                   ('two', '(compound, (argument, list))', 'compound', 'argument',\n                                'list',))\n            self.assertEquals(f5.func_code.co_varnames,\n                   ('(compound, first)', 'two', 'compound', 'first'))\n        else:\n            self.assertEquals(f4.func_code.co_varnames,\n                  ('two', '.1', 'compound', 'argument',  'list'))\n            self.assertEquals(f5.func_code.co_varnames,\n                  ('.0', 'two', 'compound', 'first'))\n        def a1(one_arg,): pass\n        def a2(two, args,): pass\n        def v0(*rest): pass\n        def v1(a, *rest): pass\n        def v2(a, b, *rest): pass\n        def v3(a, (b, c), *rest): return a, b, c, rest\n\n        f1()\n        f2(1)\n        f2(1,)\n        f3(1, 2)\n        f3(1, 2,)\n        f4(1, (2, (3, 4)))\n        v0()\n        v0(1)\n        v0(1,)\n        v0(1,2)\n        v0(1,2,3,4,5,6,7,8,9,0)\n        v1(1)\n        v1(1,)\n        v1(1,2)\n        v1(1,2,3)\n        v1(1,2,3,4,5,6,7,8,9,0)\n        v2(1,2)\n        v2(1,2,3)\n        v2(1,2,3,4)\n        v2(1,2,3,4,5,6,7,8,9,0)\n        v3(1,(2,3))\n        v3(1,(2,3),4)\n        v3(1,(2,3),4,5,6,7,8,9,0)\n\n        # ceval unpacks the formal arguments into the first argcount names;\n        # thus, the names nested inside tuples must appear after these names.\n        if sys.platform.startswith('java'):\n            self.assertEquals(v3.func_code.co_varnames, ('a', '(b, c)', 'rest', 'b', 'c'))\n        else:\n            self.assertEquals(v3.func_code.co_varnames, ('a', '.1', 'rest', 'b', 'c'))\n        self.assertEquals(v3(1, (2, 3), 4), (1, 2, 3, (4,)))\n        def d01(a=1): pass\n        d01()\n        d01(1)\n        d01(*(1,))\n        d01(**{'a':2})\n        def d11(a, b=1): pass\n        d11(1)\n        d11(1, 2)\n        d11(1, **{'b':2})\n        def d21(a, b, c=1): pass\n        d21(1, 2)\n        d21(1, 2, 3)\n        d21(*(1, 2, 3))\n        d21(1, *(2, 3))\n        d21(1, 2, *(3,))\n        d21(1, 2, **{'c':3})\n        def d02(a=1, b=2): pass\n        d02()\n        d02(1)\n        d02(1, 2)\n        d02(*(1, 2))\n        d02(1, *(2,))\n        d02(1, **{'b':2})\n        d02(**{'a': 1, 'b': 2})\n        def d12(a, b=1, c=2): pass\n        d12(1)\n        d12(1, 2)\n        d12(1, 2, 3)\n        def d22(a, b, c=1, d=2): pass\n        d22(1, 2)\n        d22(1, 2, 3)\n        d22(1, 2, 3, 4)\n        def d01v(a=1, *rest): pass\n        d01v()\n        d01v(1)\n        d01v(1, 2)\n        d01v(*(1, 2, 3, 4))\n        d01v(*(1,))\n        d01v(**{'a':2})\n        def d11v(a, b=1, *rest): pass\n        d11v(1)\n        d11v(1, 2)\n        d11v(1, 2, 3)\n        def d21v(a, b, c=1, *rest): pass\n        d21v(1, 2)\n        d21v(1, 2, 3)\n        d21v(1, 2, 3, 4)\n        d21v(*(1, 2, 3, 4))\n        d21v(1, 2, **{'c': 3})\n        def d02v(a=1, b=2, *rest): pass\n        d02v()\n        d02v(1)\n        d02v(1, 2)\n        d02v(1, 2, 3)\n        d02v(1, *(2, 3, 4))\n        d02v(**{'a': 1, 'b': 2})\n        def d12v(a, b=1, c=2, *rest): pass\n        d12v(1)\n        d12v(1, 2)\n        d12v(1, 2, 3)\n        d12v(1, 2, 3, 4)\n        d12v(*(1, 2, 3, 4))\n        d12v(1, 2, *(3, 4, 5))\n        d12v(1, *(2,), **{'c': 3})\n        def d22v(a, b, c=1, d=2, *rest): pass\n        d22v(1, 2)\n        d22v(1, 2, 3)\n        d22v(1, 2, 3, 4)\n        d22v(1, 2, 3, 4, 5)\n        d22v(*(1, 2, 3, 4))\n        d22v(1, 2, *(3, 4, 5))\n        d22v(1, *(2, 3), **{'d': 4})\n        def d31v((x)): pass\n        d31v(1)\n        def d32v((x,)): pass\n        d32v((1,))\n\n        # keyword arguments after *arglist\n        def f(*args, **kwargs):\n            return args, kwargs\n        self.assertEquals(f(1, x=2, *[3, 4], y=5), ((1, 3, 4),\n                                                    {'x':2, 'y':5}))\n        self.assertRaises(SyntaxError, eval, \"f(1, *(2,3), 4)\")\n        self.assertRaises(SyntaxError, eval, \"f(1, x=2, *(3,4), x=5)\")\n\n        # Check ast errors in *args and *kwargs\n        check_syntax_error(self, \"f(*g(1=2))\")\n        check_syntax_error(self, \"f(**g(1=2))\")\n\n    def testLambdef(self):\n        ### lambdef: 'lambda' [varargslist] ':' test\n        l1 = lambda : 0\n        self.assertEquals(l1(), 0)\n        l2 = lambda : a[d] # XXX just testing the expression\n        l3 = lambda : [2 < x for x in [-1, 3, 0L]]\n        self.assertEquals(l3(), [0, 1, 0])\n        l4 = lambda x = lambda y = lambda z=1 : z : y() : x()\n        self.assertEquals(l4(), 1)\n        l5 = lambda x, y, z=2: x + y + z\n        self.assertEquals(l5(1, 2), 5)\n        self.assertEquals(l5(1, 2, 3), 6)\n        check_syntax_error(self, \"lambda x: x = 2\")\n        check_syntax_error(self, \"lambda (None,): None\")\n\n    ### stmt: simple_stmt | compound_stmt\n    # Tested below\n\n    def testSimpleStmt(self):\n        ### simple_stmt: small_stmt (';' small_stmt)* [';']\n        x = 1; pass; del x\n        def foo():\n            # verify statements that end with semi-colons\n            x = 1; pass; del x;\n        foo()\n\n    ### small_stmt: expr_stmt | print_stmt  | pass_stmt | del_stmt | flow_stmt | import_stmt | global_stmt | access_stmt | exec_stmt\n    # Tested below\n\n    def testExprStmt(self):\n        # (exprlist '=')* exprlist\n        1\n        1, 2, 3\n        x = 1\n        x = 1, 2, 3\n        x = y = z = 1, 2, 3\n        x, y, z = 1, 2, 3\n        abc = a, b, c = x, y, z = xyz = 1, 2, (3, 4)\n\n        check_syntax_error(self, \"x + 1 = 1\")\n        check_syntax_error(self, \"a + 1 = b + 2\")\n\n    def testPrintStmt(self):\n        # 'print' (test ',')* [test]\n        import StringIO\n\n        # Can't test printing to real stdout without comparing output\n        # which is not available in unittest.\n        save_stdout = sys.stdout\n        sys.stdout = StringIO.StringIO()\n\n        print 1, 2, 3\n        print 1, 2, 3,\n        print\n        print 0 or 1, 0 or 1,\n        print 0 or 1\n\n        # 'print' '>>' test ','\n        print >> sys.stdout, 1, 2, 3\n        print >> sys.stdout, 1, 2, 3,\n        print >> sys.stdout\n        print >> sys.stdout, 0 or 1, 0 or 1,\n        print >> sys.stdout, 0 or 1\n\n        # test printing to an instance\n        class Gulp:\n            def write(self, msg): pass\n\n        gulp = Gulp()\n        print >> gulp, 1, 2, 3\n        print >> gulp, 1, 2, 3,\n        print >> gulp\n        print >> gulp, 0 or 1, 0 or 1,\n        print >> gulp, 0 or 1\n\n        # test print >> None\n        def driver():\n            oldstdout = sys.stdout\n            sys.stdout = Gulp()\n            try:\n                tellme(Gulp())\n                tellme()\n            finally:\n                sys.stdout = oldstdout\n\n        # we should see this once\n        def tellme(file=sys.stdout):\n            print >> file, 'hello world'\n\n        driver()\n\n        # we should not see this at all\n        def tellme(file=None):\n            print >> file, 'goodbye universe'\n\n        driver()\n\n        self.assertEqual(sys.stdout.getvalue(), '''\\\n1 2 3\n1 2 3\n1 1 1\n1 2 3\n1 2 3\n1 1 1\nhello world\n''')\n        sys.stdout = save_stdout\n\n        # syntax errors\n        check_syntax_error(self, 'print ,')\n        check_syntax_error(self, 'print >> x,')\n\n    def testDelStmt(self):\n        # 'del' exprlist\n        abc = [1,2,3]\n        x, y, z = abc\n        xyz = x, y, z\n\n        del abc\n        del x, y, (z, xyz)\n\n    def testPassStmt(self):\n        # 'pass'\n        pass\n\n    # flow_stmt: break_stmt | continue_stmt | return_stmt | raise_stmt\n    # Tested below\n\n    def testBreakStmt(self):\n        # 'break'\n        while 1: break\n\n    def testContinueStmt(self):\n        # 'continue'\n        i = 1\n        while i: i = 0; continue\n\n        msg = \"\"\n        while not msg:\n            msg = \"ok\"\n            try:\n                continue\n                msg = \"continue failed to continue inside try\"\n            except:\n                msg = \"continue inside try called except block\"\n        if msg != \"ok\":\n            self.fail(msg)\n\n        msg = \"\"\n        while not msg:\n            msg = \"finally block not called\"\n            try:\n                continue\n            finally:\n                msg = \"ok\"\n        if msg != \"ok\":\n            self.fail(msg)\n\n    def test_break_continue_loop(self):\n        # This test warrants an explanation. It is a test specifically for SF bugs\n        # #463359 and #462937. The bug is that a 'break' statement executed or\n        # exception raised inside a try/except inside a loop, *after* a continue\n        # statement has been executed in that loop, will cause the wrong number of\n        # arguments to be popped off the stack and the instruction pointer reset to\n        # a very small number (usually 0.) Because of this, the following test\n        # *must* written as a function, and the tracking vars *must* be function\n        # arguments with default values. Otherwise, the test will loop and loop.\n\n        def test_inner(extra_burning_oil = 1, count=0):\n            big_hippo = 2\n            while big_hippo:\n                count += 1\n                try:\n                    if extra_burning_oil and big_hippo == 1:\n                        extra_burning_oil -= 1\n                        break\n                    big_hippo -= 1\n                    continue\n                except:\n                    raise\n            if count > 2 or big_hippo <> 1:\n                self.fail(\"continue then break in try/except in loop broken!\")\n        test_inner()\n\n    def testReturn(self):\n        # 'return' [testlist]\n        def g1(): return\n        def g2(): return 1\n        g1()\n        x = g2()\n        check_syntax_error(self, \"class foo:return 1\")\n\n    def testYield(self):\n        check_syntax_error(self, \"class foo:yield 1\")\n\n    def testRaise(self):\n        # 'raise' test [',' test]\n        try: raise RuntimeError, 'just testing'\n        except RuntimeError: pass\n        try: raise KeyboardInterrupt\n        except KeyboardInterrupt: pass\n\n    def testImport(self):\n        # 'import' dotted_as_names\n        import sys\n        import time, sys\n        # 'from' dotted_name 'import' ('*' | '(' import_as_names ')' | import_as_names)\n        from time import time\n        from time import (time)\n        # not testable inside a function, but already done at top of the module\n        # from sys import *\n        from sys import path, argv\n        from sys import (path, argv)\n        from sys import (path, argv,)\n\n    def testGlobal(self):\n        # 'global' NAME (',' NAME)*\n        global a\n        global a, b\n        global one, two, three, four, five, six, seven, eight, nine, ten\n\n    def testExec(self):\n        # 'exec' expr ['in' expr [',' expr]]\n        z = None\n        del z\n        exec 'z=1+1\\n'\n        if z != 2: self.fail('exec \\'z=1+1\\'\\\\n')\n        del z\n        exec 'z=1+1'\n        if z != 2: self.fail('exec \\'z=1+1\\'')\n        z = None\n        del z\n        import types\n        if hasattr(types, \"UnicodeType\"):\n            exec r\"\"\"if 1:\n            exec u'z=1+1\\n'\n            if z != 2: self.fail('exec u\\'z=1+1\\'\\\\n')\n            del z\n            exec u'z=1+1'\n            if z != 2: self.fail('exec u\\'z=1+1\\'')\"\"\"\n        g = {}\n        exec 'z = 1' in g\n        if g.has_key('__builtins__'): del g['__builtins__']\n        if g != {'z': 1}: self.fail('exec \\'z = 1\\' in g')\n        g = {}\n        l = {}\n\n        import warnings\n        warnings.filterwarnings(\"ignore\", \"global statement\", module=\"<string>\")\n        exec 'global a; a = 1; b = 2' in g, l\n        if g.has_key('__builtins__'): del g['__builtins__']\n        if l.has_key('__builtins__'): del l['__builtins__']\n        if (g, l) != ({'a':1}, {'b':2}):\n            self.fail('exec ... in g (%s), l (%s)' %(g,l))\n\n    def testAssert(self):\n        # assert_stmt: 'assert' test [',' test]\n        assert 1\n        assert 1, 1\n        assert lambda x:x\n        assert 1, lambda x:x+1\n        try:\n            assert 0, \"msg\"\n        except AssertionError, e:\n            self.assertEquals(e.args[0], \"msg\")\n        else:\n            if __debug__:\n                self.fail(\"AssertionError not raised by assert 0\")\n\n    ### compound_stmt: if_stmt | while_stmt | for_stmt | try_stmt | funcdef | classdef\n    # Tested below\n\n    def testIf(self):\n        # 'if' test ':' suite ('elif' test ':' suite)* ['else' ':' suite]\n        if 1: pass\n        if 1: pass\n        else: pass\n        if 0: pass\n        elif 0: pass\n        if 0: pass\n        elif 0: pass\n        elif 0: pass\n        elif 0: pass\n        else: pass\n\n    def testWhile(self):\n        # 'while' test ':' suite ['else' ':' suite]\n        while 0: pass\n        while 0: pass\n        else: pass\n\n        # Issue1920: \"while 0\" is optimized away,\n        # ensure that the \"else\" clause is still present.\n        x = 0\n        while 0:\n            x = 1\n        else:\n            x = 2\n        self.assertEquals(x, 2)\n\n    def testFor(self):\n        # 'for' exprlist 'in' exprlist ':' suite ['else' ':' suite]\n        for i in 1, 2, 3: pass\n        for i, j, k in (): pass\n        else: pass\n        class Squares:\n            def __init__(self, max):\n                self.max = max\n                self.sofar = []\n            def __len__(self): return len(self.sofar)\n            def __getitem__(self, i):\n                if not 0 <= i < self.max: raise IndexError\n                n = len(self.sofar)\n                while n <= i:\n                    self.sofar.append(n*n)\n                    n = n+1\n                return self.sofar[i]\n        n = 0\n        for x in Squares(10): n = n+x\n        if n != 285:\n            self.fail('for over growing sequence')\n\n        result = []\n        for x, in [(1,), (2,), (3,)]:\n            result.append(x)\n        self.assertEqual(result, [1, 2, 3])\n\n    def testTry(self):\n        ### try_stmt: 'try' ':' suite (except_clause ':' suite)+ ['else' ':' suite]\n        ###         | 'try' ':' suite 'finally' ':' suite\n        ### except_clause: 'except' [expr [('as' | ',') expr]]\n        try:\n            1/0\n        except ZeroDivisionError:\n            pass\n        else:\n            pass\n        try: 1/0\n        except EOFError: pass\n        except TypeError as msg: pass\n        except RuntimeError, msg: pass\n        except: pass\n        else: pass\n        try: 1/0\n        except (EOFError, TypeError, ZeroDivisionError): pass\n        try: 1/0\n        except (EOFError, TypeError, ZeroDivisionError), msg: pass\n        try: pass\n        finally: pass\n\n    def testSuite(self):\n        # simple_stmt | NEWLINE INDENT NEWLINE* (stmt NEWLINE*)+ DEDENT\n        if 1: pass\n        if 1:\n            pass\n        if 1:\n            #\n            #\n            #\n            pass\n            pass\n            #\n            pass\n            #\n\n    def testTest(self):\n        ### and_test ('or' and_test)*\n        ### and_test: not_test ('and' not_test)*\n        ### not_test: 'not' not_test | comparison\n        if not 1: pass\n        if 1 and 1: pass\n        if 1 or 1: pass\n        if not not not 1: pass\n        if not 1 and 1 and 1: pass\n        if 1 and 1 or 1 and 1 and 1 or not 1 and 1: pass\n\n    def testComparison(self):\n        ### comparison: expr (comp_op expr)*\n        ### comp_op: '<'|'>'|'=='|'>='|'<='|'<>'|'!='|'in'|'not' 'in'|'is'|'is' 'not'\n        if 1: pass\n        x = (1 == 1)\n        if 1 == 1: pass\n        if 1 != 1: pass\n        if 1 <> 1: pass\n        if 1 < 1: pass\n        if 1 > 1: pass\n        if 1 <= 1: pass\n        if 1 >= 1: pass\n        if 1 is 1: pass\n        if 1 is not 1: pass\n        if 1 in (): pass\n        if 1 not in (): pass\n        if 1 < 1 > 1 == 1 >= 1 <= 1 <> 1 != 1 in 1 not in 1 is 1 is not 1: pass\n\n    def testBinaryMaskOps(self):\n        x = 1 & 1\n        x = 1 ^ 1\n        x = 1 | 1\n\n    def testShiftOps(self):\n        x = 1 << 1\n        x = 1 >> 1\n        x = 1 << 1 >> 1\n\n    def testAdditiveOps(self):\n        x = 1\n        x = 1 + 1\n        x = 1 - 1 - 1\n        x = 1 - 1 + 1 - 1 + 1\n\n    def testMultiplicativeOps(self):\n        x = 1 * 1\n        x = 1 / 1\n        x = 1 % 1\n        x = 1 / 1 * 1 % 1\n\n    def testUnaryOps(self):\n        x = +1\n        x = -1\n        x = ~1\n        x = ~1 ^ 1 & 1 | 1 & 1 ^ -1\n        x = -1*1/1 + 1*1 - ---1*1\n\n    def testSelectors(self):\n        ### trailer: '(' [testlist] ')' | '[' subscript ']' | '.' NAME\n        ### subscript: expr | [expr] ':' [expr]\n\n        import sys, time\n        c = sys.path[0]\n        x = time.time()\n        x = sys.modules['time'].time()\n        a = '01234'\n        c = a[0]\n        c = a[-1]\n        s = a[0:5]\n        s = a[:5]\n        s = a[0:]\n        s = a[:]\n        s = a[-5:]\n        s = a[:-1]\n        s = a[-4:-3]\n        # A rough test of SF bug 1333982.  http://python.org/sf/1333982\n        # The testing here is fairly incomplete.\n        # Test cases should include: commas with 1 and 2 colons\n        d = {}\n        d[1] = 1\n        d[1,] = 2\n        d[1,2] = 3\n        d[1,2,3] = 4\n        L = list(d)\n        L.sort()\n        self.assertEquals(str(L), '[1, (1,), (1, 2), (1, 2, 3)]')\n\n    def testAtoms(self):\n        ### atom: '(' [testlist] ')' | '[' [testlist] ']' | '{' [dictmaker] '}' | '`' testlist '`' | NAME | NUMBER | STRING\n        ### dictmaker: test ':' test (',' test ':' test)* [',']\n\n        x = (1)\n        x = (1 or 2 or 3)\n        x = (1 or 2 or 3, 2, 3)\n\n        x = []\n        x = [1]\n        x = [1 or 2 or 3]\n        x = [1 or 2 or 3, 2, 3]\n        x = []\n\n        x = {}\n        x = {'one': 1}\n        x = {'one': 1,}\n        x = {'one' or 'two': 1 or 2}\n        x = {'one': 1, 'two': 2}\n        x = {'one': 1, 'two': 2,}\n        x = {'one': 1, 'two': 2, 'three': 3, 'four': 4, 'five': 5, 'six': 6}\n\n        x = `x`\n        x = `1 or 2 or 3`\n        self.assertEqual(`1,2`, '(1, 2)')\n\n        x = x\n        x = 'x'\n        x = 123\n\n    ### exprlist: expr (',' expr)* [',']\n    ### testlist: test (',' test)* [',']\n    # These have been exercised enough above\n\n    def testClassdef(self):\n        # 'class' NAME ['(' [testlist] ')'] ':' suite\n        class B: pass\n        class B2(): pass\n        class C1(B): pass\n        class C2(B): pass\n        class D(C1, C2, B): pass\n        class C:\n            def meth1(self): pass\n            def meth2(self, arg): pass\n            def meth3(self, a1, a2): pass\n        # decorator: '@' dotted_name [ '(' [arglist] ')' ] NEWLINE\n        # decorators: decorator+\n        # decorated: decorators (classdef | funcdef)\n        def class_decorator(x):\n            x.decorated = True\n            return x\n        @class_decorator\n        class G:\n            pass\n        self.assertEqual(G.decorated, True)\n\n    def testListcomps(self):\n        # list comprehension tests\n        nums = [1, 2, 3, 4, 5]\n        strs = [\"Apple\", \"Banana\", \"Coconut\"]\n        spcs = [\"  Apple\", \" Banana \", \"Coco  nut  \"]\n\n        self.assertEqual([s.strip() for s in spcs], ['Apple', 'Banana', 'Coco  nut'])\n        self.assertEqual([3 * x for x in nums], [3, 6, 9, 12, 15])\n        self.assertEqual([x for x in nums if x > 2], [3, 4, 5])\n        self.assertEqual([(i, s) for i in nums for s in strs],\n                         [(1, 'Apple'), (1, 'Banana'), (1, 'Coconut'),\n                          (2, 'Apple'), (2, 'Banana'), (2, 'Coconut'),\n                          (3, 'Apple'), (3, 'Banana'), (3, 'Coconut'),\n                          (4, 'Apple'), (4, 'Banana'), (4, 'Coconut'),\n                          (5, 'Apple'), (5, 'Banana'), (5, 'Coconut')])\n        self.assertEqual([(i, s) for i in nums for s in [f for f in strs if \"n\" in f]],\n                         [(1, 'Banana'), (1, 'Coconut'), (2, 'Banana'), (2, 'Coconut'),\n                          (3, 'Banana'), (3, 'Coconut'), (4, 'Banana'), (4, 'Coconut'),\n                          (5, 'Banana'), (5, 'Coconut')])\n        self.assertEqual([(lambda a:[a**i for i in range(a+1)])(j) for j in range(5)],\n                         [[1], [1, 1], [1, 2, 4], [1, 3, 9, 27], [1, 4, 16, 64, 256]])\n\n        def test_in_func(l):\n            return [None < x < 3 for x in l if x > 2]\n\n        self.assertEqual(test_in_func(nums), [False, False, False])\n\n        def test_nested_front():\n            self.assertEqual([[y for y in [x, x + 1]] for x in [1,3,5]],\n                             [[1, 2], [3, 4], [5, 6]])\n\n        test_nested_front()\n\n        check_syntax_error(self, \"[i, s for i in nums for s in strs]\")\n        check_syntax_error(self, \"[x if y]\")\n\n        suppliers = [\n          (1, \"Boeing\"),\n          (2, \"Ford\"),\n          (3, \"Macdonalds\")\n        ]\n\n        parts = [\n          (10, \"Airliner\"),\n          (20, \"Engine\"),\n          (30, \"Cheeseburger\")\n        ]\n\n        suppart = [\n          (1, 10), (1, 20), (2, 20), (3, 30)\n        ]\n\n        x = [\n          (sname, pname)\n            for (sno, sname) in suppliers\n              for (pno, pname) in parts\n                for (sp_sno, sp_pno) in suppart\n                  if sno == sp_sno and pno == sp_pno\n        ]\n\n        self.assertEqual(x, [('Boeing', 'Airliner'), ('Boeing', 'Engine'), ('Ford', 'Engine'),\n                             ('Macdonalds', 'Cheeseburger')])\n\n    def testGenexps(self):\n        # generator expression tests\n        g = ([x for x in range(10)] for x in range(1))\n        self.assertEqual(g.next(), [x for x in range(10)])\n        try:\n            g.next()\n            self.fail('should produce StopIteration exception')\n        except StopIteration:\n            pass\n\n        a = 1\n        try:\n            g = (a for d in a)\n            g.next()\n            self.fail('should produce TypeError')\n        except TypeError:\n            pass\n\n        self.assertEqual(list((x, y) for x in 'abcd' for y in 'abcd'), [(x, y) for x in 'abcd' for y in 'abcd'])\n        self.assertEqual(list((x, y) for x in 'ab' for y in 'xy'), [(x, y) for x in 'ab' for y in 'xy'])\n\n        a = [x for x in range(10)]\n        b = (x for x in (y for y in a))\n        self.assertEqual(sum(b), sum([x for x in range(10)]))\n\n        self.assertEqual(sum(x**2 for x in range(10)), sum([x**2 for x in range(10)]))\n        self.assertEqual(sum(x*x for x in range(10) if x%2), sum([x*x for x in range(10) if x%2]))\n        self.assertEqual(sum(x for x in (y for y in range(10))), sum([x for x in range(10)]))\n        self.assertEqual(sum(x for x in (y for y in (z for z in range(10)))), sum([x for x in range(10)]))\n        self.assertEqual(sum(x for x in [y for y in (z for z in range(10))]), sum([x for x in range(10)]))\n        self.assertEqual(sum(x for x in (y for y in (z for z in range(10) if True)) if True), sum([x for x in range(10)]))\n        self.assertEqual(sum(x for x in (y for y in (z for z in range(10) if True) if False) if True), 0)\n        check_syntax_error(self, \"foo(x for x in range(10), 100)\")\n        check_syntax_error(self, \"foo(100, x for x in range(10))\")\n\n    def testComprehensionSpecials(self):\n        # test for outmost iterable precomputation\n        x = 10; g = (i for i in range(x)); x = 5\n        self.assertEqual(len(list(g)), 10)\n\n        # This should hold, since we're only precomputing outmost iterable.\n        x = 10; t = False; g = ((i,j) for i in range(x) if t for j in range(x))\n        x = 5; t = True;\n        self.assertEqual([(i,j) for i in range(10) for j in range(5)], list(g))\n\n        # Grammar allows multiple adjacent 'if's in listcomps and genexps,\n        # even though it's silly. Make sure it works (ifelse broke this.)\n        self.assertEqual([ x for x in range(10) if x % 2 if x % 3 ], [1, 5, 7])\n        self.assertEqual(list(x for x in range(10) if x % 2 if x % 3), [1, 5, 7])\n\n        # verify unpacking single element tuples in listcomp/genexp.\n        self.assertEqual([x for x, in [(4,), (5,), (6,)]], [4, 5, 6])\n        self.assertEqual(list(x for x, in [(7,), (8,), (9,)]), [7, 8, 9])\n\n    def test_with_statement(self):\n        class manager(object):\n            def __enter__(self):\n                return (1, 2)\n            def __exit__(self, *args):\n                pass\n\n        with manager():\n            pass\n        with manager() as x:\n            pass\n        with manager() as (x, y):\n            pass\n        with manager(), manager():\n            pass\n        with manager() as x, manager() as y:\n            pass\n        with manager() as x, manager():\n            pass\n\n    def testIfElseExpr(self):\n        # Test ifelse expressions in various cases\n        def _checkeval(msg, ret):\n            \"helper to check that evaluation of expressions is done correctly\"\n            print x\n            return ret\n\n        self.assertEqual([ x() for x in lambda: True, lambda: False if x() ], [True])\n        self.assertEqual([ x() for x in (lambda: True, lambda: False) if x() ], [True])\n        self.assertEqual([ x(False) for x in (lambda x: False if x else True, lambda x: True if x else False) if x(False) ], [True])\n        self.assertEqual((5 if 1 else _checkeval(\"check 1\", 0)), 5)\n        self.assertEqual((_checkeval(\"check 2\", 0) if 0 else 5), 5)\n        self.assertEqual((5 and 6 if 0 else 1), 1)\n        self.assertEqual(((5 and 6) if 0 else 1), 1)\n        self.assertEqual((5 and (6 if 1 else 1)), 6)\n        self.assertEqual((0 or _checkeval(\"check 3\", 2) if 0 else 3), 3)\n        self.assertEqual((1 or _checkeval(\"check 4\", 2) if 1 else _checkeval(\"check 5\", 3)), 1)\n        self.assertEqual((0 or 5 if 1 else _checkeval(\"check 6\", 3)), 5)\n        self.assertEqual((not 5 if 1 else 1), False)\n        self.assertEqual((not 5 if 0 else 1), 1)\n        self.assertEqual((6 + 1 if 1 else 2), 7)\n        self.assertEqual((6 - 1 if 1 else 2), 5)\n        self.assertEqual((6 * 2 if 1 else 4), 12)\n        self.assertEqual((6 / 2 if 1 else 3), 3)\n        self.assertEqual((6 < 4 if 0 else 2), 2)\n\n    def testStringLiterals(self):\n        x = ''; y = \"\"; self.assert_(len(x) == 0 and x == y)\n        x = '\\''; y = \"'\"; self.assert_(len(x) == 1 and x == y and ord(x) == 39)\n        x = '\"'; y = \"\\\"\"; self.assert_(len(x) == 1 and x == y and ord(x) == 34)\n        x = \"doesn't \\\"shrink\\\" does it\"\n        y = 'doesn\\'t \"shrink\" does it'\n        self.assert_(len(x) == 24 and x == y)\n        x = \"does \\\"shrink\\\" doesn't it\"\n        y = 'does \"shrink\" doesn\\'t it'\n        self.assert_(len(x) == 24 and x == y)\n        x = \"\"\"\nThe \"quick\"\nbrown fox\njumps over\nthe 'lazy' dog.\n\"\"\"\n        y = '\\nThe \"quick\"\\nbrown fox\\njumps over\\nthe \\'lazy\\' dog.\\n'\n        self.assertEquals(x, y)\n        y = '''\nThe \"quick\"\nbrown fox\njumps over\nthe 'lazy' dog.\n'''\n        self.assertEquals(x, y)\n        y = \"\\n\\\nThe \\\"quick\\\"\\n\\\nbrown fox\\n\\\njumps over\\n\\\nthe 'lazy' dog.\\n\\\n\"\n        self.assertEquals(x, y)\n        y = '\\n\\\nThe \\\"quick\\\"\\n\\\nbrown fox\\n\\\njumps over\\n\\\nthe \\'lazy\\' dog.\\n\\\n'\n        self.assertEquals(x, y)",
  "vendor/tree-sitter-python/examples/python2-grammar.py::def_test_main": "def test_main():\n    run_unittest(TokenTests, GrammarTests)\n\nif __name__ == '__main__':\n    test_main()",
  "vendor/tree-sitter-python/examples/compound-statement-without-trailing-newline.py::class_Foo": "class Foo:\n  def bar():\n    print \"hi\"",
  "vendor/tree-sitter-python/examples/python3-grammar.py::header": "# Python test set -- part 1, grammar.\n# This just tests whether the parser accepts them all.\n\n# NOTE: When you run this test as a script from the command line, you\n# get warnings about certain hex/oct constants.  Since those are\n# issued by the parser, you can't suppress them by adding a\n# filterwarnings() call to this module.  Therefore, to shut up the\n# regression test, the filterwarnings() call has been added to\n# regrtest.py.\n\nfrom test.support import run_unittest, check_syntax_error\nimport unittest\nimport sys\n# testing import *\nfrom sys import *",
  "vendor/tree-sitter-python/examples/python3-grammar.py::class_TokenTests": "class TokenTests(unittest.TestCase):\n\n    def testBackslash(self):\n        # Backslash means line continuation:\n        x = 1 \\\n        + 1\n        self.assertEquals(x, 2, 'backslash for line continuation')\n\n        # Backslash does not means continuation in comments :\\\n        x = 0\n        self.assertEquals(x, 0, 'backslash ending comment')\n\n    def testPlainIntegers(self):\n        self.assertEquals(type(000), type(0))\n        self.assertEquals(0xff, 255)\n        self.assertEquals(0o377, 255)\n        self.assertEquals(2147483647, 0o17777777777)\n        self.assertEquals(0b1001, 9)\n        # \"0x\" is not a valid literal\n        self.assertRaises(SyntaxError, eval, \"0x\")\n        from sys import maxsize\n        if maxsize == 2147483647:\n            self.assertEquals(-2147483647-1, -0o20000000000)\n            # XXX -2147483648\n            self.assert_(0o37777777777 > 0)\n            self.assert_(0xffffffff > 0)\n            self.assert_(0b1111111111111111111111111111111 > 0)\n            for s in ('2147483648', '0o40000000000', '0x100000000',\n                      '0b10000000000000000000000000000000'):\n                try:\n                    x = eval(s)\n                except OverflowError:\n                    self.fail(\"OverflowError on huge integer literal %r\" % s)\n        elif maxsize == 9223372036854775807:\n            self.assertEquals(-9223372036854775807-1, -0o1000000000000000000000)\n            self.assert_(0o1777777777777777777777 > 0)\n            self.assert_(0xffffffffffffffff > 0)\n            self.assert_(0b11111111111111111111111111111111111111111111111111111111111111 > 0)\n            for s in '9223372036854775808', '0o2000000000000000000000', \\\n                     '0x10000000000000000', \\\n                     '0b100000000000000000000000000000000000000000000000000000000000000':\n                try:\n                    x = eval(s)\n                except OverflowError:\n                    self.fail(\"OverflowError on huge integer literal %r\" % s)\n        else:\n            self.fail('Weird maxsize value %r' % maxsize)\n\n    def testLongIntegers(self):\n        x = 0\n        x = 0xffffffffffffffff\n        x = 0Xffffffffffffffff\n        x = 0o77777777777777777\n        x = 0O77777777777777777\n        x = 123456789012345678901234567890\n        x = 0b100000000000000000000000000000000000000000000000000000000000000000000\n        x = 0B111111111111111111111111111111111111111111111111111111111111111111111\n\n    def testUnderscoresInNumbers(self):\n        # Integers\n        x = 1_0\n        x = 123_456_7_89\n        x = 0xabc_123_4_5\n        x = 0X_abc_123\n        x = 0B11_01\n        x = 0b_11_01\n        x = 0o45_67\n        x = 0O_45_67\n\n        # Floats\n        x = 3_1.4\n        x = 03_1.4\n        x = 3_1.\n        x = .3_1\n        x = 3.1_4\n        x = 0_3.1_4\n        x = 3e1_4\n        x = 3_1e+4_1\n        x = 3_1E-4_1\n\n    def testFloats(self):\n        x = 3.14\n        x = 314.\n        x = 0.314\n        # XXX x = 000.314\n        x = .314\n        x = 3e14\n        x = 3E14\n        x = 3e-14\n        x = 3e+14\n        x = 3.e14\n        x = .3e14\n        x = 3.1e4\n\n    def testEllipsis(self):\n        x = ...\n        self.assert_(x is Ellipsis)\n        self.assertRaises(SyntaxError, eval, \".. .\")",
  "vendor/tree-sitter-python/examples/python3-grammar.py::class_GrammarTests": "class GrammarTests(unittest.TestCase):\n\n    # single_input: NEWLINE | simple_stmt | compound_stmt NEWLINE\n    # XXX can't test in a script -- this rule is only used when interactive\n\n    # file_input: (NEWLINE | stmt)* ENDMARKER\n    # Being tested as this very moment this very module\n\n    # expr_input: testlist NEWLINE\n    # XXX Hard to test -- used only in calls to input()\n\n    def testEvalInput(self):\n        # testlist ENDMARKER\n        x = eval('1, 0 or 1')\n\n    def testFuncdef(self):\n        ### [decorators] 'def' NAME parameters ['->' test] ':' suite\n        ### decorator: '@' dotted_name [ '(' [arglist] ')' ] NEWLINE\n        ### decorators: decorator+\n        ### parameters: '(' [typedargslist] ')'\n        ### typedargslist: ((tfpdef ['=' test] ',')*\n        ###                ('*' [tfpdef] (',' tfpdef ['=' test])* [',' '**' tfpdef] | '**' tfpdef)\n        ###                | tfpdef ['=' test] (',' tfpdef ['=' test])* [','])\n        ### tfpdef: NAME [':' test]\n        ### varargslist: ((vfpdef ['=' test] ',')*\n        ###              ('*' [vfpdef] (',' vfpdef ['=' test])*  [',' '**' vfpdef] | '**' vfpdef)\n        ###              | vfpdef ['=' test] (',' vfpdef ['=' test])* [','])\n        ### vfpdef: NAME\n        def f1(): pass\n        f1()\n        f1(*())\n        f1(*(), **{})\n        def f2(one_argument): pass\n        def f3(two, arguments): pass\n        self.assertEquals(f2.__code__.co_varnames, ('one_argument',))\n        self.assertEquals(f3.__code__.co_varnames, ('two', 'arguments'))\n        def a1(one_arg,): pass\n        def a2(two, args,): pass\n        def v0(*rest): pass\n        def v1(a, *rest): pass\n        def v2(a, b, *rest): pass\n\n        f1()\n        f2(1)\n        f2(1,)\n        f3(1, 2)\n        f3(1, 2,)\n        v0()\n        v0(1)\n        v0(1,)\n        v0(1,2)\n        v0(1,2,3,4,5,6,7,8,9,0)\n        v1(1)\n        v1(1,)\n        v1(1,2)\n        v1(1,2,3)\n        v1(1,2,3,4,5,6,7,8,9,0)\n        v2(1,2)\n        v2(1,2,3)\n        v2(1,2,3,4)\n        v2(1,2,3,4,5,6,7,8,9,0)\n\n        def d01(a=1): pass\n        d01()\n        d01(1)\n        d01(*(1,))\n        d01(**{'a':2})\n        def d11(a, b=1): pass\n        d11(1)\n        d11(1, 2)\n        d11(1, **{'b':2})\n        def d21(a, b, c=1): pass\n        d21(1, 2)\n        d21(1, 2, 3)\n        d21(*(1, 2, 3))\n        d21(1, *(2, 3))\n        d21(1, 2, *(3,))\n        d21(1, 2, **{'c':3})\n        def d02(a=1, b=2): pass\n        d02()\n        d02(1)\n        d02(1, 2)\n        d02(*(1, 2))\n        d02(1, *(2,))\n        d02(1, **{'b':2})\n        d02(**{'a': 1, 'b': 2})\n        def d12(a, b=1, c=2): pass\n        d12(1)\n        d12(1, 2)\n        d12(1, 2, 3)\n        def d22(a, b, c=1, d=2): pass\n        d22(1, 2)\n        d22(1, 2, 3)\n        d22(1, 2, 3, 4)\n        def d01v(a=1, *rest): pass\n        d01v()\n        d01v(1)\n        d01v(1, 2)\n        d01v(*(1, 2, 3, 4))\n        d01v(*(1,))\n        d01v(**{'a':2})\n        def d11v(a, b=1, *rest): pass\n        d11v(1)\n        d11v(1, 2)\n        d11v(1, 2, 3)\n        def d21v(a, b, c=1, *rest): pass\n        d21v(1, 2)\n        d21v(1, 2, 3)\n        d21v(1, 2, 3, 4)\n        d21v(*(1, 2, 3, 4))\n        d21v(1, 2, **{'c': 3})\n        def d02v(a=1, b=2, *rest): pass\n        d02v()\n        d02v(1)\n        d02v(1, 2)\n        d02v(1, 2, 3)\n        d02v(1, *(2, 3, 4))\n        d02v(**{'a': 1, 'b': 2})\n        def d12v(a, b=1, c=2, *rest): pass\n        d12v(1)\n        d12v(1, 2)\n        d12v(1, 2, 3)\n        d12v(1, 2, 3, 4)\n        d12v(*(1, 2, 3, 4))\n        d12v(1, 2, *(3, 4, 5))\n        d12v(1, *(2,), **{'c': 3})\n        def d22v(a, b, c=1, d=2, *rest): pass\n        d22v(1, 2)\n        d22v(1, 2, 3)\n        d22v(1, 2, 3, 4)\n        d22v(1, 2, 3, 4, 5)\n        d22v(*(1, 2, 3, 4))\n        d22v(1, 2, *(3, 4, 5))\n        d22v(1, *(2, 3), **{'d': 4})\n\n        # keyword argument type tests\n        try:\n            str('x', **{b'foo':1 })\n        except TypeError:\n            pass\n        else:\n            self.fail('Bytes should not work as keyword argument names')\n        # keyword only argument tests\n        def pos0key1(*, key): return key\n        pos0key1(key=100)\n        def pos2key2(p1, p2, *, k1, k2=100): return p1,p2,k1,k2\n        pos2key2(1, 2, k1=100)\n        pos2key2(1, 2, k1=100, k2=200)\n        pos2key2(1, 2, k2=100, k1=200)\n        def pos2key2dict(p1, p2, *, k1=100, k2, **kwarg): return p1,p2,k1,k2,kwarg\n        pos2key2dict(1,2,k2=100,tokwarg1=100,tokwarg2=200)\n        pos2key2dict(1,2,tokwarg1=100,tokwarg2=200, k2=100)\n\n        # keyword arguments after *arglist\n        def f(*args, **kwargs):\n            return args, kwargs\n        self.assertEquals(f(1, x=2, *[3, 4], y=5), ((1, 3, 4),\n                                                    {'x':2, 'y':5}))\n        self.assertRaises(SyntaxError, eval, \"f(1, *(2,3), 4)\")\n        self.assertRaises(SyntaxError, eval, \"f(1, x=2, *(3,4), x=5)\")\n\n        # argument annotation tests\n        def f(x) -> list: pass\n        self.assertEquals(f.__annotations__, {'return': list})\n        def f(x:int): pass\n        self.assertEquals(f.__annotations__, {'x': int})\n        def f(*x:str): pass\n        self.assertEquals(f.__annotations__, {'x': str})\n        def f(**x:float): pass\n        self.assertEquals(f.__annotations__, {'x': float})\n        def f(x, y:1+2): pass\n        self.assertEquals(f.__annotations__, {'y': 3})\n        def f(a, b:1, c:2, d): pass\n        self.assertEquals(f.__annotations__, {'b': 1, 'c': 2})\n        def f(a, b:1, c:2, d, e:3=4, f=5, *g:6): pass\n        self.assertEquals(f.__annotations__,\n                          {'b': 1, 'c': 2, 'e': 3, 'g': 6})\n        def f(a, b:1, c:2, d, e:3=4, f=5, *g:6, h:7, i=8, j:9=10,\n              **k:11) -> 12: pass\n        self.assertEquals(f.__annotations__,\n                          {'b': 1, 'c': 2, 'e': 3, 'g': 6, 'h': 7, 'j': 9,\n                           'k': 11, 'return': 12})\n        # Check for SF Bug #1697248 - mixing decorators and a return annotation\n        def null(x): return x\n        @null\n        def f(x) -> list: pass\n        self.assertEquals(f.__annotations__, {'return': list})\n\n        # test closures with a variety of oparg's\n        closure = 1\n        def f(): return closure\n        def f(x=1): return closure\n        def f(*, k=1): return closure\n        def f() -> int: return closure\n\n        # Check ast errors in *args and *kwargs\n        check_syntax_error(self, \"f(*g(1=2))\")\n        check_syntax_error(self, \"f(**g(1=2))\")\n\n    def testLambdef(self):\n        ### lambdef: 'lambda' [varargslist] ':' test\n        l1 = lambda : 0\n        self.assertEquals(l1(), 0)\n        l2 = lambda : a[d] # XXX just testing the expression\n        l3 = lambda : [2 < x for x in [-1, 3, 0]]\n        self.assertEquals(l3(), [0, 1, 0])\n        l4 = lambda x = lambda y = lambda z=1 : z : y() : x()\n        self.assertEquals(l4(), 1)\n        l5 = lambda x, y, z=2: x + y + z\n        self.assertEquals(l5(1, 2), 5)\n        self.assertEquals(l5(1, 2, 3), 6)\n        check_syntax_error(self, \"lambda x: x = 2\")\n        check_syntax_error(self, \"lambda (None,): None\")\n        l6 = lambda x, y, *, k=20: x+y+k\n        self.assertEquals(l6(1,2), 1+2+20)\n        self.assertEquals(l6(1,2,k=10), 1+2+10)\n\n\n    ### stmt: simple_stmt | compound_stmt\n    # Tested below\n\n    def testSimpleStmt(self):\n        ### simple_stmt: small_stmt (';' small_stmt)* [';']\n        x = 1; pass; del x\n        def foo():\n            # verify statements that end with semi-colons\n            x = 1; pass; del x;\n        foo()\n\n    ### small_stmt: expr_stmt | pass_stmt | del_stmt | flow_stmt | import_stmt | global_stmt | access_stmt\n    # Tested below\n\n    def testExprStmt(self):\n        # (exprlist '=')* exprlist\n        1\n        1, 2, 3\n        x = 1\n        x = 1, 2, 3\n        x = y = z = 1, 2, 3\n        x, y, z = 1, 2, 3\n        abc = a, b, c = x, y, z = xyz = 1, 2, (3, 4)\n\n        check_syntax_error(self, \"x + 1 = 1\")\n        check_syntax_error(self, \"a + 1 = b + 2\")\n\n    def testDelStmt(self):\n        # 'del' exprlist\n        abc = [1,2,3]\n        x, y, z = abc\n        xyz = x, y, z\n\n        del abc\n        del x, y, (z, xyz)\n\n    def testPassStmt(self):\n        # 'pass'\n        pass\n\n    # flow_stmt: break_stmt | continue_stmt | return_stmt | raise_stmt\n    # Tested below\n\n    def testBreakStmt(self):\n        # 'break'\n        while 1: break\n\n    def testContinueStmt(self):\n        # 'continue'\n        i = 1\n        while i: i = 0; continue\n\n        msg = \"\"\n        while not msg:\n            msg = \"ok\"\n            try:\n                continue\n                msg = \"continue failed to continue inside try\"\n            except:\n                msg = \"continue inside try called except block\"\n        if msg != \"ok\":\n            self.fail(msg)\n\n        msg = \"\"\n        while not msg:\n            msg = \"finally block not called\"\n            try:\n                continue\n            finally:\n                msg = \"ok\"\n        if msg != \"ok\":\n            self.fail(msg)\n\n    def test_break_continue_loop(self):\n        # This test warrants an explanation. It is a test specifically for SF bugs\n        # #463359 and #462937. The bug is that a 'break' statement executed or\n        # exception raised inside a try/except inside a loop, *after* a continue\n        # statement has been executed in that loop, will cause the wrong number of\n        # arguments to be popped off the stack and the instruction pointer reset to\n        # a very small number (usually 0.) Because of this, the following test\n        # *must* written as a function, and the tracking vars *must* be function\n        # arguments with default values. Otherwise, the test will loop and loop.\n\n        def test_inner(extra_burning_oil = 1, count=0):\n            big_hippo = 2\n            while big_hippo:\n                count += 1\n                try:\n                    if extra_burning_oil and big_hippo == 1:\n                        extra_burning_oil -= 1\n                        break\n                    big_hippo -= 1\n                    continue\n                except:\n                    raise\n            if count > 2 or big_hippo != 1:\n                self.fail(\"continue then break in try/except in loop broken!\")\n        test_inner()\n\n    def testReturn(self):\n        # 'return' [testlist]\n        def g1(): return\n        def g2(): return 1\n        g1()\n        x = g2()\n        check_syntax_error(self, \"class foo:return 1\")\n\n    def testYield(self):\n        check_syntax_error(self, \"class foo:yield 1\")\n\n    def testRaise(self):\n        # 'raise' test [',' test]\n        try: raise RuntimeError('just testing')\n        except RuntimeError: pass\n        try: raise KeyboardInterrupt\n        except KeyboardInterrupt: pass\n\n    def testImport(self):\n        # 'import' dotted_as_names\n        import sys\n        import time, sys\n        # 'from' dotted_name 'import' ('*' | '(' import_as_names ')' | import_as_names)\n        from time import time\n        from time import (time)\n        # not testable inside a function, but already done at top of the module\n        # from sys import *\n        from sys import path, argv\n        from sys import (path, argv)\n        from sys import (path, argv,)\n\n    def testGlobal(self):\n        # 'global' NAME (',' NAME)*\n        global a\n        global a, b\n        global one, two, three, four, five, six, seven, eight, nine, ten\n\n    def testNonlocal(self):\n        # 'nonlocal' NAME (',' NAME)*\n        x = 0\n        y = 0\n        def f():\n            nonlocal x\n            nonlocal x, y\n\n    def testAssert(self):\n        # assert_stmt: 'assert' test [',' test]\n        assert 1\n        assert 1, 1\n        assert lambda x:x\n        assert 1, lambda x:x+1\n        try:\n            assert 0, \"msg\"\n        except AssertionError as e:\n            self.assertEquals(e.args[0], \"msg\")\n        else:\n            if __debug__:\n                self.fail(\"AssertionError not raised by assert 0\")\n\n    ### compound_stmt: if_stmt | while_stmt | for_stmt | try_stmt | funcdef | classdef\n    # Tested below\n\n    def testIf(self):\n        # 'if' test ':' suite ('elif' test ':' suite)* ['else' ':' suite]\n        if 1: pass\n        if 1: pass\n        else: pass\n        if 0: pass\n        elif 0: pass\n        if 0: pass\n        elif 0: pass\n        elif 0: pass\n        elif 0: pass\n        else: pass\n\n    def testWhile(self):\n        # 'while' test ':' suite ['else' ':' suite]\n        while 0: pass\n        while 0: pass\n        else: pass\n\n        # Issue1920: \"while 0\" is optimized away,\n        # ensure that the \"else\" clause is still present.\n        x = 0\n        while 0:\n            x = 1\n        else:\n            x = 2\n        self.assertEquals(x, 2)\n\n    def testFor(self):\n        # 'for' exprlist 'in' exprlist ':' suite ['else' ':' suite]\n        for i in 1, 2, 3: pass\n        for i, j, k in (): pass\n        else: pass\n        class Squares:\n            def __init__(self, max):\n                self.max = max\n                self.sofar = []\n            def __len__(self): return len(self.sofar)\n            def __getitem__(self, i):\n                if not 0 <= i < self.max: raise IndexError\n                n = len(self.sofar)\n                while n <= i:\n                    self.sofar.append(n*n)\n                    n = n+1\n                return self.sofar[i]\n        n = 0\n        for x in Squares(10): n = n+x\n        if n != 285:\n            self.fail('for over growing sequence')\n\n        result = []\n        for x, in [(1,), (2,), (3,)]:\n            result.append(x)\n        self.assertEqual(result, [1, 2, 3])\n\n    def testTry(self):\n        ### try_stmt: 'try' ':' suite (except_clause ':' suite)+ ['else' ':' suite]\n        ###         | 'try' ':' suite 'finally' ':' suite\n        ### except_clause: 'except' [expr ['as' expr]]\n        try:\n            1/0\n        except ZeroDivisionError:\n            pass\n        else:\n            pass\n        try: 1/0\n        except EOFError: pass\n        except TypeError as msg: pass\n        except RuntimeError as msg: pass\n        except: pass\n        else: pass\n        try: 1/0\n        except (EOFError, TypeError, ZeroDivisionError): pass\n        try: 1/0\n        except (EOFError, TypeError, ZeroDivisionError) as msg: pass\n        try: pass\n        finally: pass\n\n    def testSuite(self):\n        # simple_stmt | NEWLINE INDENT NEWLINE* (stmt NEWLINE*)+ DEDENT\n        if 1: pass\n        if 1:\n            pass\n        if 1:\n            #\n            #\n            #\n            pass\n            pass\n            #\n            pass\n            #\n\n    def testTest(self):\n        ### and_test ('or' and_test)*\n        ### and_test: not_test ('and' not_test)*\n        ### not_test: 'not' not_test | comparison\n        if not 1: pass\n        if 1 and 1: pass\n        if 1 or 1: pass\n        if not not not 1: pass\n        if not 1 and 1 and 1: pass\n        if 1 and 1 or 1 and 1 and 1 or not 1 and 1: pass\n\n    def testComparison(self):\n        ### comparison: expr (comp_op expr)*\n        ### comp_op: '<'|'>'|'=='|'>='|'<='|'!='|'in'|'not' 'in'|'is'|'is' 'not'\n        if 1: pass\n        x = (1 == 1)\n        if 1 == 1: pass\n        if 1 != 1: pass\n        if 1 < 1: pass\n        if 1 > 1: pass\n        if 1 <= 1: pass\n        if 1 >= 1: pass\n        if 1 is 1: pass\n        if 1 is not 1: pass\n        if 1 in (): pass\n        if 1 not in (): pass\n        if 1 < 1 > 1 == 1 >= 1 <= 1 != 1 in 1 not in 1 is 1 is not 1: pass\n\n    def testBinaryMaskOps(self):\n        x = 1 & 1\n        x = 1 ^ 1\n        x = 1 | 1\n\n    def testShiftOps(self):\n        x = 1 << 1\n        x = 1 >> 1\n        x = 1 << 1 >> 1\n\n    def testAdditiveOps(self):\n        x = 1\n        x = 1 + 1\n        x = 1 - 1 - 1\n        x = 1 - 1 + 1 - 1 + 1\n\n    def testMultiplicativeOps(self):\n        x = 1 * 1\n        x = 1 / 1\n        x = 1 % 1\n        x = 1 / 1 * 1 % 1\n\n    def testUnaryOps(self):\n        x = +1\n        x = -1\n        x = ~1\n        x = ~1 ^ 1 & 1 | 1 & 1 ^ -1\n        x = -1*1/1 + 1*1 - ---1*1\n\n    def testSelectors(self):\n        ### trailer: '(' [testlist] ')' | '[' subscript ']' | '.' NAME\n        ### subscript: expr | [expr] ':' [expr]\n\n        import sys, time\n        c = sys.path[0]\n        x = time.time()\n        x = sys.modules['time'].time()\n        a = '01234'\n        c = a[0]\n        c = a[-1]\n        s = a[0:5]\n        s = a[:5]\n        s = a[0:]\n        s = a[:]\n        s = a[-5:]\n        s = a[:-1]\n        s = a[-4:-3]\n        # A rough test of SF bug 1333982.  http://python.org/sf/1333982\n        # The testing here is fairly incomplete.\n        # Test cases should include: commas with 1 and 2 colons\n        d = {}\n        d[1] = 1\n        d[1,] = 2\n        d[1,2] = 3\n        d[1,2,3] = 4\n        L = list(d)\n        L.sort(key=lambda x: x if isinstance(x, tuple) else ())\n        self.assertEquals(str(L), '[1, (1,), (1, 2), (1, 2, 3)]')\n\n    def testAtoms(self):\n        ### atom: '(' [testlist] ')' | '[' [testlist] ']' | '{' [dictsetmaker] '}' | NAME | NUMBER | STRING\n        ### dictsetmaker: (test ':' test (',' test ':' test)* [',']) | (test (',' test)* [','])\n\n        x = (1)\n        x = (1 or 2 or 3)\n        x = (1 or 2 or 3, 2, 3)\n\n        x = []\n        x = [1]\n        x = [1 or 2 or 3]\n        x = [1 or 2 or 3, 2, 3]\n        x = []\n\n        x = {}\n        x = {'one': 1}\n        x = {'one': 1,}\n        x = {'one' or 'two': 1 or 2}\n        x = {'one': 1, 'two': 2}\n        x = {'one': 1, 'two': 2,}\n        x = {'one': 1, 'two': 2, 'three': 3, 'four': 4, 'five': 5, 'six': 6}\n\n        x = {'one'}\n        x = {'one', 1,}\n        x = {'one', 'two', 'three'}\n        x = {2, 3, 4,}\n\n        x = x\n        x = 'x'\n        x = 123\n\n    ### exprlist: expr (',' expr)* [',']\n    ### testlist: test (',' test)* [',']\n    # These have been exercised enough above\n\n    def testClassdef(self):\n        # 'class' NAME ['(' [testlist] ')'] ':' suite\n        class B: pass\n        class B2(): pass\n        class C1(B): pass\n        class C2(B): pass\n        class D(C1, C2, B): pass\n        class C:\n            def meth1(self): pass\n            def meth2(self, arg): pass\n            def meth3(self, a1, a2): pass\n\n        # decorator: '@' dotted_name [ '(' [arglist] ')' ] NEWLINE\n        # decorators: decorator+\n        # decorated: decorators (classdef | funcdef)\n        def class_decorator(x): return x\n        @class_decorator\n        class G: pass\n\n    def testDictcomps(self):\n        # dictorsetmaker: ( (test ':' test (comp_for |\n        #                                   (',' test ':' test)* [','])) |\n        #                   (test (comp_for | (',' test)* [','])) )\n        nums = [1, 2, 3]\n        self.assertEqual({i:i+1 for i in nums}, {1: 2, 2: 3, 3: 4})\n\n    def testListcomps(self):\n        # list comprehension tests\n        nums = [1, 2, 3, 4, 5]\n        strs = [\"Apple\", \"Banana\", \"Coconut\"]\n        spcs = [\"  Apple\", \" Banana \", \"Coco  nut  \"]\n\n        self.assertEqual([s.strip() for s in spcs], ['Apple', 'Banana', 'Coco  nut'])\n        self.assertEqual([3 * x for x in nums], [3, 6, 9, 12, 15])\n        self.assertEqual([x for x in nums if x > 2], [3, 4, 5])\n        self.assertEqual([(i, s) for i in nums for s in strs],\n                         [(1, 'Apple'), (1, 'Banana'), (1, 'Coconut'),\n                          (2, 'Apple'), (2, 'Banana'), (2, 'Coconut'),\n                          (3, 'Apple'), (3, 'Banana'), (3, 'Coconut'),\n                          (4, 'Apple'), (4, 'Banana'), (4, 'Coconut'),\n                          (5, 'Apple'), (5, 'Banana'), (5, 'Coconut')])\n        self.assertEqual([(i, s) for i in nums for s in [f for f in strs if \"n\" in f]],\n                         [(1, 'Banana'), (1, 'Coconut'), (2, 'Banana'), (2, 'Coconut'),\n                          (3, 'Banana'), (3, 'Coconut'), (4, 'Banana'), (4, 'Coconut'),\n                          (5, 'Banana'), (5, 'Coconut')])\n        self.assertEqual([(lambda a:[a**i for i in range(a+1)])(j) for j in range(5)],\n                         [[1], [1, 1], [1, 2, 4], [1, 3, 9, 27], [1, 4, 16, 64, 256]])\n\n        def test_in_func(l):\n            return [0 < x < 3 for x in l if x > 2]\n\n        self.assertEqual(test_in_func(nums), [False, False, False])\n\n        def test_nested_front():\n            self.assertEqual([[y for y in [x, x + 1]] for x in [1,3,5]],\n                             [[1, 2], [3, 4], [5, 6]])\n\n        test_nested_front()\n\n        check_syntax_error(self, \"[i, s for i in nums for s in strs]\")\n        check_syntax_error(self, \"[x if y]\")\n\n        suppliers = [\n          (1, \"Boeing\"),\n          (2, \"Ford\"),\n          (3, \"Macdonalds\")\n        ]\n\n        parts = [\n          (10, \"Airliner\"),\n          (20, \"Engine\"),\n          (30, \"Cheeseburger\")\n        ]\n\n        suppart = [\n          (1, 10), (1, 20), (2, 20), (3, 30)\n        ]\n\n        x = [\n          (sname, pname)\n            for (sno, sname) in suppliers\n              for (pno, pname) in parts\n                for (sp_sno, sp_pno) in suppart\n                  if sno == sp_sno and pno == sp_pno\n        ]\n\n        self.assertEqual(x, [('Boeing', 'Airliner'), ('Boeing', 'Engine'), ('Ford', 'Engine'),\n                             ('Macdonalds', 'Cheeseburger')])\n\n    def testGenexps(self):\n        # generator expression tests\n        g = ([x for x in range(10)] for x in range(1))\n        self.assertEqual(next(g), [x for x in range(10)])\n        try:\n            next(g)\n            self.fail('should produce StopIteration exception')\n        except StopIteration:\n            pass\n\n        a = 1\n        try:\n            g = (a for d in a)\n            next(g)\n            self.fail('should produce TypeError')\n        except TypeError:\n            pass\n\n        self.assertEqual(list((x, y) for x in 'abcd' for y in 'abcd'), [(x, y) for x in 'abcd' for y in 'abcd'])\n        self.assertEqual(list((x, y) for x in 'ab' for y in 'xy'), [(x, y) for x in 'ab' for y in 'xy'])\n\n        a = [x for x in range(10)]\n        b = (x for x in (y for y in a))\n        self.assertEqual(sum(b), sum([x for x in range(10)]))\n\n        self.assertEqual(sum(x**2 for x in range(10)), sum([x**2 for x in range(10)]))\n        self.assertEqual(sum(x*x for x in range(10) if x%2), sum([x*x for x in range(10) if x%2]))\n        self.assertEqual(sum(x for x in (y for y in range(10))), sum([x for x in range(10)]))\n        self.assertEqual(sum(x for x in (y for y in (z for z in range(10)))), sum([x for x in range(10)]))\n        self.assertEqual(sum(x for x in [y for y in (z for z in range(10))]), sum([x for x in range(10)]))\n        self.assertEqual(sum(x for x in (y for y in (z for z in range(10) if True)) if True), sum([x for x in range(10)]))\n        self.assertEqual(sum(x for x in (y for y in (z for z in range(10) if True) if False) if True), 0)\n        check_syntax_error(self, \"foo(x for x in range(10), 100)\")\n        check_syntax_error(self, \"foo(100, x for x in range(10))\")\n\n    def testComprehensionSpecials(self):\n        # test for outmost iterable precomputation\n        x = 10; g = (i for i in range(x)); x = 5\n        self.assertEqual(len(list(g)), 10)\n\n        # This should hold, since we're only precomputing outmost iterable.\n        x = 10; t = False; g = ((i,j) for i in range(x) if t for j in range(x))\n        x = 5; t = True;\n        self.assertEqual([(i,j) for i in range(10) for j in range(5)], list(g))\n\n        # Grammar allows multiple adjacent 'if's in listcomps and genexps,\n        # even though it's silly. Make sure it works (ifelse broke this.)\n        self.assertEqual([ x for x in range(10) if x % 2 if x % 3 ], [1, 5, 7])\n        self.assertEqual(list(x for x in range(10) if x % 2 if x % 3), [1, 5, 7])\n\n        # verify unpacking single element tuples in listcomp/genexp.\n        self.assertEqual([x for x, in [(4,), (5,), (6,)]], [4, 5, 6])\n        self.assertEqual(list(x for x, in [(7,), (8,), (9,)]), [7, 8, 9])\n\n    def test_with_statement(self):\n        class manager(object):\n            def __enter__(self):\n                return (1, 2)\n            def __exit__(self, *args):\n                pass\n\n        with manager():\n            pass\n        with manager() as x:\n            pass\n        with manager() as (x, y):\n            pass\n        with manager(), manager():\n            pass\n        with manager() as x, manager() as y:\n            pass\n        with manager() as x, manager():\n            pass\n\n    def testIfElseExpr(self):\n        # Test ifelse expressions in various cases\n        def _checkeval(msg, ret):\n            \"helper to check that evaluation of expressions is done correctly\"\n            print(x)\n            return ret\n\n        # the next line is not allowed anymore\n        #self.assertEqual([ x() for x in lambda: True, lambda: False if x() ], [True])\n        self.assertEqual([ x() for x in (lambda: True, lambda: False) if x() ], [True])\n        self.assertEqual([ x(False) for x in (lambda x: False if x else True, lambda x: True if x else False) if x(False) ], [True])\n        self.assertEqual((5 if 1 else _checkeval(\"check 1\", 0)), 5)\n        self.assertEqual((_checkeval(\"check 2\", 0) if 0 else 5), 5)\n        self.assertEqual((5 and 6 if 0 else 1), 1)\n        self.assertEqual(((5 and 6) if 0 else 1), 1)\n        self.assertEqual((5 and (6 if 1 else 1)), 6)\n        self.assertEqual((0 or _checkeval(\"check 3\", 2) if 0 else 3), 3)\n        self.assertEqual((1 or _checkeval(\"check 4\", 2) if 1 else _checkeval(\"check 5\", 3)), 1)\n        self.assertEqual((0 or 5 if 1 else _checkeval(\"check 6\", 3)), 5)\n        self.assertEqual((not 5 if 1 else 1), False)\n        self.assertEqual((not 5 if 0 else 1), 1)\n        self.assertEqual((6 + 1 if 1 else 2), 7)\n        self.assertEqual((6 - 1 if 1 else 2), 5)\n        self.assertEqual((6 * 2 if 1 else 4), 12)\n        self.assertEqual((6 / 2 if 1 else 3), 3)\n        self.assertEqual((6 < 4 if 0 else 2), 2)\n\n    def testStringLiterals(self):\n        x = ''; y = \"\"; self.assert_(len(x) == 0 and x == y)\n        x = '\\''; y = \"'\"; self.assert_(len(x) == 1 and x == y and ord(x) == 39)\n        x = '\"'; y = \"\\\"\"; self.assert_(len(x) == 1 and x == y and ord(x) == 34)\n        x = \"doesn't \\\"shrink\\\" does it\"\n        y = 'doesn\\'t \"shrink\" does it'\n        self.assert_(len(x) == 24 and x == y)\n        x = \"does \\\"shrink\\\" doesn't it\"\n        y = 'does \"shrink\" doesn\\'t it'\n        self.assert_(len(x) == 24 and x == y)\n        x = f\"\"\"\nThe \"quick\"\nbrown fo{ok()}x\njumps over\nthe 'lazy' dog.\n\"\"\"\n        y = '\\nThe \"quick\"\\nbrown fox\\njumps over\\nthe \\'lazy\\' dog.\\n'\n        self.assertEquals(x, y)\n        y = '''\nThe \"quick\"\nbrown fox\njumps over\nthe 'lazy' dog.\n'''\n        self.assertEquals(x, y)\n        y = \"\\n\\\nThe \\\"quick\\\"\\n\\\nbrown fox\\n\\\njumps over\\n\\\nthe 'lazy' dog.\\n\\\n\"\n        self.assertEquals(x, y)\n        y = '\\n\\\nThe \\\"quick\\\"\\n\\\nbrown fox\\n\\\njumps over\\n\\\nthe \\'lazy\\' dog.\\n\\\n'\n        self.assertEquals(x, y)",
  "vendor/tree-sitter-python/examples/python3-grammar.py::def_test_main": "def test_main():\n    run_unittest(TokenTests, GrammarTests)\n\nif __name__ == '__main__':\n    test_main()",
  "vendor/tree-sitter-python/examples/python3.8_grammar.py::header": "# Python test set -- part 1, grammar.\n# This just tests whether the parser accepts them all.\n\nfrom test.support import check_syntax_error\nimport inspect\nimport unittest\nimport sys\n# testing import *\nfrom sys import *\n\n# different import patterns to check that __annotations__ does not interfere\n# with import machinery\nimport test.ann_module as ann_module\nimport typing\nfrom collections import ChainMap\nfrom test import ann_module2\nimport test\n\n# These are shared with test_tokenize and other test modules.\n#\n# Note: since several test cases filter out floats by looking for \"e\" and \".\",\n# don't add hexadecimal literals that contain \"e\" or \"E\".\nVALID_UNDERSCORE_LITERALS = [\n    '0_0_0',\n    '4_2',\n    '1_0000_0000',\n    '0b1001_0100',\n    '0xffff_ffff',\n    '0o5_7_7',\n    '1_00_00.5',\n    '1_00_00.5e5',\n    '1_00_00e5_1',\n    '1e1_0',\n    '.1_4',\n    '.1_4e1',\n    '0b_0',\n    '0x_f',\n    '0o_5',\n    '1_00_00j',\n    '1_00_00.5j',\n    '1_00_00e5_1j',\n    '.1_4j',\n    '(1_2.5+3_3j)',\n    '(.5_6j)',\n]\nINVALID_UNDERSCORE_LITERALS = [\n    # Trailing underscores:\n    '0_',\n    '42_',\n    '1.4j_',\n    '0x_',\n    '0b1_',\n    '0xf_',\n    '0o5_',\n    '0 if 1_Else 1',\n    # Underscores in the base selector:\n    '0_b0',\n    '0_xf',\n    '0_o5',\n    # Old-style octal, still disallowed:\n    '0_7',\n    '09_99',\n    # Multiple consecutive underscores:\n    '4_______2',\n    '0.1__4',\n    '0.1__4j',\n    '0b1001__0100',\n    '0xffff__ffff',\n    '0x___',\n    '0o5__77',\n    '1e1__0',\n    '1e1__0j',\n    # Underscore right before a dot:\n    '1_.4',\n    '1_.4j',\n    # Underscore right after a dot:\n    '1._4',\n    '1._4j',\n    '._5',\n    '._5j',\n    # Underscore right after a sign:\n    '1.0e+_1',\n    '1.0e+_1j',\n    # Underscore right before j:\n    '1.4_j',\n    '1.4e5_j',\n    # Underscore right before e:\n    '1_e1',\n    '1.4_e1',\n    '1.4_e1j',\n    # Underscore right after e:\n    '1e_1',\n    '1.4e_1',\n    '1.4e_1j',\n    # Complex cases with parens:\n    '(1+1.5_j_)',\n    '(1+1.5_j)',\n]",
  "vendor/tree-sitter-python/examples/python3.8_grammar.py::class_TokenTests": "class TokenTests(unittest.TestCase):\n\n    def test_backslash(self):\n        # Backslash means line continuation:\n        x = 1 \\\n        + 1\n        self.assertEqual(x, 2, 'backslash for line continuation')\n\n        # Backslash does not means continuation in comments :\\\n        x = 0\n        self.assertEqual(x, 0, 'backslash ending comment')\n\n    def test_plain_integers(self):\n        self.assertEqual(type(000), type(0))\n        self.assertEqual(0xff, 255)\n        self.assertEqual(0o377, 255)\n        self.assertEqual(2147483647, 0o17777777777)\n        self.assertEqual(0b1001, 9)\n        # \"0x\" is not a valid literal\n        self.assertRaises(SyntaxError, eval, \"0x\")\n        from sys import maxsize\n        if maxsize == 2147483647:\n            self.assertEqual(-2147483647-1, -0o20000000000)\n            # XXX -2147483648\n            self.assertTrue(0o37777777777 > 0)\n            self.assertTrue(0xffffffff > 0)\n            self.assertTrue(0b1111111111111111111111111111111 > 0)\n            for s in ('2147483648', '0o40000000000', '0x100000000',\n                      '0b10000000000000000000000000000000'):\n                try:\n                    x = eval(s)\n                except OverflowError:\n                    self.fail(\"OverflowError on huge integer literal %r\" % s)\n        elif maxsize == 9223372036854775807:\n            self.assertEqual(-9223372036854775807-1, -0o1000000000000000000000)\n            self.assertTrue(0o1777777777777777777777 > 0)\n            self.assertTrue(0xffffffffffffffff > 0)\n            self.assertTrue(0b11111111111111111111111111111111111111111111111111111111111111 > 0)\n            for s in '9223372036854775808', '0o2000000000000000000000', \\\n                     '0x10000000000000000', \\\n                     '0b100000000000000000000000000000000000000000000000000000000000000':\n                try:\n                    x = eval(s)\n                except OverflowError:\n                    self.fail(\"OverflowError on huge integer literal %r\" % s)\n        else:\n            self.fail('Weird maxsize value %r' % maxsize)\n\n    def test_long_integers(self):\n        x = 0\n        x = 0xffffffffffffffff\n        x = 0Xffffffffffffffff\n        x = 0o77777777777777777\n        x = 0O77777777777777777\n        x = 123456789012345678901234567890\n        x = 0b100000000000000000000000000000000000000000000000000000000000000000000\n        x = 0B111111111111111111111111111111111111111111111111111111111111111111111\n\n    def test_floats(self):\n        x = 3.14\n        x = 314.\n        x = 0.314\n        # XXX x = 000.314\n        x = .314\n        x = 3e14\n        x = 3E14\n        x = 3e-14\n        x = 3e+14\n        x = 3.e14\n        x = .3e14\n        x = 3.1e4\n\n    def test_float_exponent_tokenization(self):\n        # See issue 21642.\n        self.assertEqual(1 if 1else 0, 1)\n        self.assertEqual(1 if 0else 0, 0)\n        self.assertRaises(SyntaxError, eval, \"0 if 1Else 0\")\n\n    def test_underscore_literals(self):\n        for lit in VALID_UNDERSCORE_LITERALS:\n            self.assertEqual(eval(lit), eval(lit.replace('_', '')))\n        for lit in INVALID_UNDERSCORE_LITERALS:\n            self.assertRaises(SyntaxError, eval, lit)\n        # Sanity check: no literal begins with an underscore\n        self.assertRaises(NameError, eval, \"_0\")\n\n    def test_string_literals(self):\n        x = ''; y = \"\"; self.assertTrue(len(x) == 0 and x == y)\n        x = '\\''; y = \"'\"; self.assertTrue(len(x) == 1 and x == y and ord(x) == 39)\n        x = '\"'; y = \"\\\"\"; self.assertTrue(len(x) == 1 and x == y and ord(x) == 34)\n        x = \"doesn't \\\"shrink\\\" does it\"\n        y = 'doesn\\'t \"shrink\" does it'\n        self.assertTrue(len(x) == 24 and x == y)\n        x = \"does \\\"shrink\\\" doesn't it\"\n        y = 'does \"shrink\" doesn\\'t it'\n        self.assertTrue(len(x) == 24 and x == y)\n        x = \"\"\"\nThe \"quick\"\nbrown fox\njumps over\nthe 'lazy' dog.\n\"\"\"\n        y = '\\nThe \"quick\"\\nbrown fox\\njumps over\\nthe \\'lazy\\' dog.\\n'\n        self.assertEqual(x, y)\n        y = '''\nThe \"quick\"\nbrown fox\njumps over\nthe 'lazy' dog.\n'''\n        self.assertEqual(x, y)\n        y = \"\\n\\\nThe \\\"quick\\\"\\n\\\nbrown fox\\n\\\njumps over\\n\\\nthe 'lazy' dog.\\n\\\n\"\n        self.assertEqual(x, y)\n        y = '\\n\\\nThe \\\"quick\\\"\\n\\\nbrown fox\\n\\\njumps over\\n\\\nthe \\'lazy\\' dog.\\n\\\n'\n        self.assertEqual(x, y)\n\n    def test_ellipsis(self):\n        x = ...\n        self.assertTrue(x is Ellipsis)\n        self.assertRaises(SyntaxError, eval, \".. .\")\n\n    def test_eof_error(self):\n        samples = (\"def foo(\", \"\\ndef foo(\", \"def foo(\\n\")\n        for s in samples:\n            with self.assertRaises(SyntaxError) as cm:\n                compile(s, \"<test>\", \"exec\")\n            self.assertIn(\"unexpected EOF\", str(cm.exception))\n\n# var_annot_global: int # a global annotated is necessary for test_var_annot\n\n# custom namespace for testing __annotations__",
  "vendor/tree-sitter-python/examples/python3.8_grammar.py::class_CNS": "class CNS:\n    def __init__(self):\n        self._dct = {}\n    def __setitem__(self, item, value):\n        self._dct[item.lower()] = value\n    def __getitem__(self, item):\n        return self._dct[item]",
  "vendor/tree-sitter-python/examples/python3.8_grammar.py::class_GrammarTests": "class GrammarTests(unittest.TestCase):\n\n    check_syntax_error = check_syntax_error\n\n    # single_input: NEWLINE | simple_stmt | compound_stmt NEWLINE\n    # XXX can't test in a script -- this rule is only used when interactive\n\n    # file_input: (NEWLINE | stmt)* ENDMARKER\n    # Being tested as this very moment this very module\n\n    # expr_input: testlist NEWLINE\n    # XXX Hard to test -- used only in calls to input()\n\n    def test_eval_input(self):\n        # testlist ENDMARKER\n        x = eval('1, 0 or 1')\n\n    def test_var_annot_basics(self):\n        # all these should be allowed\n        var1: int = 5\n        # var2: [int, str]\n        my_lst = [42]\n        def one():\n            return 1\n        # int.new_attr: int\n        # [list][0]: type\n        my_lst[one()-1]: int = 5\n        self.assertEqual(my_lst, [5])\n\n    def test_var_annot_syntax_errors(self):\n        # parser pass\n        check_syntax_error(self, \"def f: int\")\n        check_syntax_error(self, \"x: int: str\")\n        check_syntax_error(self, \"def f():\\n\"\n                                 \"    nonlocal x: int\\n\")\n        # AST pass\n        check_syntax_error(self, \"[x, 0]: int\\n\")\n        check_syntax_error(self, \"f(): int\\n\")\n        check_syntax_error(self, \"(x,): int\")\n        check_syntax_error(self, \"def f():\\n\"\n                                 \"    (x, y): int = (1, 2)\\n\")\n        # symtable pass\n        check_syntax_error(self, \"def f():\\n\"\n                                 \"    x: int\\n\"\n                                 \"    global x\\n\")\n        check_syntax_error(self, \"def f():\\n\"\n                                 \"    global x\\n\"\n                                 \"    x: int\\n\")\n\n    def test_var_annot_basic_semantics(self):\n        # execution order\n        with self.assertRaises(ZeroDivisionError):\n            no_name[does_not_exist]: no_name_again = 1/0\n        with self.assertRaises(NameError):\n            no_name[does_not_exist]: 1/0 = 0\n        global var_annot_global\n\n        # function semantics\n        def f():\n            st: str = \"Hello\"\n            a.b: int = (1, 2)\n            return st\n        self.assertEqual(f.__annotations__, {})\n        def f_OK():\n            # x: 1/0\n        f_OK()\n        def fbad():\n            # x: int\n            print(x)\n        with self.assertRaises(UnboundLocalError):\n            fbad()\n        def f2bad():\n            # (no_such_global): int\n            print(no_such_global)\n        try:\n            f2bad()\n        except Exception as e:\n            self.assertIs(type(e), NameError)\n\n        # class semantics\n        class C:\n            # __foo: int\n            s: str = \"attr\"\n            z = 2\n            def __init__(self, x):\n                self.x: int = x\n        self.assertEqual(C.__annotations__, {'_C__foo': int, 's': str})\n        with self.assertRaises(NameError):\n            class CBad:\n                no_such_name_defined.attr: int = 0\n        with self.assertRaises(NameError):\n            class Cbad2(C):\n                # x: int\n                x.y: list = []\n\n    def test_var_annot_metaclass_semantics(self):\n        class CMeta(type):\n            @classmethod\n            def __prepare__(metacls, name, bases, **kwds):\n                return {'__annotations__': CNS()}\n        class CC(metaclass=CMeta):\n            # XX: 'ANNOT'\n        self.assertEqual(CC.__annotations__['xx'], 'ANNOT')\n\n    def test_var_annot_module_semantics(self):\n        with self.assertRaises(AttributeError):\n            print(test.__annotations__)\n        self.assertEqual(ann_module.__annotations__,\n                     {1: 2, 'x': int, 'y': str, 'f': typing.Tuple[int, int]})\n        self.assertEqual(ann_module.M.__annotations__,\n                              {'123': 123, 'o': type})\n        self.assertEqual(ann_module2.__annotations__, {})\n\n    def test_var_annot_in_module(self):\n        # check that functions fail the same way when executed\n        # outside of module where they were defined\n        from test.ann_module3 import f_bad_ann, g_bad_ann, D_bad_ann\n        with self.assertRaises(NameError):\n            f_bad_ann()\n        with self.assertRaises(NameError):\n            g_bad_ann()\n        with self.assertRaises(NameError):\n            D_bad_ann(5)\n\n    def test_var_annot_simple_exec(self):\n        gns = {}; lns= {}\n        exec(\"'docstring'\\n\"\n             \"__annotations__[1] = 2\\n\"\n             \"x: int = 5\\n\", gns, lns)\n        self.assertEqual(lns[\"__annotations__\"], {1: 2, 'x': int})\n        with self.assertRaises(KeyError):\n            gns['__annotations__']\n\n    def test_var_annot_custom_maps(self):\n        # tests with custom locals() and __annotations__\n        ns = {'__annotations__': CNS()}\n        exec('X: int; Z: str = \"Z\"; (w): complex = 1j', ns)\n        self.assertEqual(ns['__annotations__']['x'], int)\n        self.assertEqual(ns['__annotations__']['z'], str)\n        with self.assertRaises(KeyError):\n            ns['__annotations__']['w']\n        nonloc_ns = {}\n        class CNS2:\n            def __init__(self):\n                self._dct = {}\n            def __setitem__(self, item, value):\n                nonlocal nonloc_ns\n                self._dct[item] = value\n                nonloc_ns[item] = value\n            def __getitem__(self, item):\n                return self._dct[item]\n        exec('x: int = 1', {}, CNS2())\n        self.assertEqual(nonloc_ns['__annotations__']['x'], int)\n\n    def test_var_annot_refleak(self):\n        # complex case: custom locals plus custom __annotations__\n        # this was causing refleak\n        cns = CNS()\n        nonloc_ns = {'__annotations__': cns}\n        class CNS2:\n            def __init__(self):\n                self._dct = {'__annotations__': cns}\n            def __setitem__(self, item, value):\n                nonlocal nonloc_ns\n                self._dct[item] = value\n                nonloc_ns[item] = value\n            def __getitem__(self, item):\n                return self._dct[item]\n        exec('X: str', {}, CNS2())\n        self.assertEqual(nonloc_ns['__annotations__']['x'], str)\n\n    def test_funcdef(self):\n        ### [decorators] 'def' NAME parameters ['->' test] ':' suite\n        ### decorator: '@' dotted_name [ '(' [arglist] ')' ] NEWLINE\n        ### decorators: decorator+\n        ### parameters: '(' [typedargslist] ')'\n        ### typedargslist: ((tfpdef ['=' test] ',')*\n        ###                ('*' [tfpdef] (',' tfpdef ['=' test])* [',' '**' tfpdef] | '**' tfpdef)\n        ###                | tfpdef ['=' test] (',' tfpdef ['=' test])* [','])\n        ### tfpdef: NAME [':' test]\n        ### varargslist: ((vfpdef ['=' test] ',')*\n        ###              ('*' [vfpdef] (',' vfpdef ['=' test])*  [',' '**' vfpdef] | '**' vfpdef)\n        ###              | vfpdef ['=' test] (',' vfpdef ['=' test])* [','])\n        ### vfpdef: NAME\n        def f1(): pass\n        f1()\n        f1(*())\n        f1(*(), **{})\n        def f2(one_argument): pass\n        def f3(two, arguments): pass\n        self.assertEqual(f2.__code__.co_varnames, ('one_argument',))\n        self.assertEqual(f3.__code__.co_varnames, ('two', 'arguments'))\n        def a1(one_arg,): pass\n        def a2(two, args,): pass\n        def v0(*rest): pass\n        def v1(a, *rest): pass\n        def v2(a, b, *rest): pass\n\n        f1()\n        f2(1)\n        f2(1,)\n        f3(1, 2)\n        f3(1, 2,)\n        v0()\n        v0(1)\n        v0(1,)\n        v0(1,2)\n        v0(1,2,3,4,5,6,7,8,9,0)\n        v1(1)\n        v1(1,)\n        v1(1,2)\n        v1(1,2,3)\n        v1(1,2,3,4,5,6,7,8,9,0)\n        v2(1,2)\n        v2(1,2,3)\n        v2(1,2,3,4)\n        v2(1,2,3,4,5,6,7,8,9,0)\n\n        def d01(a=1): pass\n        d01()\n        d01(1)\n        d01(*(1,))\n        d01(*[] or [2])\n        d01(*() or (), *{} and (), **() or {})\n        d01(**{'a':2})\n        d01(**{'a':2} or {})\n        def d11(a, b=1): pass\n        d11(1)\n        d11(1, 2)\n        d11(1, **{'b':2})\n        def d21(a, b, c=1): pass\n        d21(1, 2)\n        d21(1, 2, 3)\n        d21(*(1, 2, 3))\n        d21(1, *(2, 3))\n        d21(1, 2, *(3,))\n        d21(1, 2, **{'c':3})\n        def d02(a=1, b=2): pass\n        d02()\n        d02(1)\n        d02(1, 2)\n        d02(*(1, 2))\n        d02(1, *(2,))\n        d02(1, **{'b':2})\n        d02(**{'a': 1, 'b': 2})\n        def d12(a, b=1, c=2): pass\n        d12(1)\n        d12(1, 2)\n        d12(1, 2, 3)\n        def d22(a, b, c=1, d=2): pass\n        d22(1, 2)\n        d22(1, 2, 3)\n        d22(1, 2, 3, 4)\n        def d01v(a=1, *rest): pass\n        d01v()\n        d01v(1)\n        d01v(1, 2)\n        d01v(*(1, 2, 3, 4))\n        d01v(*(1,))\n        d01v(**{'a':2})\n        def d11v(a, b=1, *rest): pass\n        d11v(1)\n        d11v(1, 2)\n        d11v(1, 2, 3)\n        def d21v(a, b, c=1, *rest): pass\n        d21v(1, 2)\n        d21v(1, 2, 3)\n        d21v(1, 2, 3, 4)\n        d21v(*(1, 2, 3, 4))\n        d21v(1, 2, **{'c': 3})\n        def d02v(a=1, b=2, *rest): pass\n        d02v()\n        d02v(1)\n        d02v(1, 2)\n        d02v(1, 2, 3)\n        d02v(1, *(2, 3, 4))\n        d02v(**{'a': 1, 'b': 2})\n        def d12v(a, b=1, c=2, *rest): pass\n        d12v(1)\n        d12v(1, 2)\n        d12v(1, 2, 3)\n        d12v(1, 2, 3, 4)\n        d12v(*(1, 2, 3, 4))\n        d12v(1, 2, *(3, 4, 5))\n        d12v(1, *(2,), **{'c': 3})\n        def d22v(a, b, c=1, d=2, *rest): pass\n        d22v(1, 2)\n        d22v(1, 2, 3)\n        d22v(1, 2, 3, 4)\n        d22v(1, 2, 3, 4, 5)\n        d22v(*(1, 2, 3, 4))\n        d22v(1, 2, *(3, 4, 5))\n        d22v(1, *(2, 3), **{'d': 4})\n\n        # keyword argument type tests\n        try:\n            str('x', **{b'foo':1 })\n        except TypeError:\n            pass\n        else:\n            self.fail('Bytes should not work as keyword argument names')\n        # keyword only argument tests\n        def pos0key1(*, key): return key\n        pos0key1(key=100)\n        def pos2key2(p1, p2, *, k1, k2=100): return p1,p2,k1,k2\n        pos2key2(1, 2, k1=100)\n        pos2key2(1, 2, k1=100, k2=200)\n        pos2key2(1, 2, k2=100, k1=200)\n        def pos2key2dict(p1, p2, *, k1=100, k2, **kwarg): return p1,p2,k1,k2,kwarg\n        pos2key2dict(1,2,k2=100,tokwarg1=100,tokwarg2=200)\n        pos2key2dict(1,2,tokwarg1=100,tokwarg2=200, k2=100)\n\n        self.assertRaises(SyntaxError, eval, \"def f(*): pass\")\n        self.assertRaises(SyntaxError, eval, \"def f(*,): pass\")\n        self.assertRaises(SyntaxError, eval, \"def f(*, **kwds): pass\")\n\n        # keyword arguments after *arglist\n        def f(*args, **kwargs):\n            return args, kwargs\n        self.assertEqual(f(1, x=2, *[3, 4], y=5), ((1, 3, 4),\n                                                    {'x':2, 'y':5}))\n        self.assertEqual(f(1, *(2,3), 4), ((1, 2, 3, 4), {}))\n        self.assertRaises(SyntaxError, eval, \"f(1, x=2, *(3,4), x=5)\")\n        self.assertEqual(f(**{'eggs':'scrambled', 'spam':'fried'}),\n                         ((), {'eggs':'scrambled', 'spam':'fried'}))\n        self.assertEqual(f(spam='fried', **{'eggs':'scrambled'}),\n                         ((), {'eggs':'scrambled', 'spam':'fried'}))\n\n        # Check ast errors in *args and *kwargs\n        check_syntax_error(self, \"f(*g(1=2))\")\n        check_syntax_error(self, \"f(**g(1=2))\")\n\n        # argument annotation tests\n        def f(x) -> list: pass\n        self.assertEqual(f.__annotations__, {'return': list})\n        def f(x: int): pass\n        self.assertEqual(f.__annotations__, {'x': int})\n        def f(*x: str): pass\n        self.assertEqual(f.__annotations__, {'x': str})\n        def f(**x: float): pass\n        self.assertEqual(f.__annotations__, {'x': float})\n        def f(x, y: 1+2): pass\n        self.assertEqual(f.__annotations__, {'y': 3})\n        def f(a, b: 1, c: 2, d): pass\n        self.assertEqual(f.__annotations__, {'b': 1, 'c': 2})\n        def f(a, b: 1, c: 2, d, e: 3 = 4, f=5, *g: 6): pass\n        self.assertEqual(f.__annotations__,\n                         {'b': 1, 'c': 2, 'e': 3, 'g': 6})\n        def f(a, b: 1, c: 2, d, e: 3 = 4, f=5, *g: 6, h: 7, i=8, j: 9 = 10,\n              **k: 11) -> 12: pass\n        self.assertEqual(f.__annotations__,\n                         {'b': 1, 'c': 2, 'e': 3, 'g': 6, 'h': 7, 'j': 9,\n                          'k': 11, 'return': 12})\n        # Check for issue #20625 -- annotations mangling\n        class Spam:\n            def f(self, *, __kw: 1):\n                pass\n        class Ham(Spam): pass\n        self.assertEqual(Spam.f.__annotations__, {'_Spam__kw': 1})\n        self.assertEqual(Ham.f.__annotations__, {'_Spam__kw': 1})\n        # Check for SF Bug #1697248 - mixing decorators and a return annotation\n        def null(x): return x\n        @null\n        def f(x) -> list: pass\n        self.assertEqual(f.__annotations__, {'return': list})\n\n        # test closures with a variety of opargs\n        closure = 1\n        def f(): return closure\n        def f(x=1): return closure\n        def f(*, k=1): return closure\n        def f() -> int: return closure\n\n        # Check trailing commas are permitted in funcdef argument list\n        def f(a,): pass\n        def f(*args,): pass\n        def f(**kwds,): pass\n        def f(a, *args,): pass\n        def f(a, **kwds,): pass\n        def f(*args, b,): pass\n        def f(*, b,): pass\n        def f(*args, **kwds,): pass\n        def f(a, *args, b,): pass\n        def f(a, *, b,): pass\n        def f(a, *args, **kwds,): pass\n        def f(*args, b, **kwds,): pass\n        def f(*, b, **kwds,): pass\n        def f(a, *args, b, **kwds,): pass\n        def f(a, *, b, **kwds,): pass\n\n    def test_lambdef(self):\n        ### lambdef: 'lambda' [varargslist] ':' test\n        l1 = lambda : 0\n        self.assertEqual(l1(), 0)\n        l2 = lambda : a[d] # XXX just testing the expression\n        l3 = lambda : [2 < x for x in [-1, 3, 0]]\n        self.assertEqual(l3(), [0, 1, 0])\n        l4 = lambda x = lambda y = lambda z=1 : z : y() : x()\n        self.assertEqual(l4(), 1)\n        l5 = lambda x, y, z=2: x + y + z\n        self.assertEqual(l5(1, 2), 5)\n        self.assertEqual(l5(1, 2, 3), 6)\n        check_syntax_error(self, \"lambda x: x = 2\")\n        check_syntax_error(self, \"lambda (None,): None\")\n        l6 = lambda x, y, *, k=20: x+y+k\n        self.assertEqual(l6(1,2), 1+2+20)\n        self.assertEqual(l6(1,2,k=10), 1+2+10)\n\n        # check that trailing commas are permitted\n        l10 = lambda a,: 0\n        l11 = lambda *args,: 0\n        l12 = lambda **kwds,: 0\n        l13 = lambda a, *args,: 0\n        l14 = lambda a, **kwds,: 0\n        l15 = lambda *args, b,: 0\n        l16 = lambda *, b,: 0\n        l17 = lambda *args, **kwds,: 0\n        l18 = lambda a, *args, b,: 0\n        l19 = lambda a, *, b,: 0\n        l20 = lambda a, *args, **kwds,: 0\n        l21 = lambda *args, b, **kwds,: 0\n        l22 = lambda *, b, **kwds,: 0\n        l23 = lambda a, *args, b, **kwds,: 0\n        l24 = lambda a, *, b, **kwds,: 0\n\n\n    ### stmt: simple_stmt | compound_stmt\n    # Tested below\n\n    def test_simple_stmt(self):\n        ### simple_stmt: small_stmt (';' small_stmt)* [';']\n        x = 1; pass; del x\n        def foo():\n            # verify statements that end with semi-colons\n            x = 1; pass; del x;\n        foo()\n\n    ### small_stmt: expr_stmt | pass_stmt | del_stmt | flow_stmt | import_stmt | global_stmt | access_stmt\n    # Tested below\n\n    def test_expr_stmt(self):\n        # (exprlist '=')* exprlist\n        1\n        1, 2, 3\n        x = 1\n        x = 1, 2, 3\n        x = y = z = 1, 2, 3\n        x, y, z = 1, 2, 3\n        abc = a, b, c = x, y, z = xyz = 1, 2, (3, 4)\n\n        check_syntax_error(self, \"x + 1 = 1\")\n        check_syntax_error(self, \"a + 1 = b + 2\")\n\n    # Check the heuristic for print & exec covers significant cases\n    # As well as placing some limits on false positives\n    def test_former_statements_refer_to_builtins(self):\n        keywords = \"print\", \"exec\"\n        # Cases where we want the custom error\n        cases = [\n            \"{} foo\",\n            \"{} {{1:foo}}\",\n            \"if 1: {} foo\",\n            \"if 1: {} {{1:foo}}\",\n            \"if 1:\\n    {} foo\",\n            \"if 1:\\n    {} {{1:foo}}\",\n        ]\n        for keyword in keywords:\n            custom_msg = \"call to '{}'\".format(keyword)\n            for case in cases:\n                source = case.format(keyword)\n                with self.subTest(source=source):\n                    with self.assertRaisesRegex(SyntaxError, custom_msg):\n                        exec(source)\n                source = source.replace(\"foo\", \"(foo.)\")\n                with self.subTest(source=source):\n                    with self.assertRaisesRegex(SyntaxError, \"invalid syntax\"):\n                        exec(source)\n\n    def test_del_stmt(self):\n        # 'del' exprlist\n        abc = [1,2,3]\n        x, y, z = abc\n        xyz = x, y, z\n\n        del abc\n        del x, y, (z, xyz)\n\n    def test_pass_stmt(self):\n        # 'pass'\n        pass\n\n    # flow_stmt: break_stmt | continue_stmt | return_stmt | raise_stmt\n    # Tested below\n\n    def test_break_stmt(self):\n        # 'break'\n        while 1: break\n\n    def test_continue_stmt(self):\n        # 'continue'\n        i = 1\n        while i: i = 0; continue\n\n        msg = \"\"\n        while not msg:\n            msg = \"ok\"\n            try:\n                continue\n                msg = \"continue failed to continue inside try\"\n            except:\n                msg = \"continue inside try called except block\"\n        if msg != \"ok\":\n            self.fail(msg)\n\n        msg = \"\"\n        while not msg:\n            msg = \"finally block not called\"\n            try:\n                continue\n            finally:\n                msg = \"ok\"\n        if msg != \"ok\":\n            self.fail(msg)\n\n    def test_break_continue_loop(self):\n        # This test warrants an explanation. It is a test specifically for SF bugs\n        # #463359 and #462937. The bug is that a 'break' statement executed or\n        # exception raised inside a try/except inside a loop, *after* a continue\n        # statement has been executed in that loop, will cause the wrong number of\n        # arguments to be popped off the stack and the instruction pointer reset to\n        # a very small number (usually 0.) Because of this, the following test\n        # *must* written as a function, and the tracking vars *must* be function\n        # arguments with default values. Otherwise, the test will loop and loop.\n\n        def test_inner(extra_burning_oil = 1, count=0):\n            big_hippo = 2\n            while big_hippo:\n                count += 1\n                try:\n                    if extra_burning_oil and big_hippo == 1:\n                        extra_burning_oil -= 1\n                        break\n                    big_hippo -= 1\n                    continue\n                except:\n                    raise\n            if count > 2 or big_hippo != 1:\n                self.fail(\"continue then break in try/except in loop broken!\")\n        test_inner()\n\n    def test_return(self):\n        # 'return' [testlist]\n        def g1(): return\n        def g2(): return 1\n        g1()\n        x = g2()\n        check_syntax_error(self, \"class foo:return 1\")\n\n    def test_break_in_finally(self):\n        count = 0\n        while count < 2:\n            count += 1\n            try:\n                pass\n            finally:\n                break\n        self.assertEqual(count, 1)\n\n        count = 0\n        while count < 2:\n            count += 1\n            try:\n                continue\n            finally:\n                break\n        self.assertEqual(count, 1)\n\n        count = 0\n        while count < 2:\n            count += 1\n            try:\n                1/0\n            finally:\n                break\n        self.assertEqual(count, 1)\n\n        for count in [0, 1]:\n            self.assertEqual(count, 0)\n            try:\n                pass\n            finally:\n                break\n        self.assertEqual(count, 0)\n\n        for count in [0, 1]:\n            self.assertEqual(count, 0)\n            try:\n                continue\n            finally:\n                break\n        self.assertEqual(count, 0)\n\n        for count in [0, 1]:\n            self.assertEqual(count, 0)\n            try:\n                1/0\n            finally:\n                break\n        self.assertEqual(count, 0)\n\n    def test_continue_in_finally(self):\n        count = 0\n        while count < 2:\n            count += 1\n            try:\n                pass\n            finally:\n                continue\n            break\n        self.assertEqual(count, 2)\n\n        count = 0\n        while count < 2:\n            count += 1\n            try:\n                break\n            finally:\n                continue\n        self.assertEqual(count, 2)\n\n        count = 0\n        while count < 2:\n            count += 1\n            try:\n                1/0\n            finally:\n                continue\n            break\n        self.assertEqual(count, 2)\n\n        for count in [0, 1]:\n            try:\n                pass\n            finally:\n                continue\n            break\n        self.assertEqual(count, 1)\n\n        for count in [0, 1]:\n            try:\n                break\n            finally:\n                continue\n        self.assertEqual(count, 1)\n\n        for count in [0, 1]:\n            try:\n                1/0\n            finally:\n                continue\n            break\n        self.assertEqual(count, 1)\n\n    def test_return_in_finally(self):\n        def g1():\n            try:\n                pass\n            finally:\n                return 1\n        self.assertEqual(g1(), 1)\n\n        def g2():\n            try:\n                return 2\n            finally:\n                return 3\n        self.assertEqual(g2(), 3)\n\n        def g3():\n            try:\n                1/0\n            finally:\n                return 4\n        self.assertEqual(g3(), 4)\n\n    def test_yield(self):\n        # Allowed as standalone statement\n        def g(): yield 1\n        def g(): yield from ()\n        # Allowed as RHS of assignment\n        def g(): x = yield 1\n        def g(): x = yield from ()\n        # Ordinary yield accepts implicit tuples\n        def g(): yield 1, 1\n        def g(): x = yield 1, 1\n        # 'yield from' does not\n        check_syntax_error(self, \"def g(): yield from (), 1\")\n        check_syntax_error(self, \"def g(): x = yield from (), 1\")\n        # Requires parentheses as subexpression\n        def g(): 1, (yield 1)\n        def g(): 1, (yield from ())\n        check_syntax_error(self, \"def g(): 1, yield 1\")\n        check_syntax_error(self, \"def g(): 1, yield from ()\")\n        # Requires parentheses as call argument\n        def g(): f((yield 1))\n        def g(): f((yield 1), 1)\n        def g(): f((yield from ()))\n        def g(): f((yield from ()), 1)\n        check_syntax_error(self, \"def g(): f(yield 1)\")\n        check_syntax_error(self, \"def g(): f(yield 1, 1)\")\n        check_syntax_error(self, \"def g(): f(yield from ())\")\n        check_syntax_error(self, \"def g(): f(yield from (), 1)\")\n        # Not allowed at top level\n        check_syntax_error(self, \"yield\")\n        check_syntax_error(self, \"yield from\")\n        # Not allowed at class scope\n        check_syntax_error(self, \"class foo:yield 1\")\n        check_syntax_error(self, \"class foo:yield from ()\")\n        # Check annotation refleak on SyntaxError\n        check_syntax_error(self, \"def g(a:(yield)): pass\")\n\n    def test_yield_in_comprehensions(self):\n        # Check yield in comprehensions\n        def g(): [x for x in [(yield 1)]]\n        def g(): [x for x in [(yield from ())]]\n\n        check = self.check_syntax_error\n        check(\"def g(): [(yield x) for x in ()]\",\n              \"'yield' inside list comprehension\")\n        check(\"def g(): [x for x in () if not (yield x)]\",\n              \"'yield' inside list comprehension\")\n        check(\"def g(): [y for x in () for y in [(yield x)]]\",\n              \"'yield' inside list comprehension\")\n        check(\"def g(): {(yield x) for x in ()}\",\n              \"'yield' inside set comprehension\")\n        check(\"def g(): {(yield x): x for x in ()}\",\n              \"'yield' inside dict comprehension\")\n        check(\"def g(): {x: (yield x) for x in ()}\",\n              \"'yield' inside dict comprehension\")\n        check(\"def g(): ((yield x) for x in ())\",\n              \"'yield' inside generator expression\")\n        check(\"def g(): [(yield from x) for x in ()]\",\n              \"'yield' inside list comprehension\")\n        check(\"class C: [(yield x) for x in ()]\",\n              \"'yield' inside list comprehension\")\n        check(\"[(yield x) for x in ()]\",\n              \"'yield' inside list comprehension\")\n\n    def test_raise(self):\n        # 'raise' test [',' test]\n        try: raise RuntimeError('just testing')\n        except RuntimeError: pass\n        try: raise KeyboardInterrupt\n        except KeyboardInterrupt: pass\n\n    def test_import(self):\n        # 'import' dotted_as_names\n        import sys\n        import time, sys\n        # 'from' dotted_name 'import' ('*' | '(' import_as_names ')' | import_as_names)\n        from time import time\n        from time import (time)\n        # not testable inside a function, but already done at top of the module\n        # from sys import *\n        from sys import path, argv\n        from sys import (path, argv)\n        from sys import (path, argv,)\n\n    def test_global(self):\n        # 'global' NAME (',' NAME)*\n        global a\n        global a, b\n        global one, two, three, four, five, six, seven, eight, nine, ten\n\n    def test_nonlocal(self):\n        # 'nonlocal' NAME (',' NAME)*\n        x = 0\n        y = 0\n        def f():\n            nonlocal x\n            nonlocal x, y\n\n    def test_assert(self):\n        # assertTruestmt: 'assert' test [',' test]\n        assert 1\n        assert 1, 1\n        assert lambda x:x\n        assert 1, lambda x:x+1\n\n        try:\n            assert True\n        except AssertionError as e:\n            self.fail(\"'assert True' should not have raised an AssertionError\")\n\n        try:\n            assert True, 'this should always pass'\n        except AssertionError as e:\n            self.fail(\"'assert True, msg' should not have \"\n                      \"raised an AssertionError\")\n\n    # these tests fail if python is run with -O, so check __debug__\n    @unittest.skipUnless(__debug__, \"Won't work if __debug__ is False\")\n    def testAssert2(self):\n        try:\n            assert 0, \"msg\"\n        except AssertionError as e:\n            self.assertEqual(e.args[0], \"msg\")\n        else:\n            self.fail(\"AssertionError not raised by assert 0\")\n\n        try:\n            assert False\n        except AssertionError as e:\n            self.assertEqual(len(e.args), 0)\n        else:\n            self.fail(\"AssertionError not raised by 'assert False'\")\n\n\n    ### compound_stmt: if_stmt | while_stmt | for_stmt | try_stmt | funcdef | classdef\n    # Tested below\n\n    def test_if(self):\n        # 'if' test ':' suite ('elif' test ':' suite)* ['else' ':' suite]\n        if 1: pass\n        if 1: pass\n        else: pass\n        if 0: pass\n        elif 0: pass\n        if 0: pass\n        elif 0: pass\n        elif 0: pass\n        elif 0: pass\n        else: pass\n\n    def test_while(self):\n        # 'while' test ':' suite ['else' ':' suite]\n        while 0: pass\n        while 0: pass\n        else: pass\n\n        # Issue1920: \"while 0\" is optimized away,\n        # ensure that the \"else\" clause is still present.\n        x = 0\n        while 0:\n            x = 1\n        else:\n            x = 2\n        self.assertEqual(x, 2)\n\n    def test_for(self):\n        # 'for' exprlist 'in' exprlist ':' suite ['else' ':' suite]\n        for i in 1, 2, 3: pass\n        for i, j, k in (): pass\n        else: pass\n        class Squares:\n            def __init__(self, max):\n                self.max = max\n                self.sofar = []\n            def __len__(self): return len(self.sofar)\n            def __getitem__(self, i):\n                if not 0 <= i < self.max: raise IndexError\n                n = len(self.sofar)\n                while n <= i:\n                    self.sofar.append(n*n)\n                    n = n+1\n                return self.sofar[i]\n        n = 0\n        for x in Squares(10): n = n+x\n        if n != 285:\n            self.fail('for over growing sequence')\n\n        result = []\n        for x, in [(1,), (2,), (3,)]:\n            result.append(x)\n        self.assertEqual(result, [1, 2, 3])\n\n    def test_try(self):\n        ### try_stmt: 'try' ':' suite (except_clause ':' suite)+ ['else' ':' suite]\n        ###         | 'try' ':' suite 'finally' ':' suite\n        ### except_clause: 'except' [expr ['as' expr]]\n        try:\n            1/0\n        except ZeroDivisionError:\n            pass\n        else:\n            pass\n        try: 1/0\n        except EOFError: pass\n        except TypeError as msg: pass\n        except: pass\n        else: pass\n        try: 1/0\n        except (EOFError, TypeError, ZeroDivisionError): pass\n        try: 1/0\n        except (EOFError, TypeError, ZeroDivisionError) as msg: pass\n        try: pass\n        finally: pass\n\n    def test_suite(self):\n        # simple_stmt | NEWLINE INDENT NEWLINE* (stmt NEWLINE*)+ DEDENT\n        if 1: pass\n        if 1:\n            pass\n        if 1:\n            #\n            #\n            #\n            pass\n            pass\n            #\n            pass\n            #\n\n    def test_test(self):\n        ### and_test ('or' and_test)*\n        ### and_test: not_test ('and' not_test)*\n        ### not_test: 'not' not_test | comparison\n        if not 1: pass\n        if 1 and 1: pass\n        if 1 or 1: pass\n        if not not not 1: pass\n        if not 1 and 1 and 1: pass\n        if 1 and 1 or 1 and 1 and 1 or not 1 and 1: pass\n\n    def test_comparison(self):\n        ### comparison: expr (comp_op expr)*\n        ### comp_op: '<'|'>'|'=='|'>='|'<='|'!='|'in'|'not' 'in'|'is'|'is' 'not'\n        if 1: pass\n        x = (1 == 1)\n        if 1 == 1: pass\n        if 1 != 1: pass\n        if 1 < 1: pass\n        if 1 > 1: pass\n        if 1 <= 1: pass\n        if 1 >= 1: pass\n        if 1 is 1: pass\n        if 1 is not 1: pass\n        if 1 in (): pass\n        if 1 not in (): pass\n        if 1 < 1 > 1 == 1 >= 1 <= 1 != 1 in 1 not in 1 is 1 is not 1: pass\n\n    def test_binary_mask_ops(self):\n        x = 1 & 1\n        x = 1 ^ 1\n        x = 1 | 1\n\n    def test_shift_ops(self):\n        x = 1 << 1\n        x = 1 >> 1\n        x = 1 << 1 >> 1\n\n    def test_additive_ops(self):\n        x = 1\n        x = 1 + 1\n        x = 1 - 1 - 1\n        x = 1 - 1 + 1 - 1 + 1\n\n    def test_multiplicative_ops(self):\n        x = 1 * 1\n        x = 1 / 1\n        x = 1 % 1\n        x = 1 / 1 * 1 % 1\n\n    def test_unary_ops(self):\n        x = +1\n        x = -1\n        x = ~1\n        x = ~1 ^ 1 & 1 | 1 & 1 ^ -1\n        x = -1*1/1 + 1*1 - ---1*1\n\n    def test_selectors(self):\n        ### trailer: '(' [testlist] ')' | '[' subscript ']' | '.' NAME\n        ### subscript: expr | [expr] ':' [expr]\n\n        import sys, time\n        c = sys.path[0]\n        x = time.time()\n        x = sys.modules['time'].time()\n        a = '01234'\n        c = a[0]\n        c = a[-1]\n        s = a[0:5]\n        s = a[:5]\n        s = a[0:]\n        s = a[:]\n        s = a[-5:]\n        s = a[:-1]\n        s = a[-4:-3]\n        # A rough test of SF bug 1333982.  http://python.org/sf/1333982\n        # The testing here is fairly incomplete.\n        # Test cases should include: commas with 1 and 2 colons\n        d = {}\n        d[1] = 1\n        d[1,] = 2\n        d[1,2] = 3\n        d[1,2,3] = 4\n        L = list(d)\n        L.sort(key=lambda x: (type(x).__name__, x))\n        self.assertEqual(str(L), '[1, (1,), (1, 2), (1, 2, 3)]')\n\n    def test_atoms(self):\n        ### atom: '(' [testlist] ')' | '[' [testlist] ']' | '{' [dictsetmaker] '}' | NAME | NUMBER | STRING\n        ### dictsetmaker: (test ':' test (',' test ':' test)* [',']) | (test (',' test)* [','])\n\n        x = (1)\n        x = (1 or 2 or 3)\n        x = (1 or 2 or 3, 2, 3)\n\n        x = []\n        x = [1]\n        x = [1 or 2 or 3]\n        x = [1 or 2 or 3, 2, 3]\n        x = []\n\n        x = {}\n        x = {'one': 1}\n        x = {'one': 1,}\n        x = {'one' or 'two': 1 or 2}\n        x = {'one': 1, 'two': 2}\n        x = {'one': 1, 'two': 2,}\n        x = {'one': 1, 'two': 2, 'three': 3, 'four': 4, 'five': 5, 'six': 6}\n\n        x = {'one'}\n        x = {'one', 1,}\n        x = {'one', 'two', 'three'}\n        x = {2, 3, 4,}\n\n        x = x\n        x = 'x'\n        x = 123\n\n    ### exprlist: expr (',' expr)* [',']\n    ### testlist: test (',' test)* [',']\n    # These have been exercised enough above\n\n    def test_classdef(self):\n        # 'class' NAME ['(' [testlist] ')'] ':' suite\n        class B: pass\n        class B2(): pass\n        class C1(B): pass\n        class C2(B): pass\n        class D(C1, C2, B): pass\n        class C:\n            def meth1(self): pass\n            def meth2(self, arg): pass\n            def meth3(self, a1, a2): pass\n\n        # decorator: '@' dotted_name [ '(' [arglist] ')' ] NEWLINE\n        # decorators: decorator+\n        # decorated: decorators (classdef | funcdef)\n        def class_decorator(x): return x\n        @class_decorator\n        class G: pass\n\n    def test_dictcomps(self):\n        # dictorsetmaker: ( (test ':' test (comp_for |\n        #                                   (',' test ':' test)* [','])) |\n        #                   (test (comp_for | (',' test)* [','])) )\n        nums = [1, 2, 3]\n        self.assertEqual({i:i+1 for i in nums}, {1: 2, 2: 3, 3: 4})\n\n    def test_listcomps(self):\n        # list comprehension tests\n        nums = [1, 2, 3, 4, 5]\n        strs = [\"Apple\", \"Banana\", \"Coconut\"]\n        spcs = [\"  Apple\", \" Banana \", \"Coco  nut  \"]\n\n        self.assertEqual([s.strip() for s in spcs], ['Apple', 'Banana', 'Coco  nut'])\n        self.assertEqual([3 * x for x in nums], [3, 6, 9, 12, 15])\n        self.assertEqual([x for x in nums if x > 2], [3, 4, 5])\n        self.assertEqual([(i, s) for i in nums for s in strs],\n                         [(1, 'Apple'), (1, 'Banana'), (1, 'Coconut'),\n                          (2, 'Apple'), (2, 'Banana'), (2, 'Coconut'),\n                          (3, 'Apple'), (3, 'Banana'), (3, 'Coconut'),\n                          (4, 'Apple'), (4, 'Banana'), (4, 'Coconut'),\n                          (5, 'Apple'), (5, 'Banana'), (5, 'Coconut')])\n        self.assertEqual([(i, s) for i in nums for s in [f for f in strs if \"n\" in f]],\n                         [(1, 'Banana'), (1, 'Coconut'), (2, 'Banana'), (2, 'Coconut'),\n                          (3, 'Banana'), (3, 'Coconut'), (4, 'Banana'), (4, 'Coconut'),\n                          (5, 'Banana'), (5, 'Coconut')])\n        self.assertEqual([(lambda a:[a**i for i in range(a+1)])(j) for j in range(5)],\n                         [[1], [1, 1], [1, 2, 4], [1, 3, 9, 27], [1, 4, 16, 64, 256]])\n\n        def test_in_func(l):\n            return [0 < x < 3 for x in l if x > 2]\n\n        self.assertEqual(test_in_func(nums), [False, False, False])\n\n        def test_nested_front():\n            self.assertEqual([[y for y in [x, x + 1]] for x in [1,3,5]],\n                             [[1, 2], [3, 4], [5, 6]])\n\n        test_nested_front()\n\n        check_syntax_error(self, \"[i, s for i in nums for s in strs]\")\n        check_syntax_error(self, \"[x if y]\")\n\n        suppliers = [\n          (1, \"Boeing\"),\n          (2, \"Ford\"),\n          (3, \"Macdonalds\")\n        ]\n\n        parts = [\n          (10, \"Airliner\"),\n          (20, \"Engine\"),\n          (30, \"Cheeseburger\")\n        ]\n\n        suppart = [\n          (1, 10), (1, 20), (2, 20), (3, 30)\n        ]\n\n        x = [\n          (sname, pname)\n            for (sno, sname) in suppliers\n              for (pno, pname) in parts\n                for (sp_sno, sp_pno) in suppart\n                  if sno == sp_sno and pno == sp_pno\n        ]\n\n        self.assertEqual(x, [('Boeing', 'Airliner'), ('Boeing', 'Engine'), ('Ford', 'Engine'),\n                             ('Macdonalds', 'Cheeseburger')])\n\n    def test_genexps(self):\n        # generator expression tests\n        g = ([x for x in range(10)] for x in range(1))\n        self.assertEqual(next(g), [x for x in range(10)])\n        try:\n            next(g)\n            self.fail('should produce StopIteration exception')\n        except StopIteration:\n            pass\n\n        a = 1\n        try:\n            g = (a for d in a)\n            next(g)\n            self.fail('should produce TypeError')\n        except TypeError:\n            pass\n\n        self.assertEqual(list((x, y) for x in 'abcd' for y in 'abcd'), [(x, y) for x in 'abcd' for y in 'abcd'])\n        self.assertEqual(list((x, y) for x in 'ab' for y in 'xy'), [(x, y) for x in 'ab' for y in 'xy'])\n\n        a = [x for x in range(10)]\n        b = (x for x in (y for y in a))\n        self.assertEqual(sum(b), sum([x for x in range(10)]))\n\n        self.assertEqual(sum(x**2 for x in range(10)), sum([x**2 for x in range(10)]))\n        self.assertEqual(sum(x*x for x in range(10) if x%2), sum([x*x for x in range(10) if x%2]))\n        self.assertEqual(sum(x for x in (y for y in range(10))), sum([x for x in range(10)]))\n        self.assertEqual(sum(x for x in (y for y in (z for z in range(10)))), sum([x for x in range(10)]))\n        self.assertEqual(sum(x for x in [y for y in (z for z in range(10))]), sum([x for x in range(10)]))\n        self.assertEqual(sum(x for x in (y for y in (z for z in range(10) if True)) if True), sum([x for x in range(10)]))\n        self.assertEqual(sum(x for x in (y for y in (z for z in range(10) if True) if False) if True), 0)\n        check_syntax_error(self, \"foo(x for x in range(10), 100)\")\n        check_syntax_error(self, \"foo(100, x for x in range(10))\")\n\n    def test_comprehension_specials(self):\n        # test for outmost iterable precomputation\n        x = 10; g = (i for i in range(x)); x = 5\n        self.assertEqual(len(list(g)), 10)\n\n        # This should hold, since we're only precomputing outmost iterable.\n        x = 10; t = False; g = ((i,j) for i in range(x) if t for j in range(x))\n        x = 5; t = True;\n        self.assertEqual([(i,j) for i in range(10) for j in range(5)], list(g))\n\n        # Grammar allows multiple adjacent 'if's in listcomps and genexps,\n        # even though it's silly. Make sure it works (ifelse broke this.)\n        self.assertEqual([ x for x in range(10) if x % 2 if x % 3 ], [1, 5, 7])\n        self.assertEqual(list(x for x in range(10) if x % 2 if x % 3), [1, 5, 7])\n\n        # verify unpacking single element tuples in listcomp/genexp.\n        self.assertEqual([x for x, in [(4,), (5,), (6,)]], [4, 5, 6])\n        self.assertEqual(list(x for x, in [(7,), (8,), (9,)]), [7, 8, 9])\n\n    def test_with_statement(self):\n        class manager(object):\n            def __enter__(self):\n                return (1, 2)\n            def __exit__(self, *args):\n                pass\n\n        with manager():\n            pass\n        with manager() as x:\n            pass\n        with manager() as (x, y):\n            pass\n        with manager(), manager():\n            pass\n        with manager() as x, manager() as y:\n            pass\n        with manager() as x, manager():\n            pass\n\n    def test_if_else_expr(self):\n        # Test ifelse expressions in various cases\n        def _checkeval(msg, ret):\n            \"helper to check that evaluation of expressions is done correctly\"\n            print(msg)\n            return ret\n\n        # the next line is not allowed anymore\n        #self.assertEqual([ x() for x in lambda: True, lambda: False if x() ], [True])\n        self.assertEqual([ x() for x in (lambda: True, lambda: False) if x() ], [True])\n        self.assertEqual([ x(False) for x in (lambda x: False if x else True, lambda x: True if x else False) if x(False) ], [True])\n        self.assertEqual((5 if 1 else _checkeval(\"check 1\", 0)), 5)\n        self.assertEqual((_checkeval(\"check 2\", 0) if 0 else 5), 5)\n        self.assertEqual((5 and 6 if 0 else 1), 1)\n        self.assertEqual(((5 and 6) if 0 else 1), 1)\n        self.assertEqual((5 and (6 if 1 else 1)), 6)\n        self.assertEqual((0 or _checkeval(\"check 3\", 2) if 0 else 3), 3)\n        self.assertEqual((1 or _checkeval(\"check 4\", 2) if 1 else _checkeval(\"check 5\", 3)), 1)\n        self.assertEqual((0 or 5 if 1 else _checkeval(\"check 6\", 3)), 5)\n        self.assertEqual((not 5 if 1 else 1), False)\n        self.assertEqual((not 5 if 0 else 1), 1)\n        self.assertEqual((6 + 1 if 1 else 2), 7)\n        self.assertEqual((6 - 1 if 1 else 2), 5)\n        self.assertEqual((6 * 2 if 1 else 4), 12)\n        self.assertEqual((6 / 2 if 1 else 3), 3)\n        self.assertEqual((6 < 4 if 0 else 2), 2)\n\n    def test_paren_evaluation(self):\n        self.assertEqual(16 // (4 // 2), 8)\n        self.assertEqual((16 // 4) // 2, 2)\n        self.assertEqual(16 // 4 // 2, 2)\n        self.assertTrue(False is (2 is 3))\n        self.assertFalse((False is 2) is 3)\n        self.assertFalse(False is 2 is 3)\n\n    def test_matrix_mul(self):\n        # This is not intended to be a comprehensive test, rather just to be few\n        # samples of the @ operator in test_grammar.py.\n        class M:\n            def __matmul__(self, o):\n                return 4\n            def __imatmul__(self, o):\n                self.other = o\n                return self\n        m = M()\n        self.assertEqual(m @ m, 4)\n        m @= 42\n        self.assertEqual(m.other, 42)\n\n    def test_async_await(self):\n        async def test():\n            def sum():\n                pass\n            if 1:\n                await someobj()\n\n        self.assertEqual(test.__name__, 'test')\n        self.assertTrue(bool(test.__code__.co_flags & inspect.CO_COROUTINE))\n\n        def decorator(func):\n            setattr(func, '_marked', True)\n            return func\n\n        @decorator\n        async def test2():\n            return 22\n        self.assertTrue(test2._marked)\n        self.assertEqual(test2.__name__, 'test2')\n        self.assertTrue(bool(test2.__code__.co_flags & inspect.CO_COROUTINE))\n\n    def test_async_for(self):\n        class Done(Exception): pass\n\n        class AIter:\n            def __aiter__(self):\n                return self\n            async def __anext__(self):\n                raise StopAsyncIteration\n\n        async def foo():\n            async for i in AIter():\n                pass\n            async for i, j in AIter():\n                pass\n            async for i in AIter():\n                pass\n            else:\n                pass\n            raise Done\n\n        with self.assertRaises(Done):\n            foo().send(None)\n\n    def test_async_with(self):\n        class Done(Exception): pass\n\n        class manager:\n            async def __aenter__(self):\n                return (1, 2)\n            async def __aexit__(self, *exc):\n                return False\n\n        async def foo():\n            async with manager():\n                pass\n            async with manager() as x:\n                pass\n            async with manager() as (x, y):\n                pass\n            async with manager(), manager():\n                pass\n            async with manager() as x, manager() as y:\n                pass\n            async with manager() as x, manager():\n                pass\n            raise Done\n\n        with self.assertRaises(Done):\n            foo().send(None)\n\n\nif __name__ == '__main__':\n    unittest.main()"
}